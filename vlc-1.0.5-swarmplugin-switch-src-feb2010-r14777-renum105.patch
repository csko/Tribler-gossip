diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/arno-compile-mingw32.sh ./bindings/python/arno-compile-mingw32.sh
--- /arno/build/vlc-1.0.5/bindings/python/arno-compile-mingw32.sh	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/arno-compile-mingw32.sh	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,20 @@
+#
+# VLC docs (http://wiki.videolan.org/Python_bindings) say that 
+#    python setup.py build --compiler=mingw32
+#
+# will compile the bindings. This currently doesn't work for me. 
+# Instead:
+#  1. Obtain Python 2.5.4 source, extract in one dir above vlc source
+#     dir. 
+#  2. Remove test for cross-compilation from test %zd printf() format
+#     support from Python's configure script.
+#  3. Configure Python for cross-compile:
+#  $ ./configure --host=mingw32 --with-gcc=i586-mingw32msvc-gcc --with-cxx=i586-mingw32msvc-g++ --enable-shared --with-threads
+# 4. Obtain python25.dll for Python 2.5.4 from \windows\system32 after
+#    Python 2.5.4 binary installer was run on a Windows box, put in 
+#    one dir above vlc source dir.
+# 5. Run below commands:
+#
+
+i586-mingw32msvc-gcc -mthreads -fno-strict-aliasing -g -O3 -Wall -Wstrict-prototypes  -I../.. -I./../../include -I/usr/win32/include -I../../../Python-2.5.4 -I../../../Python-2.5.4/Include -c ./vlc_module.c -o ../../bindings/python/./vlc_module.o -D_FILE_OFFSET_BITS=64 -D__USE_UNIX98 -D_LARGEFILE64_SOURCE -D_REENTRANT -D_THREAD_SAFE -D_GNU_SOURCE  -O3 -ffast-math -funroll-loops -mtune=pentium2 -g
+i586-mingw32msvc-g++  -Wsign-compare -Wall -mms-bitfields -pipe -shared ../../bindings/python/./vlc_module.o ../../src/.libs/libvlc.dll.a ../../../python25.dll -o ../../bindings/python/vlc.pyd -g -lkernel32 -L/usr/win32/lib -liconv /usr/win32/lib/libintl.a /usr/win32/lib/libiconv.a -lws2_32 -lnetapi32 -lwinmm -mwindows 
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/debian/control ./bindings/python/debian/control
--- /arno/build/vlc-1.0.5/bindings/python/debian/control	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/debian/control	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,15 @@
+Source: python-vlc
+Section: contrib/libs
+Priority: optional
+Maintainer: Jason Scheunemann <jason.scheunemann@yahoo.com>
+Build-Depends: cdbs, debhelper (>= 7), python-central (>=0.5.6), python-setuptools, python-dev, libvlc-dev (>= 1.0.0)
+XS-Python-Version: 2.5
+Standards-Version: 3.8.0
+Homepage: http://wiki.videolan.org/PythonBinding
+
+Package: python-vlc
+Architecture: any
+XB-Python-Version: ${python:Versions}
+Depends: ${python:Depends}, ${misc:Depends}, vlc (>= 1.0.0)
+Description: VLC bindings for python.
+ VLC bindings for python.
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/debian/rules ./bindings/python/debian/rules
--- /arno/build/vlc-1.0.5/bindings/python/debian/rules	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/debian/rules	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,8 @@
+#!/usr/bin/make -f
+
+DEB_PYTHON_SYSTEM=pycentral
+
+include /usr/share/cdbs/1/rules/debhelper.mk
+include /usr/share/cdbs/1/class/python-distutils.mk
+
+# Add here any variable or target overrides you need.
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/GIT-VERSION ./bindings/python/GIT-VERSION
--- /arno/build/vlc-1.0.5/bindings/python/GIT-VERSION	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/GIT-VERSION	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,3 @@
+commit 2eeddcf4ae267ad5b2bbac5d518a69c51104cf68
+Author: RÃ©mi Duraffort <ivoire@videolan.org>
+Date:   Tue Aug 25 12:28:49 2009 +0200
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/MANIFEST.in ./bindings/python/MANIFEST.in
--- /arno/build/vlc-1.0.5/bindings/python/MANIFEST.in	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/MANIFEST.in	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,7 @@
+include vlcglue.h
+include vlc_mediacontrol.c
+include vlc_position.c
+include vlc_instance.c
+include vlc_mediaplayer.c
+include vlc_media.c
+include vlcwidget.py
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/python-vlc.spec ./bindings/python/python-vlc.spec
--- /arno/build/vlc-1.0.5/bindings/python/python-vlc.spec	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/python-vlc.spec	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,71 @@
+%define name python-vlc
+%define version 1.0.0.90
+%define unmangled_version 1.0.0.90
+%define release 1
+%{!?python_sitelib: %global python_sitelib %(%{__python} -c "from distutils.sysconfig import get_python_lib; print get_python_lib()")}
+
+Summary: VLC bindings for python.
+Name: %{name}
+Version: %{version}
+Release: %{release}
+Source0: %{name}-%{unmangled_version}.tar.gz
+License: GPL
+Group: Development/Libraries
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroot
+Prefix: %{_prefix}
+Vendor: Olivier Aubert <olivier.aubert@liris.cnrs.fr>
+Url: http://wiki.videolan.org/PythonBinding
+
+%description
+VLC bindings for python.
+
+This module provides bindings for the native libvlc API of the VLC
+video player. Documentation can be found on the VLC wiki :
+http://wiki.videolan.org/ExternalAPI
+
+This module also provides a MediaControl object, which implements an
+API inspired from the OMG Audio/Video Stream 1.0 specification.
+Documentation can be found on the VLC wiki :
+http://wiki.videolan.org/PythonBinding
+
+Example session (for the MediaControl API):
+
+import vlc
+mc=vlc.MediaControl(['--verbose', '1'])
+mc.playlist_add_item('movie.mpg')
+
+# Start the movie at 2000ms
+p=vlc.Position()
+p.origin=vlc.RelativePosition
+p.key=vlc.MediaTime
+p.value=2000
+mc.start(p)
+# which could be abbreviated as
+# mc.start(2000)
+# for the default conversion from int is to make a RelativePosition in MediaTime
+
+# Display some text during 2000ms
+mc.display_text('Some useless information', 0, 2000)
+
+# Pause the video
+mc.pause(0)
+
+# Get status information
+mc.get_stream_information()
+       
+
+%prep
+%setup -n %{name}-%{unmangled_version}
+
+%build
+env CFLAGS="$RPM_OPT_FLAGS" python setup.py build
+
+%install
+python setup.py install --root=$RPM_BUILD_ROOT --record=INSTALLED_FILES
+
+%clean
+rm -rf $RPM_BUILD_ROOT
+
+%files -f INSTALLED_FILES
+%defattr(-,root,root)
+%{python_sitelib}/vlcwidget.pyo
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/README ./bindings/python/README
--- /arno/build/vlc-1.0.5/bindings/python/README	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/README	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,21 @@
+* Testing
+
+If you try to compile the bindings from a development tree, you will
+have to specify the path for VLC modules, which cannot be guessed by
+the extension module (and are hardcoded for a standard installation,
+i.e. /usr/lib/vlc on *NIX)
+
+For vlc.MediaControl:
+mc=vlc.MediaControl('--plugin-path /path/to/vlc/directory'.split())
+
+For vlc.Instance:
+i=vlc.Instance('--plugin-path /path/to/vlc/directory'.split())
+
+* Skeleton generation (for developers of the module):
+
+** For method bindings:
+
+perl -n -e 'print "static PyObject *\nvlcInput_$2( PyObject *self, PyObject *args )\n{\n    libvlc_exception_t ex;\n    LIBVLC_TRY;\n    $1_$2( self->p_input, &ex);    LIBVLC_EXCEPT;\n    Py_INCREF( Py_None );\n    return Py_None;\n}\n\n" if /(libvlc_input)_(\w+)/ and ($2 ne "t")' ../../include/vlc/libvlc.h 
+
+** For method table:
+perl -n -e 'print "    { \"$2\", $1_$2, METH_VARARGS,\n      \"$2()\" },\n" if /^(vlcInstance)_(\w+)/' vlc_instance.c 
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/setup.py ./bindings/python/setup.py
--- /arno/build/vlc-1.0.5/bindings/python/setup.py	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/setup.py	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,134 @@
+from distutils.core import setup, Extension
+import os
+import commands
+
+# Get build variables (buildir, srcdir)
+top_builddir = os.path.join( '..', '..' )
+os.environ['top_builddir'] = top_builddir
+
+# Determine the extra link args. Normally, vlc-config should take care
+# of this and return the right path values, from a development tree or
+# an installed version.
+libtool=False
+linkargs=[]
+d=os.path.join(top_builddir, 'src', '.libs')
+if os.path.exists(d):
+    # We are in a development tree, which was compiled with libtool
+    libtool=True
+    linkargs=[ '-L' + d ]
+else:
+    d=os.path.join(top_builddir, 'src')
+    # We are in a development tree, which was compiled without libtool
+    if os.path.exists(d):
+        linkargs=[ '-L' + d ]
+
+# For out-of-tree compilations
+srcdir = '.'
+
+def get_vlcconfig():
+    vlcconfig=None
+    for n in ( 'vlc-config',
+               os.path.join( top_builddir, 'vlc-config' )):
+        if os.path.exists(n):
+            vlcconfig=n
+            break
+    status, output = commands.getstatusoutput('pkg-config libvlc --exists')
+    if status == 0:
+        vlcconfig="pkg-config libvlc"
+    if vlcconfig is None:
+        print "*** Warning *** Cannot find vlc-config. Will try sane defaults."
+    elif os.sys.platform == 'win32':
+        # Win32 does not know how to invoke the shell itself.
+        vlcconfig="sh %s" % vlcconfig
+    return vlcconfig
+
+def get_vlc_version():
+    vlcconfig=get_vlcconfig()
+    if vlcconfig is None:
+        return ""
+    else:
+        version=os.popen('%s --modversion' % vlcconfig, 'r').readline().strip()
+        return version
+
+def get_cflags():
+    vlcconfig=get_vlcconfig()
+    if vlcconfig is None:
+        return []
+    else:
+        cflags=os.popen('%s --cflags ' % vlcconfig, 'r').readline().strip()
+        return cflags
+
+def get_ldflags():
+    vlcconfig=get_vlcconfig()
+    if vlcconfig is None:
+        return [ '-lvlc' ]
+    else:
+	ldflags = []
+	if os.sys.platform == 'darwin':
+	    ldflags = "-read_only_relocs warning".split()
+        ldflags.extend(os.popen('%s --libs ' % vlcconfig,
+                                'r').readline().rstrip().split())
+	if os.sys.platform == 'darwin':
+	    ldflags.append('-lstdc++')
+        return ldflags
+
+#source_files = [ 'vlc_module.c', 'vlc_mediacontrol.c',
+#                 'vlc_position.c', 'vlc_instance.c', 'vlc_input.c' ]
+source_files = [ 'vlc_module.c' ]
+
+# To compile in a local vlc tree
+vlclocal = Extension('vlc',
+                     sources = [ os.path.join( srcdir, f ) for f in source_files ],
+                     include_dirs = [ top_builddir, os.path.join(top_builddir,"include"),
+                                      srcdir ],
+                     extra_objects = [ ],
+                     extra_compile_args = get_cflags(),
+                     extra_link_args = linkargs + get_ldflags(),
+                     )
+
+setup (name = 'python-vlc',
+       version = '1.0.0.90',
+       author='Olivier Aubert',
+       author_email='olivier.aubert@liris.cnrs.fr',
+       url='http://wiki.videolan.org/PythonBinding',
+       py_modules=['vlcwidget'],
+       keywords = [ 'vlc', 'video' ],
+       license = "GPL",
+       description = "VLC bindings for python.",
+       long_description = """VLC bindings for python.
+
+This module provides bindings for the native libvlc API of the VLC
+video player. Documentation can be found on the VLC wiki :
+http://wiki.videolan.org/ExternalAPI
+
+This module also provides a MediaControl object, which implements an
+API inspired from the OMG Audio/Video Stream 1.0 specification.
+Documentation can be found on the VLC wiki :
+http://wiki.videolan.org/PythonBinding
+
+Example session (for the MediaControl API):
+
+import vlc
+mc=vlc.MediaControl(['--verbose', '1'])
+mc.playlist_add_item('movie.mpg')
+
+# Start the movie at 2000ms
+p=vlc.Position()
+p.origin=vlc.RelativePosition
+p.key=vlc.MediaTime
+p.value=2000
+mc.start(p)
+# which could be abbreviated as
+# mc.start(2000)
+# for the default conversion from int is to make a RelativePosition in MediaTime
+
+# Display some text during 2000ms
+mc.display_text('Some useless information', 0, 2000)
+
+# Pause the video
+mc.pause(0)
+
+# Get status information
+mc.get_stream_information()
+       """,
+       ext_modules = [ vlclocal ])
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/vlcglue.h ./bindings/python/vlcglue.h
--- /arno/build/vlc-1.0.5/bindings/python/vlcglue.h	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/vlcglue.h	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,162 @@
+/*****************************************************************************
+ * vlcglue.h: Main header for the Python binding
+ *****************************************************************************
+ * Copyright (C) 1998-2004 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *          ClÃ©ment Stenac <zorglub@videolan.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#ifndef _VLCGLUE_H
+#define _VLCGLUE_H 1
+
+#include <Python.h>
+#include "structmember.h"
+
+#include <stdio.h>
+#include <vlc/vlc.h>
+#include <vlc/libvlc.h>
+#include <vlc/mediacontrol_structures.h>
+#include <vlc/mediacontrol.h>
+
+/* Python 2.5 64-bit support compatibility define */
+#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
+typedef int Py_ssize_t;
+#define PY_SSIZE_T_MAX INT_MAX
+#define PY_SSIZE_T_MIN INT_MIN
+#endif
+
+
+/**********************************************************************
+ * Exceptions handling
+ **********************************************************************/
+
+#define MC_TRY exception=mediacontrol_exception_create( )
+
+#define MC_EXCEPT  \
+  if( exception && exception->code ) { \
+    PyObject *py_exc = MediaControl_InternalException; \
+    switch( exception->code ) { \
+    case mediacontrol_InternalException: \
+      py_exc = MediaControl_InternalException; \
+      break; \
+    case mediacontrol_PlaylistException: \
+      py_exc = MediaControl_PlaylistException; \
+      break; \
+    case mediacontrol_InvalidPosition: \
+      py_exc = MediaControl_InvalidPosition; \
+      break; \
+    case mediacontrol_PositionKeyNotSupported: \
+      py_exc = MediaControl_PositionKeyNotSupported; \
+      break; \
+    case mediacontrol_PositionOriginNotSupported: \
+      py_exc = MediaControl_PositionOriginNotSupported; \
+      break; \
+    } \
+    PyErr_SetString( py_exc, exception->message ); \
+    mediacontrol_exception_free( exception ); \
+    return NULL; \
+  } else if( exception ) { mediacontrol_exception_free( exception ); }
+
+PyObject *MediaControl_InternalException;
+PyObject *MediaControl_PositionKeyNotSupported;
+PyObject *MediaControl_PositionOriginNotSupported;
+PyObject *MediaControl_InvalidPosition;
+PyObject *MediaControl_PlaylistException;
+PyObject *vlc_Exception;
+
+/**********************************************************************
+ * vlc.Instance Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    libvlc_instance_t* p_instance;
+} vlcInstance;
+
+/**********************************************************************
+ * MediaControl Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    mediacontrol_Instance* mc;
+    vlcInstance *vlc_instance;
+} MediaControl;
+
+/**********************************************************************
+ * Position Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    int origin;
+    int key;
+    PY_LONG_LONG value;
+} PyPosition;
+
+/**********************************************************************
+ * vlc.MediaPlayer Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    libvlc_media_player_t* p_mp;
+} vlcMediaPlayer;
+
+/**********************************************************************
+ * vlc.Media Object
+ **********************************************************************/
+typedef struct
+{
+    PyObject_HEAD
+    libvlc_media_t* p_media;
+} vlcMedia;
+
+/* Forward declarations */
+staticforward PyTypeObject MediaControl_Type;
+staticforward PyTypeObject PyPosition_Type;
+staticforward PyTypeObject vlcInstance_Type;
+staticforward PyTypeObject vlcMediaPlayer_Type;
+staticforward PyTypeObject vlcMedia_Type;
+
+#define LIBVLC_INSTANCE(self) (((vlcInstance*)self)->p_instance)
+#define LIBVLC_MEDIAPLAYER(self) (((vlcMediaPlayer*)self)->p_mp)
+#define LIBVLC_MEDIA(self) (((vlcMedia*)self)->p_media)
+#define LIBVLC_MC(self) (((MediaControl*)self)->mc)
+
+#define LIBVLC_TRY libvlc_exception_init( &ex );
+
+#define LIBVLC_EXCEPT if( libvlc_exception_raised( &ex ) ) { \
+    PyObject *py_exc = vlc_Exception; \
+    PyErr_SetString( py_exc, libvlc_exception_get_message( &ex ) ); \
+    return NULL; \
+  }
+
+mediacontrol_PositionKey positionKey_py_to_c( PyObject * py_key );
+mediacontrol_PositionOrigin positionOrigin_py_to_c( PyObject * py_origin );
+mediacontrol_Position * position_py_to_c( PyObject * py_position );
+PyPosition * position_c_to_py( mediacontrol_Position * position );
+
+/* Long long conversion on Mac os X/ppc */
+#if defined (__ppc__) || defined(__ppc64__)
+#define ntohll(x) ((long long) x >> 64)
+#else
+#define ntohll(x) (x)
+#endif
+
+#endif
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/vlc_instance.c ./bindings/python/vlc_instance.c
--- /arno/build/vlc-1.0.5/bindings/python/vlc_instance.c	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/vlc_instance.c	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,611 @@
+/*****************************************************************************
+ * vlc_instance.c: vlc.Instance binding
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/* Helper functions */
+static Py_ssize_t
+pyoptions_to_args(PyObject *py_options, char*** pppsz_args)
+{
+    Py_ssize_t i_size;
+    Py_ssize_t  i_index;
+
+    Py_INCREF( py_options );
+    if( ! PySequence_Check( py_options ) )
+    {
+        PyErr_SetString( PyExc_TypeError, "Parameter must be a sequence." );
+        return -1;
+    }
+    i_size = PySequence_Size( py_options );
+
+    char **ppsz_args = *pppsz_args = malloc( ( i_size + 1 ) * sizeof( char * ) );
+
+    if( ! ppsz_args )
+    {
+        PyErr_SetString( PyExc_MemoryError, "Out of memory" );
+        return -1;
+    }
+
+    for ( i_index = 0; i_index < i_size; i_index++ )
+    {
+        ppsz_args[i_index] =
+            strdup( PyString_AsString( PyObject_Str(
+                                           PySequence_GetItem( py_options,
+                                                               i_index ) ) ) );
+    }
+    ppsz_args[i_size] = NULL;
+    Py_DECREF( py_options );
+    return i_size;
+}
+
+static void
+free_args(int i_size, char** ppsz_args)
+{
+    int i_index;
+
+    for ( i_index = 0; i_index < i_size; i_index++ )
+        free( ppsz_args[i_index] );
+    free( ppsz_args );
+}
+
+/*****************************************************************************
+ * Instance object implementation
+ *****************************************************************************/
+
+static PyObject *
+vlcInstance_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
+{
+    vlcInstance *self;
+    libvlc_exception_t ex;
+    PyObject* py_list = NULL;
+    char** ppsz_args = NULL;
+    int i_size = 0;
+
+    fprintf(stderr, "Instantiating\n");
+    if( PyArg_ParseTuple( args, "|O", &py_list ) )
+    {
+        i_size = pyoptions_to_args( py_list, &ppsz_args );
+        if( i_size < 0 )
+            return NULL;
+    }
+    else
+    {
+        /* No arguments were given. Clear the exception raised
+           by PyArg_ParseTuple. */
+        PyErr_Clear( );
+    }
+
+    self = PyObject_New( vlcInstance, &vlcInstance_Type );
+
+    Py_BEGIN_ALLOW_THREADS
+    LIBVLC_TRY
+    LIBVLC_INSTANCE(self) = libvlc_new( i_size, ppsz_args, &ex );
+    free_args( i_size, ppsz_args );
+    LIBVLC_EXCEPT
+    Py_END_ALLOW_THREADS
+
+    Py_INCREF( self );
+    return ( PyObject * )self;
+}
+
+static void
+vlcInstance_dealloc( PyObject *self )
+{
+    libvlc_release( LIBVLC_INSTANCE(self) );
+    PyObject_DEL( self );
+}
+
+static PyObject *
+vlcInstance_get_vlc_id( PyObject *self, PyObject *args )
+{
+    return Py_BuildValue( "i", libvlc_get_vlc_id( LIBVLC_INSTANCE(self) ) );
+}
+
+static PyObject *
+vlcInstance_new_media_player( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_media_player_t *p_mp;
+    vlcMediaPlayer *p_ret;
+
+    LIBVLC_TRY;
+    p_mp = libvlc_media_player_new( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+
+    p_ret = PyObject_New( vlcMediaPlayer, &vlcMediaPlayer_Type );
+    p_ret->p_mp = p_mp;
+    Py_INCREF( p_ret ); /* Ah bon ? */
+    return ( PyObject * )p_ret;
+}
+
+static PyObject *
+vlcInstance_audio_toggle_mute( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    LIBVLC_TRY;
+    libvlc_audio_toggle_mute( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_audio_get_mute( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_audio_get_mute( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcInstance_audio_set_mute( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_mute;
+
+    if( !PyArg_ParseTuple( args, "i", &i_mute ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_audio_set_mute( LIBVLC_INSTANCE(self), i_mute, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_audio_get_volume( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_audio_get_volume( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcInstance_audio_set_volume( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_volume;
+
+    if( !PyArg_ParseTuple( args, "i", &i_volume ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_audio_set_volume( LIBVLC_INSTANCE(self), i_volume, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_audio_get_channel( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_audio_get_channel( LIBVLC_INSTANCE(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcInstance_audio_set_channel( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_channel;
+
+    if( !PyArg_ParseTuple( args, "i", &i_channel ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_audio_set_channel( LIBVLC_INSTANCE(self), i_channel, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+/* vlm_add_broadcast : name, input MRL, output MRL
+   Keywords: options, enable, loop */
+static PyObject *
+vlcInstance_vlm_add_broadcast( PyObject *self, PyObject *args, PyObject *kwds )
+{
+    libvlc_exception_t ex;
+    static char *kwlist[] = { "name", "input", "output",
+                              "options", "enable", "loop", NULL};
+    char* psz_name = NULL;
+    char* psz_input = NULL;
+    char* psz_output = NULL;
+    PyObject* py_options = NULL;
+    int i_enable = 1;
+    int i_loop = 0;
+    int i_size = 0;
+    char** ppsz_args = NULL;
+
+    if( !PyArg_ParseTupleAndKeywords( args, kwds, "sss|Oii", kwlist,
+                                      &psz_name,
+                      &psz_input, &psz_output,
+                      &py_options, &i_enable, &i_loop ) )
+        return NULL;
+
+    if( py_options )
+    {
+        i_size = pyoptions_to_args( py_options, &ppsz_args );
+    }
+
+    LIBVLC_TRY;
+    libvlc_vlm_add_broadcast( LIBVLC_INSTANCE(self),
+                              psz_name, psz_input, psz_output,
+                              i_size, ppsz_args, i_enable, i_loop, &ex);
+    free_args( i_size, ppsz_args );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_del_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_del_media( LIBVLC_INSTANCE(self), psz_name, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_set_enabled( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    int i_enabled;
+
+    if( !PyArg_ParseTuple( args, "si", &psz_name, &i_enabled ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_set_enabled( LIBVLC_INSTANCE(self), psz_name, i_enabled, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_set_output( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    char* psz_output;
+
+    if( !PyArg_ParseTuple( args, "ss", &psz_name, &psz_output ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_set_output( LIBVLC_INSTANCE(self), psz_name, psz_output, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_set_input( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    char* psz_input;
+
+    if( !PyArg_ParseTuple( args, "ss", &psz_name, &psz_input ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_set_input( LIBVLC_INSTANCE(self), psz_name, psz_input, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_add_input( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    char* psz_input;
+
+    if( !PyArg_ParseTuple( args, "ss", &psz_name, &psz_input ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_add_input( LIBVLC_INSTANCE(self), psz_name, psz_input, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_set_loop( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    int i_loop;
+
+    if( !PyArg_ParseTuple( args, "si", &psz_name, &i_loop ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_set_loop( LIBVLC_INSTANCE(self), psz_name, i_loop, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_change_media( PyObject *self, PyObject *args, PyObject *kwds )
+{
+    libvlc_exception_t ex;
+    static char *kwlist[] = { "name", "input", "output",
+                              "options", "enable", "loop", NULL};
+    char* psz_name = NULL;
+    char* psz_input = NULL;
+    char* psz_output = NULL;
+    PyObject* py_options = NULL;
+    int i_enable = 1;
+    int i_loop = 0;
+    int i_size = 0;
+    char** ppsz_args = NULL;
+
+    if( !PyArg_ParseTupleAndKeywords( args, kwds, "sss|Oii", kwlist,
+                                      &psz_name,
+                      &psz_input, &psz_output,
+                      &py_options, &i_enable, &i_loop ) )
+        return NULL;
+
+    if( py_options )
+    {
+        i_size = pyoptions_to_args( py_options, &ppsz_args );
+    }
+
+    LIBVLC_TRY;
+    libvlc_vlm_change_media( LIBVLC_INSTANCE(self),
+                              psz_name, psz_input, psz_output,
+                              i_size, ppsz_args, i_enable, i_loop, &ex);
+    free_args( i_size, ppsz_args );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_play_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_play_media( LIBVLC_INSTANCE(self), psz_name, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_stop_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_stop_media( LIBVLC_INSTANCE(self), psz_name, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_pause_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_pause_media( LIBVLC_INSTANCE(self), psz_name, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_seek_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    float f_percentage;
+
+    if( !PyArg_ParseTuple( args, "sf", &psz_name, &f_percentage ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_vlm_seek_media( LIBVLC_INSTANCE(self), psz_name, f_percentage, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcInstance_vlm_show_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_name;
+    char* psz_ret;
+    PyObject* o_ret;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_name ) )
+        return NULL;
+    LIBVLC_TRY;
+    psz_ret = libvlc_vlm_show_media( LIBVLC_INSTANCE(self), psz_name, &ex );
+    LIBVLC_EXCEPT;
+    o_ret = Py_BuildValue( "s", psz_ret );
+    free( psz_ret );
+    return o_ret;
+}
+
+static PyObject *
+vlcInstance_media_new( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_media_t *p_media;
+    char* psz_mrl = NULL;
+    vlcMedia *p_ret;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_mrl ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    p_media = libvlc_media_new( LIBVLC_INSTANCE(self), psz_mrl, &ex );
+    LIBVLC_EXCEPT;
+
+    p_ret = PyObject_New( vlcMedia, &vlcMedia_Type );
+    p_ret->p_media = p_media;
+    Py_INCREF( p_ret ); /* Ah bon ? */
+    return ( PyObject * )p_ret;
+}
+
+/* Method table */
+static PyMethodDef vlcInstance_methods[] =
+{
+    { "get_vlc_id", vlcInstance_get_vlc_id, METH_NOARGS,
+      "get_vlc_id( ) -> int        Get the instance id."},
+    { "audio_toggle_mute", vlcInstance_audio_toggle_mute, METH_NOARGS,
+      "audio_toggle_mute()         Toggle the mute state"},
+    { "audio_get_mute", vlcInstance_audio_get_mute, METH_NOARGS,
+      "audio_get_mute() -> int     Get the mute state"},
+    { "audio_set_mute", vlcInstance_audio_set_mute, METH_VARARGS,
+      "audio_set_mute(state=int)         Set the mute state"},
+    { "audio_get_volume", vlcInstance_audio_get_volume, METH_NOARGS,
+      "audio_get_volume() -> int   Get the audio volume"},
+    { "audio_set_volume", vlcInstance_audio_set_volume, METH_VARARGS,
+      "audio_set_volume(volume=int)       Set the audio volume"},
+    { "audio_get_channel", vlcInstance_audio_get_channel, METH_NOARGS,
+      "audio_get_channel() -> int  Get current audio channel" },
+    { "audio_set_channel", vlcInstance_audio_set_channel, METH_VARARGS,
+      "audio_set_channel(int)      Set current audio channel" },
+
+    { "media_new", vlcInstance_media_new, METH_VARARGS,
+      "media_new(str) -> object   Create a media object with the given mrl."},
+
+    { "mediaplayer_new", vlcInstance_new_media_player, METH_NOARGS,
+      "mediaplayer_new() -> object   Create a media player."},
+
+    { "vlm_add_broadcast", vlcInstance_vlm_add_broadcast, METH_VARARGS | METH_KEYWORDS,
+      "vlm_add_broadcast(name=str, input=str, output=str, options=list, enable=int, loop=int)   Add a new broadcast" },
+    { "vlm_del_media", vlcInstance_vlm_del_media, METH_VARARGS,
+      "vlm_del_media(name=str)    Delete a media" },
+    { "vlm_set_enabled", vlcInstance_vlm_set_enabled, METH_VARARGS,
+      "vlm_set_enabled(name=str, enabled=int)    Enable/disable a media" },
+    { "vlm_set_output", vlcInstance_vlm_set_output, METH_VARARGS,
+      "vlm_set_output(name=str, output=str)      Set the output" },
+    { "vlm_set_input", vlcInstance_vlm_set_input, METH_VARARGS,
+      "vlm_set_input(name=str, output=str)       Set the input" },
+    { "vlm_add_input", vlcInstance_vlm_add_input, METH_VARARGS,
+      "vlm_add_input(name=str, output=str)       Add a media's input MRL" },
+    { "vlm_set_loop", vlcInstance_vlm_set_loop, METH_VARARGS,
+      "vlm_set_loop(name=str, loop=int)          Change the looping value" },
+    { "vlm_change_media", vlcInstance_vlm_change_media, METH_VARARGS | METH_KEYWORDS,
+      "vlm_change_media(name=str, input=str, output=str, options=list, enable=int, loop=int)   Change the broadcast parameters" },
+    { "vlm_play_media", vlcInstance_vlm_play_media, METH_VARARGS,
+      "vlm_play_media(name=str)       Plays the named broadcast." },
+    { "vlm_stop_media", vlcInstance_vlm_stop_media, METH_VARARGS,
+      "vlm_stop_media(name=str)       Stops the named broadcast." },
+    { "vlm_pause_media", vlcInstance_vlm_pause_media, METH_VARARGS,
+      "vlm_pause_media(name=str)      Pauses the named broadcast." },
+    { "vlm_seek_media", vlcInstance_vlm_seek_media, METH_VARARGS,
+      "vlm_seek_media(name=str, percentage=float)  Seeks in the named broadcast." },
+    { "vlm_show_media", vlcInstance_vlm_show_media, METH_VARARGS,
+      "vlm_show_media(name=str)       Return information of the named broadcast." },
+
+    { NULL, NULL, 0, NULL },
+};
+
+static PyTypeObject vlcInstance_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                          /*ob_size*/
+    "vlc.Instance",             /*tp_name*/
+    sizeof( vlcInstance_Type ), /*tp_basicsize*/
+    0,                          /*tp_itemsize*/
+    ( destructor )vlcInstance_dealloc,      /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "VLC Instance(args)",  /* tp_doc */
+    0,                     /* tp_traverse */
+    0,                     /* tp_clear */
+    0,                     /* tp_richcompare */
+    0,                     /* tp_weaklistoffset */
+    0,                     /* tp_iter */
+    0,                     /* tp_iternext */
+    vlcInstance_methods,             /* tp_methods */
+    0,             /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    vlcInstance_new,          /* tp_new */
+};
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/vlc_media.c ./bindings/python/vlc_media.c
--- /arno/build/vlc-1.0.5/bindings/python/vlc_media.c	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/vlc_media.c	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,228 @@
+/*****************************************************************************
+ * vlc_media.c: vlc.Media binding
+ *****************************************************************************
+ * Copyright (C) 2007 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/***********************************************************************
+ * vlc.Media
+ ***********************************************************************/
+
+static PyObject *
+vlcMedia_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
+{
+    fprintf(stderr, "vlcMedia_new called\n");
+    PyErr_SetString( PyExc_TypeError, "vlc.Media can be instantiated by itself. You should use vlc.Instance().media_new(mrl)." );
+    return NULL;
+}
+
+static void
+vlcMedia_dealloc( PyObject *self )
+{
+    libvlc_media_release( LIBVLC_MEDIA(self) );
+    PyObject_DEL( self );
+}
+
+static PyObject *
+vlcMedia_add_option( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_options = NULL;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_options ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_add_option( LIBVLC_MEDIA(self), psz_options, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMedia_get_mrl( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char * psz_mrl;
+    PyObject * o_ret;
+
+    LIBVLC_TRY;
+    psz_mrl = libvlc_media_get_mrl( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+
+    o_ret = Py_BuildValue( "s", psz_mrl );
+    free( psz_mrl );
+    return o_ret;
+}
+
+static PyObject *
+vlcMedia_get_state( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_state_t i_state;
+
+    LIBVLC_TRY;
+    i_state = libvlc_media_get_state( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+    /* FIXME: return the defined state constant */
+    return Py_BuildValue( "i", i_state );
+}
+
+static PyObject *
+vlcMedia_get_duration( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_time_t i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_get_duration( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "L", i_ret );
+}
+
+static PyObject *
+vlcMedia_media_player_new( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_media_player_t *p_mp;
+    vlcMediaPlayer *p_ret;
+
+    LIBVLC_TRY;
+    p_mp = libvlc_media_player_new_from_media( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+
+    p_ret = PyObject_New( vlcMediaPlayer, &vlcMediaPlayer_Type );
+    p_ret->p_mp = p_mp;
+    Py_INCREF( p_ret ); /* Ah bon ? */
+    return ( PyObject * )p_ret;
+}
+
+static PyObject *
+vlcMedia_is_preparsed( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_is_preparsed( LIBVLC_MEDIA(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "L", i_ret );
+}
+
+static PyObject *
+vlcMedia_get_meta( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char * psz_meta = NULL;
+    char * psz_ret = NULL;
+    PyObject* o_ret;
+    int i_index = -1;
+    int i_loop = 0;
+    static const char * meta_names[] = { "Title", "Artist", "Genre", "Copyright", "Album", "TrackNumber", "Description", "Rating", "Date", "Setting", "URL", "Language", "NowPlaying", "Publisher", "EncodedBy", "ArtworkURL", "TrackID", NULL };
+
+    if( !PyArg_ParseTuple( args, "s", &psz_meta ) )
+        return NULL;
+    while( meta_names[i_loop] )
+    {
+        if( !strncmp(meta_names[i_loop], psz_meta, strlen(meta_names[i_loop])) )
+        {
+            i_index = i_loop;
+            break;
+        }
+        i_loop++;
+    }
+    if( i_index < 0 )
+    {
+        PyObject *py_exc = vlc_Exception;
+        PyErr_SetString( py_exc, "Unknown meta attribute" );
+        return NULL;
+    }
+
+    LIBVLC_TRY;
+    psz_ret = libvlc_media_get_meta( LIBVLC_MEDIA(self), i_index, &ex);
+    LIBVLC_EXCEPT;
+
+    o_ret = Py_BuildValue( "s", psz_ret );
+    free( psz_ret );
+    return o_ret;
+}
+
+static PyMethodDef vlcMedia_methods[] =
+{
+    { "add_option", vlcMedia_add_option, METH_VARARGS,
+      "add_option(str) Add an option to the media." },
+    { "get_mrl", vlcMedia_get_mrl, METH_VARARGS,
+      "get_mrl() -> str" },
+    { "get_state", vlcMedia_get_state, METH_VARARGS,
+      "get_state() -> int" },
+    { "get_duration", vlcMedia_get_duration, METH_VARARGS,
+      "get_duration() -> int" },
+    { "mediaplayer_new", vlcMedia_media_player_new, METH_VARARGS,
+      "mediaplayer_new() -> vlc.MediaPlayer   Create a MediaPlayer object from a Media" },
+    { "is_preparsed", vlcMedia_is_preparsed, METH_VARARGS,
+      "is_preparsed() -> int" },
+    { "get_meta", vlcMedia_get_meta, METH_VARARGS,
+      "get_meta(str) -> str   Read the meta of the media." },
+
+    { NULL }  /* Sentinel */
+};
+
+static PyTypeObject vlcMedia_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                         /*ob_size*/
+    "vlc.Media",            /*tp_name*/
+    sizeof( vlcMedia_Type ),   /*tp_basicsize*/
+    0,                         /*tp_itemsize*/
+    vlcMedia_dealloc, /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "vlc.Media object.",  /* tp_doc */
+    0,                        /* tp_traverse */
+    0,                        /* tp_clear */
+    0,                         /* tp_richcompare */
+    0,                         /* tp_weaklistoffset */
+    0,                         /* tp_iter */
+    0,                          /* tp_iternext */
+    vlcMedia_methods,          /* tp_methods */
+    0,                         /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    vlcMedia_new,              /* tp_new */
+};
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/vlc_mediacontrol.c ./bindings/python/vlc_mediacontrol.c
--- /arno/build/vlc-1.0.5/bindings/python/vlc_mediacontrol.c	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/vlc_mediacontrol.c	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,760 @@
+/*****************************************************************************
+ * vlc_mediacontrol.c: vlc.MediaControl binding
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/*****************************************************************************
+ * VLC MediaControl object implementation
+ *****************************************************************************/
+
+/* The MediaControl constructor takes either an existing vlc.Instance or a
+   list of strings */
+static PyObject *
+MediaControl_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
+{
+    MediaControl *self;
+    mediacontrol_Exception *exception = NULL;
+    PyObject* py_param = NULL;
+    char** ppsz_args = NULL;
+    libvlc_instance_t* p_instance = NULL;
+    Py_ssize_t i_size = 0;
+
+    self = PyObject_New( MediaControl, &MediaControl_Type );
+
+    fprintf (stderr, "Instantiating mediacontrol\n");
+    if( PyArg_ParseTuple( args, "O", &py_param ) )
+    {
+        if( PyObject_TypeCheck( py_param, &vlcInstance_Type ) == 1 )
+        {
+            p_instance = ((vlcInstance*)py_param)->p_instance;
+        }
+        else
+        {
+            Py_ssize_t i_index;
+
+            Py_INCREF( py_param );
+            if( ! PySequence_Check( py_param ) )
+            {
+                PyErr_SetString( PyExc_TypeError, "Parameter must be a vlc.Instance or a sequence of strings." );
+                Py_DECREF( py_param );
+                return NULL;
+            }
+            i_size = PySequence_Size( py_param );
+            ppsz_args = malloc( ( i_size + 1 ) * sizeof( char * ) );
+            if( ! ppsz_args )
+            {
+                PyErr_SetString( PyExc_MemoryError, "Out of memory" );
+                Py_DECREF( py_param );
+                return NULL;
+            }
+
+            for ( i_index = 0; i_index < i_size; i_index++ )
+            {
+                ppsz_args[i_index] =
+                    strdup( PyString_AsString( PyObject_Str(
+                                                   PySequence_GetItem( py_param,
+                                                                       i_index ) ) ) );
+            }
+            ppsz_args[i_size] = NULL;
+            Py_DECREF( py_param );
+        }
+    }
+    else
+    {
+        /* No arguments were given. Clear the exception raised
+           by PyArg_ParseTuple. */
+        PyErr_Clear( );
+    }
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    if( p_instance )
+    {
+        self->mc = mediacontrol_new_from_instance( p_instance, exception );
+        Py_INCREF( py_param );
+        self->vlc_instance = ( vlcInstance* ) py_param;
+    }
+    else
+    {
+        self->mc = mediacontrol_new( i_size, ppsz_args, exception );
+        self->vlc_instance = PyObject_New( vlcInstance, &vlcInstance_Type );
+        self->vlc_instance->p_instance = mediacontrol_get_libvlc_instance( LIBVLC_MC(self) );
+    }
+    MC_EXCEPT;
+    Py_END_ALLOW_THREADS
+
+    Py_INCREF( self );
+    return ( PyObject * )self;
+}
+
+static void
+MediaControl_dealloc( PyObject *self )
+{
+    fprintf(stderr, "MC dealloc\n");
+    Py_DECREF( ((MediaControl*)self)->vlc_instance );
+    PyObject_DEL( self );
+}
+
+static PyObject *
+MediaControl_get_vlc_instance( PyObject *self, PyObject *args )
+{
+    vlcInstance *p_ret;
+
+    p_ret = ((MediaControl*)self)->vlc_instance;
+    Py_INCREF( p_ret );
+    return ( PyObject * )p_ret;
+}
+
+static PyObject *
+MediaControl_get_mediaplayer( PyObject *self, PyObject *args )
+{
+    vlcMediaPlayer *p_ret;
+
+    p_ret = PyObject_New( vlcMediaPlayer, &vlcMediaPlayer_Type );
+    p_ret->p_mp = mediacontrol_get_media_player( LIBVLC_MC(self) );
+    Py_INCREF( p_ret );
+    return ( PyObject * )p_ret;
+}
+
+/**
+ *  Return the current position in the stream. The returned value can
+   be relative or absolute ( according to PositionOrigin ) and the unit
+   is set by PositionKey
+ */
+static PyObject *
+MediaControl_get_media_position( PyObject *self, PyObject *args )
+{
+    mediacontrol_Position* pos;
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_origin;
+    PyObject *py_key;
+    PyObject *py_retval;
+    mediacontrol_PositionOrigin origin;
+    mediacontrol_PositionKey key;
+
+    if( !PyArg_ParseTuple( args, "OO", &py_origin, &py_key ) )
+        return NULL;
+
+    origin = positionOrigin_py_to_c( py_origin );
+    key    = positionKey_py_to_c( py_key );
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    pos = mediacontrol_get_media_position( LIBVLC_MC(self), origin, key, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = ( PyObject* )position_c_to_py( pos );
+    free( pos );
+    return py_retval;
+}
+
+/** Set the media position */
+static PyObject *
+MediaControl_set_media_position( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    mediacontrol_Position *a_position;
+    PyObject *py_pos;
+
+    if( !PyArg_ParseTuple( args, "O", &py_pos ) )
+        return NULL;
+
+    a_position = position_py_to_c( py_pos );
+    if( !a_position )
+    {
+        PyErr_SetString( PyExc_MemoryError, "Out of memory" );
+        return NULL;
+    }
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_media_position( LIBVLC_MC(self), a_position, exception );
+    free( a_position );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_start( PyObject *self, PyObject *args )
+{
+    mediacontrol_Position *a_position;
+    mediacontrol_Exception *exception = NULL;
+    PyObject *py_pos;
+
+    if( !PyArg_ParseTuple( args, "O", &py_pos ) )
+    {
+        /* No argument. Use a default 0 value. */
+        PyErr_Clear( );
+        py_pos = NULL;
+    }
+    a_position = position_py_to_c( py_pos );
+    if( !a_position )
+        return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_start( LIBVLC_MC(self), a_position, exception );
+    free( a_position );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_pause( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception *exception = NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_pause( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+  Py_INCREF( Py_None );
+  return Py_None;
+}
+
+static PyObject *
+MediaControl_resume( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception *exception = NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_resume( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_stop( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception *exception = NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_stop( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_exit( PyObject *self, PyObject *args )
+{
+    mediacontrol_exit( LIBVLC_MC(self) );
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_set_mrl( PyObject *self, PyObject *args )
+{
+    char *psz_file;
+    mediacontrol_Exception *exception = NULL;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_file ) )
+      return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_mrl( LIBVLC_MC(self), psz_file, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+MediaControl_get_mrl( PyObject *self, PyObject *args )
+{
+    PyObject *py_retval;
+    char* psz_file;
+    mediacontrol_Exception *exception = NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    psz_file = mediacontrol_get_mrl( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = Py_BuildValue( "s", psz_file );
+    free( psz_file );
+    return py_retval;
+}
+
+static PyObject *
+MediaControl_snapshot( PyObject *self, PyObject *args )
+{
+    mediacontrol_RGBPicture *p_retval = NULL;
+    mediacontrol_Exception* exception = NULL;
+    mediacontrol_Position *a_position = NULL;
+    PyObject *py_pos = NULL;
+    PyObject *py_obj = NULL;
+
+    if( !PyArg_ParseTuple( args, "O", &py_pos ) )
+      return NULL;
+
+    a_position = position_py_to_c( py_pos );
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    p_retval = mediacontrol_snapshot( LIBVLC_MC(self), a_position, exception );
+    free( a_position );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    if( !p_retval )
+    {
+        Py_INCREF( Py_None );
+        return Py_None;
+    }
+
+    /* FIXME: create a real RGBPicture object */
+    py_obj = PyDict_New();
+
+    PyDict_SetItemString( py_obj, "width",
+                          Py_BuildValue( "i", p_retval->width ) );
+    PyDict_SetItemString( py_obj, "height",
+                          Py_BuildValue( "i", p_retval->height ) );
+    PyDict_SetItemString( py_obj, "type",
+                          Py_BuildValue( "i", p_retval->type ) );
+    PyDict_SetItemString( py_obj, "data",
+                          Py_BuildValue( "s#", p_retval->data, p_retval->size ) );
+    PyDict_SetItemString( py_obj, "date",
+                          Py_BuildValue( "L", p_retval->date ) );
+
+    mediacontrol_RGBPicture__free( p_retval );
+
+    return py_obj;
+}
+
+static PyObject*
+MediaControl_display_text( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_begin, *py_end;
+    char* message;
+    mediacontrol_Position * begin;
+    mediacontrol_Position * end;
+
+    if( !PyArg_ParseTuple( args, "sOO", &message, &py_begin, &py_end ) )
+        return NULL;
+
+    begin = position_py_to_c( py_begin );
+    end   = position_py_to_c( py_end );
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_display_text( LIBVLC_MC(self), message, begin, end, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    free( begin );
+    free( end );
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject*
+MediaControl_get_stream_information( PyObject *self, PyObject *args )
+{
+    mediacontrol_StreamInformation *retval  = NULL;
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_obj;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    retval = mediacontrol_get_stream_information(
+        LIBVLC_MC(self), mediacontrol_MediaTime, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_obj = PyDict_New( );
+
+     /* FIXME: create a real StreamInformation object */
+    PyDict_SetItemString( py_obj, "status",
+                  Py_BuildValue( "i", retval->streamstatus ) );
+    PyDict_SetItemString( py_obj, "url",
+                  Py_BuildValue( "s", retval->url ) );
+    PyDict_SetItemString( py_obj, "position",
+                  Py_BuildValue( "L", retval->position ) );
+    PyDict_SetItemString( py_obj, "length",
+                  Py_BuildValue( "L", retval->length ) );
+
+    mediacontrol_StreamInformation__free( retval );
+
+    return py_obj;
+}
+
+static PyObject*
+MediaControl_sound_set_volume( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    unsigned short volume;
+
+    if( !PyArg_ParseTuple( args, "H", &volume ) )
+        return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_sound_set_volume( LIBVLC_MC(self), volume, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject*
+MediaControl_sound_get_volume( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_retval;
+    unsigned short volume;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    volume = mediacontrol_sound_get_volume( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = Py_BuildValue( "H", volume );
+    return py_retval;
+}
+
+static PyObject*
+MediaControl_set_rate( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    int rate;
+
+    if( !PyArg_ParseTuple( args, "i", &rate ) )
+        return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_rate( LIBVLC_MC(self), rate, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject*
+MediaControl_get_rate( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_retval;
+    int rate;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    rate = mediacontrol_get_rate( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = Py_BuildValue( "i", rate );
+    return py_retval;
+}
+
+static PyObject*
+MediaControl_set_fullscreen( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    int fs;
+
+    if( !PyArg_ParseTuple( args, "i", &fs ) )
+        return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_fullscreen( LIBVLC_MC(self), fs, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject*
+MediaControl_get_fullscreen( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    PyObject *py_retval;
+    int fs;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    fs = mediacontrol_get_fullscreen( LIBVLC_MC(self), exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    py_retval = Py_BuildValue( "i", fs );
+    return py_retval;
+}
+
+static PyObject*
+MediaControl_set_visual( PyObject *self, PyObject *args )
+{
+    mediacontrol_Exception* exception = NULL;
+    WINDOWHANDLE visual;
+
+    if( !PyArg_ParseTuple( args, "i", &visual ) )
+       return NULL;
+
+    Py_BEGIN_ALLOW_THREADS
+    MC_TRY;
+    mediacontrol_set_visual( LIBVLC_MC(self), visual, exception );
+    Py_END_ALLOW_THREADS
+    MC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+
+/*
+ *  added by Ivaylo
+ */
+
+/* see
+ http://docs.python.org/api/api.html
+ http://www.python.org/doc/current/ext/callingPython.html
+ http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65210
+ http://www.suttoncourtenay.org.uk/duncan/accu/integratingpython.html */
+
+
+static int read_callback_wrapper(uint8_t *p_data, int i_data, int id)
+{
+    int retvalue = 0;
+	PyObject *py_buffer = NULL;
+	PyObject *result = NULL;
+	PyGILState_STATE gstate;
+
+
+	gstate = PyGILState_Ensure();
+
+	/* Convert the arguments to a writable buffer object */
+	py_buffer = PyBuffer_FromReadWriteMemory(p_data, i_data);
+
+    if (PyErr_Occurred()) {
+		Py_XDECREF(py_buffer);
+		PyGILState_Release(gstate);
+		return 0;
+    }
+
+    /* Build up the argument list...  */
+
+
+	if (!PyCallable_Check(py_read_callback)) {
+		PyGILState_Release(gstate);
+		return 0;
+	}
+
+    /* ...for calling the Python callback read function. */
+    result = PyObject_CallFunction(py_read_callback,"Oii", py_buffer, i_data, id);
+    if (result && PyInt_Check(result)) {
+        retvalue = PyInt_AsLong(result);
+    }
+    Py_XDECREF(result);
+    Py_XDECREF(py_buffer);
+	PyGILState_Release(gstate);
+
+    return retvalue;
+}
+
+static int seek_callback_wrapper(int64_t i_pos, int id)
+{
+    int retvalue = 0;
+	PyObject *arglist;
+	PyObject *result = NULL;
+	PyGILState_STATE gstate;
+
+	gstate = PyGILState_Ensure();
+
+
+    /* Build up the argument list...  */
+    arglist = Py_BuildValue("(Li)", i_pos, id); // Arno, 2009-08-25: was (li), incorrect, pos is long long int
+
+    /* ...for calling the Python callback seek function. */
+    result = PyEval_CallObject(py_seek_callback,arglist);
+
+    if (result && PyInt_Check(result)) {
+        retvalue = PyInt_AsLong(result);
+    }
+
+    Py_XDECREF(result);
+    Py_DECREF(arglist);
+
+	PyGILState_Release(gstate);
+    return retvalue;
+}
+
+static PyObject *
+MediaControl_set_raw_callbacks(PyObject *self, PyObject *args)
+{
+    PyObject *py_read_cbk;
+    PyObject *py_seek_cbk;
+	int i_fsize;
+	int id;
+    mediacontrol_Exception *exception = NULL;
+
+    if (!PyArg_ParseTuple(args, "OOii", &py_read_cbk, &py_seek_cbk, &i_fsize, &id))
+        return NULL;
+
+    /* make sure the arguments are functions */
+    if (!PyCallable_Check(py_read_cbk) || !PyCallable_Check(py_seek_cbk))
+        PyErr_SetString(PyExc_TypeError, "Need a callable object!");
+    else {
+		Py_XINCREF(py_read_cbk);
+		Py_XINCREF(py_seek_cbk);
+		Py_XDECREF(py_read_callback);
+		Py_XDECREF(py_read_callback);
+		/* set the global callback pointers */
+		py_read_callback = py_read_cbk;
+		py_seek_callback = py_seek_cbk;
+
+		Py_BEGIN_ALLOW_THREADS
+		MC_TRY;
+		/* announce the callbacks to the raw access module */
+		mediacontrol_set_raw_callbacks( LIBVLC_MC(self),
+			read_callback_wrapper, seek_callback_wrapper, i_fsize, id, exception );
+
+		Py_END_ALLOW_THREADS
+	    MC_EXCEPT;
+
+    }
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+
+static PyMethodDef MediaControl_methods[] =
+{
+    { "get_vlc_instance", MediaControl_get_vlc_instance, METH_VARARGS,
+      "get_vlc_instance( ) -> Instance    Get embedded vlc.Instance." },
+    { "get_mediaplayer", MediaControl_get_mediaplayer, METH_VARARGS,
+      "get_mediaplayer( ) -> MediaPlayer    Get embedded vlc.MediaPlayer." },
+    { "get_media_position", MediaControl_get_media_position, METH_VARARGS,
+      "get_media_position( origin, key ) -> Position    Get current media position." },
+    { "set_media_position", MediaControl_set_media_position, METH_VARARGS,
+      "set_media_position( Position )            Set media position" },
+    { "start", MediaControl_start, METH_VARARGS,
+      "start( Position )         Start the player." },
+    { "pause", MediaControl_pause, METH_VARARGS,
+      "pause( Position )         Pause the player." },
+    { "resume", MediaControl_resume, METH_VARARGS,
+      "resume( Position )        Resume the player" },
+    { "stop", MediaControl_stop, METH_VARARGS,
+      "stop( Position )              Stop the player" },
+    { "exit", MediaControl_exit, METH_VARARGS,
+      "exit( )                     Exit the player" },
+    { "set_mrl", MediaControl_set_mrl, METH_VARARGS,
+      "set_mrl( str )               Set the file to be played" },
+    { "get_mrl", MediaControl_get_mrl, METH_VARARGS,
+      "get_mrl( ) -> str       Get the played file" },
+    { "snapshot", MediaControl_snapshot, METH_VARARGS,
+      "snapshot( Position ) -> dict        Take a snapshot" },
+    { "display_text", MediaControl_display_text, METH_VARARGS,
+      "display_text( str, Position, Position )    Display a text on the video" },
+    { "get_stream_information", MediaControl_get_stream_information,
+      METH_VARARGS,
+      "get_stream_information( ) -> dict      Get information about the stream"},
+    { "sound_get_volume", MediaControl_sound_get_volume, METH_VARARGS,
+      "sound_get_volume( ) -> int       Get the volume" },
+    { "sound_set_volume", MediaControl_sound_set_volume, METH_VARARGS,
+      "sound_set_volume( int )           Set the volume" },
+    { "set_visual", MediaControl_set_visual, METH_VARARGS,
+      "set_visual( int )           Set the embedding window visual ID" },
+    { "get_rate", MediaControl_get_rate, METH_VARARGS,
+      "get_rate( ) -> int       Get the rate" },
+    { "set_rate", MediaControl_set_rate, METH_VARARGS,
+      "set_rate( int )              Set the rate" },
+    { "get_fullscreen", MediaControl_get_fullscreen, METH_VARARGS,
+      "get_fullscreen( ) -> int       Get the fullscreen status" },
+    { "set_fullscreen", MediaControl_set_fullscreen, METH_VARARGS,
+      "set_fullscreen( int )              Set the fullscreen status" },
+     { "set_raw_callbacks", MediaControl_set_raw_callbacks, METH_VARARGS,
+        "set_raw_callbacks(read_cbk, seek_cbk, fsize, id)     Set the callbacks for the raw access method" }, /* added by Ivaylo */
+    { NULL, NULL, 0, NULL },
+};
+
+static PyTypeObject MediaControl_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                         /*ob_size*/
+    "vlc.MediaControl",        /*tp_name*/
+    sizeof( MediaControl_Type ), /*tp_basicsize*/
+    0,                         /*tp_itemsize*/
+    ( destructor )MediaControl_dealloc,      /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "Control of a VLC instance.\n\nvlc.MediaControl(args): initialisation with a list of VLC parameters.\nvlc.MediaControl(instance): initialisation with an existing vlc.Instance",  /* tp_doc */
+    0,                     /* tp_traverse */
+    0,                     /* tp_clear */
+    0,                     /* tp_richcompare */
+    0,                     /* tp_weaklistoffset */
+    0,                     /* tp_iter */
+    0,                     /* tp_iternext */
+    MediaControl_methods,             /* tp_methods */
+    0,             /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    MediaControl_new,          /* tp_new */
+};
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/vlc_mediaplayer.c ./bindings/python/vlc_mediaplayer.c
--- /arno/build/vlc-1.0.5/bindings/python/vlc_mediaplayer.c	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/vlc_mediaplayer.c	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,706 @@
+/*****************************************************************************
+ * vlc_mediaplayer.c: vlc.MediaPlayer binding
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/***********************************************************************
+ * vlc.Input
+ ***********************************************************************/
+
+static PyObject *
+vlcMediaPlayer_get_length( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int64_t i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_length( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "L", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_time( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int64_t i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_time( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "L", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_time( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int64_t i_time;
+
+    if( !PyArg_ParseTuple( args, "L", &i_time ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_time( LIBVLC_MEDIAPLAYER(self), i_time, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_position( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_ret;
+    LIBVLC_TRY;
+    f_ret = libvlc_media_player_get_position( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "f", f_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_position( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_pos;
+
+    if( !PyArg_ParseTuple( args, "f", &f_pos ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_position( LIBVLC_MEDIAPLAYER(self), f_pos, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_will_play( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_will_play( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_rate( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_ret;
+    LIBVLC_TRY;
+    f_ret = libvlc_media_player_get_rate( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "f", f_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_rate( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_rate;
+
+    if( !PyArg_ParseTuple( args, "f", &f_rate ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_rate( LIBVLC_MEDIAPLAYER(self), f_rate, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_state( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_state( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_has_vout( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_has_vout( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_fps( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    float f_ret;
+    LIBVLC_TRY;
+    f_ret = libvlc_media_player_get_fps( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "f", f_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_audio_get_track( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_audio_get_track( LIBVLC_MEDIAPLAYER(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_audio_set_track( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_track;
+
+    if( !PyArg_ParseTuple( args, "i", &i_track ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_audio_set_track( LIBVLC_MEDIAPLAYER(self), i_track, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_chapter( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_chapter( LIBVLC_MEDIAPLAYER(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_chapter_count( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_get_chapter_count( LIBVLC_MEDIAPLAYER(self), &ex );
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_chapter( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_chapter;
+
+    if( !PyArg_ParseTuple( args, "i", &i_chapter ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_chapter( LIBVLC_MEDIAPLAYER(self), i_chapter, &ex );
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+
+static PyObject *
+vlcMediaPlayer_toggle_fullscreen( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+
+    LIBVLC_TRY;
+    libvlc_toggle_fullscreen( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_set_fullscreen( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_fullscreen;
+
+    if( !PyArg_ParseTuple( args, "i", &i_fullscreen ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_set_fullscreen( LIBVLC_MEDIAPLAYER(self), i_fullscreen, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_fullscreen( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_get_fullscreen( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_height( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_video_get_height( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_width( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+
+    LIBVLC_TRY;
+    i_ret = libvlc_video_get_width( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_get_aspect_ratio( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_ret;
+    PyObject* o_ret;
+
+    LIBVLC_TRY;
+    psz_ret = libvlc_video_get_aspect_ratio( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    o_ret=Py_BuildValue( "s", psz_ret );
+    free( psz_ret );
+    return o_ret;
+}
+
+static PyObject *
+vlcMediaPlayer_set_aspect_ratio( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_ratio;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_ratio ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_video_set_aspect_ratio( LIBVLC_MEDIAPLAYER(self), psz_ratio, &ex);
+    LIBVLC_EXCEPT;
+    free( psz_ratio );
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_video_take_snapshot( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    char* psz_filename;
+
+    if( !PyArg_ParseTuple( args, "s", &psz_filename ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_video_take_snapshot( LIBVLC_MEDIAPLAYER(self), psz_filename, 0, 0, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_is_seekable( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_is_seekable( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_can_pause( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_media_player_can_pause( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_play( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+
+    LIBVLC_TRY;
+    libvlc_media_player_play( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_pause( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+
+    LIBVLC_TRY;
+    libvlc_media_player_pause( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_stop( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+
+    LIBVLC_TRY;
+    libvlc_media_player_stop( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_set_xwindow( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    uint32_t i_drawable;
+
+    if( !PyArg_ParseTuple( args, "i", &i_drawable ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_xwindow( LIBVLC_MEDIAPLAYER(self), i_drawable, &ex );
+    LIBVLC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_xwindow( PyObject *self, PyObject *args )
+{
+    uint32_t i_ret;
+
+    i_ret = libvlc_media_player_get_xwindow( LIBVLC_MEDIAPLAYER(self));
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_hwnd( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    void* i_drawable;
+
+    if( !PyArg_ParseTuple( args, "l", &i_drawable ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_hwnd( LIBVLC_MEDIAPLAYER(self), (void*) i_drawable, &ex );
+    LIBVLC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_hwnd( PyObject *self, PyObject *args )
+{
+    void* i_ret;
+
+    i_ret = libvlc_media_player_get_hwnd( LIBVLC_MEDIAPLAYER(self));
+    return Py_BuildValue( "l", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_agl( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    uint32_t i_drawable;
+
+    if( !PyArg_ParseTuple( args, "i", &i_drawable ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_agl( LIBVLC_MEDIAPLAYER(self), i_drawable, &ex );
+    LIBVLC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_agl( PyObject *self, PyObject *args )
+{
+    uint32_t i_ret;
+
+    i_ret = libvlc_media_player_get_agl( LIBVLC_MEDIAPLAYER(self));
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_nsobject( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    void* i_drawable;
+
+    if( !PyArg_ParseTuple( args, "l", &i_drawable ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_media_player_set_nsobject( LIBVLC_MEDIAPLAYER(self), (void*) i_drawable, &ex );
+    LIBVLC_EXCEPT;
+
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+static PyObject *
+vlcMediaPlayer_get_nsobject( PyObject *self, PyObject *args )
+{
+    void* i_ret;
+
+    i_ret = libvlc_media_player_get_nsobject( LIBVLC_MEDIAPLAYER(self));
+    return Py_BuildValue( "l", i_ret );
+}
+
+
+static PyObject *
+vlcMediaPlayer_set_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    PyObject* py_param = NULL;
+
+    if( !PyArg_ParseTuple( args, "O", &py_param ) )
+        return NULL;
+    if( PyObject_TypeCheck( py_param, &vlcMedia_Type ) == 1 )
+    {
+        LIBVLC_TRY;
+        libvlc_media_player_set_media( LIBVLC_MEDIAPLAYER(self), ((vlcMedia*)py_param)->p_media, &ex );
+        LIBVLC_EXCEPT;
+    }
+    else
+    {
+        PyObject *py_exc = vlc_Exception;
+        PyErr_SetString( py_exc, "vlc.Media parameter needed" );
+        return NULL;
+    }
+    return NULL;
+}
+
+static PyObject *
+vlcMediaPlayer_get_media( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    libvlc_media_t *p_media;
+    vlcMedia *p_ret;
+
+    LIBVLC_TRY;
+    p_media = libvlc_media_player_get_media( LIBVLC_MEDIAPLAYER(self), &ex );
+    LIBVLC_EXCEPT;
+
+    if( !p_media )
+    {
+        Py_INCREF( Py_None );
+        return Py_None;
+    }
+    else
+    {
+        p_ret = PyObject_New( vlcMedia, &vlcMedia_Type );
+        p_ret->p_media = p_media;
+        Py_INCREF( p_ret ); /* Ah bon ? */
+        return ( PyObject * )p_ret;
+    }
+}
+
+static PyObject *
+vlcMediaPlayer_get_spu( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_ret;
+    LIBVLC_TRY;
+    i_ret = libvlc_video_get_spu( LIBVLC_MEDIAPLAYER(self), &ex);
+    LIBVLC_EXCEPT;
+    return Py_BuildValue( "i", i_ret );
+}
+
+static PyObject *
+vlcMediaPlayer_set_spu( PyObject *self, PyObject *args )
+{
+    libvlc_exception_t ex;
+    int i_spu;
+
+    if( !PyArg_ParseTuple( args, "i", &i_spu ) )
+        return NULL;
+
+    LIBVLC_TRY;
+    libvlc_video_set_spu( LIBVLC_MEDIAPLAYER(self), i_spu, &ex);
+    LIBVLC_EXCEPT;
+    Py_INCREF( Py_None );
+    return Py_None;
+}
+
+
+static PyMethodDef vlcMediaPlayer_methods[] =
+{
+    { "get_length", vlcMediaPlayer_get_length, METH_VARARGS,
+      "get_length() -> long    " },
+    { "get_time", vlcMediaPlayer_get_time, METH_VARARGS,
+      "get_time() -> long" },
+    { "set_time", vlcMediaPlayer_set_time, METH_VARARGS,
+      "set_time(long)" },
+    { "get_position", vlcMediaPlayer_get_position, METH_VARARGS,
+      "get_position() -> float" },
+    { "set_position", vlcMediaPlayer_set_position, METH_VARARGS,
+      "set_position(float)" },
+    { "will_play", vlcMediaPlayer_will_play, METH_VARARGS,
+      "will_play() -> int" },
+    { "is_seekable", vlcMediaPlayer_is_seekable, METH_VARARGS,
+      "is_seekable() -> int" },
+    { "can_pause", vlcMediaPlayer_can_pause, METH_VARARGS,
+      "can_pause() -> int" },
+    { "get_rate", vlcMediaPlayer_get_rate, METH_VARARGS,
+      "get_rate() -> float" },
+    { "set_rate", vlcMediaPlayer_set_rate, METH_VARARGS,
+      "set_rate(float)" },
+    { "get_state", vlcMediaPlayer_get_state, METH_VARARGS,
+      "get_state() -> int" },
+    { "has_vout", vlcMediaPlayer_has_vout, METH_VARARGS,
+      "has_vout() -> int" },
+    { "get_fps", vlcMediaPlayer_get_fps, METH_VARARGS,
+      "get_fps() -> float" },
+    { "audio_get_track", vlcMediaPlayer_audio_get_track, METH_VARARGS,
+      "audio_get_track() -> int    Get current audio track" },
+    { "audio_set_track", vlcMediaPlayer_audio_set_track, METH_VARARGS,
+      "audio_set_track(int)        Set current audio track" },
+    { "toggle_fullscreen", vlcMediaPlayer_toggle_fullscreen, METH_VARARGS,
+      "toggle_fullscreen()    Toggle fullscreen status on video output" },
+    { "set_fullscreen", vlcMediaPlayer_set_fullscreen, METH_VARARGS,
+      "set_fullscreen(bool)    Enable or disable fullscreen on a video output" },
+    { "get_fullscreen", vlcMediaPlayer_get_fullscreen, METH_VARARGS,
+      "get_fullscreen() -> bool    Get current fullscreen status" },
+    { "get_height", vlcMediaPlayer_get_height, METH_VARARGS,
+      "get_height() -> int           Get current video height" },
+    { "get_width", vlcMediaPlayer_get_width, METH_VARARGS,
+      "get_width() -> int           Get current video width" },
+    { "get_aspect_ratio", vlcMediaPlayer_get_aspect_ratio, METH_VARARGS,
+      "get_aspect_ratio() -> str    Get current video aspect ratio" },
+    { "set_aspect_ratio", vlcMediaPlayer_set_aspect_ratio, METH_VARARGS,
+      "set_aspect_ratio(str)        Set new video aspect ratio" },
+    { "video_take_snapshot", vlcMediaPlayer_video_take_snapshot, METH_VARARGS,
+      "video_take_snapshot(filename=str)        Take a snapshot of the current video window" },
+
+    { "play", vlcMediaPlayer_play, METH_VARARGS,
+      "play()    Play the media instance" },
+    { "pause", vlcMediaPlayer_pause, METH_VARARGS,
+      "pause()   Pause the media instance" },
+    { "stop", vlcMediaPlayer_stop, METH_VARARGS,
+      "stop()    Stop the media instance" },
+#ifdef OLD
+    { "set_drawable", vlcMediaPlayer_set_drawable, METH_VARARGS,
+      "set_drawable()    Set the drawable id" },
+#endif
+    { "get_chapter", vlcMediaPlayer_get_chapter, METH_VARARGS,
+      "get_chapter() -> int    Get current chapter" },
+    { "set_chapter", vlcMediaPlayer_set_chapter, METH_VARARGS,
+      "set_chapter(int)        Set current chapter" },
+    { "get_chapter_count", vlcMediaPlayer_get_chapter_count, METH_VARARGS,
+      "get_chapter_count() -> int    Get current chapter count" },
+
+    { "set_media", vlcMediaPlayer_set_media, METH_VARARGS,
+      "set_media(vlc.Media)        Set the media that will be used by the media_player" },
+    { "get_media", vlcMediaPlayer_get_media, METH_VARARGS,
+      "get_media() -> vlc.Media    Get the media used by the media_player (if any)." },
+
+    { "get_spu", vlcMediaPlayer_get_spu, METH_VARARGS,
+      "get_spu() -> int   Get current video subtitle" },
+    { "set_spu", vlcMediaPlayer_set_spu, METH_VARARGS,
+      "set_spu(int)      Set new video subtitle" },
+
+    { NULL }  /* Sentinel */
+};
+
+static PyTypeObject vlcMediaPlayer_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                         /*ob_size*/
+    "vlc.MediaPlayer",            /*tp_name*/
+    sizeof( vlcMediaPlayer_Type ),   /*tp_basicsize*/
+    0,                         /*tp_itemsize*/
+    0,                         /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "vlc.MediaPlayer object\n\nIt cannot be instantiated standalone, it must be obtained from an existing vlc.Instance object",  /* tp_doc */
+    0,                        /* tp_traverse */
+    0,                        /* tp_clear */
+    0,                         /* tp_richcompare */
+    0,                         /* tp_weaklistoffset */
+    0,                         /* tp_iter */
+    0,                          /* tp_iternext */
+    vlcMediaPlayer_methods,          /* tp_methods */
+    0,                         /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    0,                         /* tp_new */
+};
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/vlc_module.c ./bindings/python/vlc_module.c
--- /arno/build/vlc-1.0.5/bindings/python/vlc_module.c	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/vlc_module.c	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,179 @@
+/*****************************************************************************
+ * vlc_module.c: vlc python binding module
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#include "vlcglue.h"
+
+/**************************************************************************
+ * VLC Module
+ **************************************************************************/
+
+#ifndef vlcMODINIT_FUNC /* declarations for DLL import/export */
+#define vlcMODINIT_FUNC void
+#endif
+
+static PyMethodDef vlc_methods[] = {
+    { NULL }  /* Sentinel */
+};
+
+/* Module globals */
+PyObject* MediaControl_InternalException          = NULL;
+PyObject* MediaControl_PositionKeyNotSupported    = NULL;
+PyObject *MediaControl_PositionOriginNotSupported = NULL;
+PyObject* MediaControl_InvalidPosition            = NULL;
+PyObject *MediaControl_PlaylistException          = NULL;
+
+/* Added by Ivaylo */
+static PyObject* py_read_callback     = NULL;
+static PyObject* py_seek_callback     = NULL;
+/* End added by Ivaylo */
+
+
+vlcMODINIT_FUNC
+initvlc( void )
+{
+    PyObject* p_module;
+
+    /* vlcMediaPlayer_Type.tp_new = PyType_GenericNew; */
+    vlcMediaPlayer_Type.tp_alloc = PyType_GenericAlloc;
+    /* vlcMedia_Type.tp_new = PyType_GenericNew; */
+    vlcMedia_Type.tp_alloc = PyType_GenericAlloc;
+
+    vlcInstance_Type.tp_alloc = PyType_GenericAlloc;
+    MediaControl_Type.tp_alloc = PyType_GenericAlloc;
+
+    p_module = Py_InitModule3( "vlc", vlc_methods,
+                               "VLC media player embedding module." );
+
+    if( !p_module )
+      return;
+
+    if( PyType_Ready( &PyPosition_Type ) < 0 )
+        return;
+    if( PyType_Ready( &MediaControl_Type ) < 0 )
+        return;
+    if( PyType_Ready( &vlcInstance_Type ) < 0 )
+        return;
+    if( PyType_Ready( &vlcMediaPlayer_Type ) < 0 )
+        return;
+    if( PyType_Ready( &vlcMedia_Type ) < 0 )
+        return;
+
+    /* Exceptions */
+    MediaControl_InternalException =
+            PyErr_NewException( "vlc.InternalException", NULL, NULL );
+    Py_INCREF( MediaControl_InternalException );
+    PyModule_AddObject( p_module, "InternalException",
+                        MediaControl_InternalException );
+
+    MediaControl_PositionKeyNotSupported =
+            PyErr_NewException( "vlc.PositionKeyNotSupported", NULL, NULL );
+    Py_INCREF( MediaControl_PositionKeyNotSupported );
+    PyModule_AddObject( p_module, "PositionKeyNotSupported",
+                        MediaControl_PositionKeyNotSupported );
+
+    MediaControl_PositionOriginNotSupported=
+            PyErr_NewException( "vlc.InvalidPosition", NULL, NULL );
+    Py_INCREF( MediaControl_PositionOriginNotSupported );
+    PyModule_AddObject( p_module, "PositionOriginNotSupported",
+                        MediaControl_PositionOriginNotSupported );
+
+    MediaControl_InvalidPosition =
+            PyErr_NewException( "vlc.InvalidPosition", NULL, NULL );
+    Py_INCREF( MediaControl_InvalidPosition );
+    PyModule_AddObject( p_module, "InvalidPosition",
+                        MediaControl_InvalidPosition );
+
+    MediaControl_PlaylistException =
+            PyErr_NewException( "vlc.PlaylistException", NULL, NULL );
+    Py_INCREF( MediaControl_PlaylistException );
+    PyModule_AddObject( p_module, "PlaylistException",
+                        MediaControl_PlaylistException );
+
+    /* Exceptions */
+    vlc_Exception =
+        PyErr_NewException( "vlc.InstanceException", NULL, NULL );
+    Py_INCREF( vlc_Exception );
+    PyModule_AddObject( p_module, "InstanceException",
+                        vlc_Exception );
+
+    /* Types */
+    Py_INCREF( &PyPosition_Type );
+    PyModule_AddObject( p_module, "Position",
+                        ( PyObject * )&PyPosition_Type );
+
+    Py_INCREF( &MediaControl_Type );
+    PyModule_AddObject( p_module, "MediaControl",
+                        ( PyObject * )&MediaControl_Type );
+
+    Py_INCREF( &vlcInstance_Type );
+    PyModule_AddObject( p_module, "Instance",
+                        ( PyObject * )&vlcInstance_Type );
+
+    Py_INCREF( &vlcMediaPlayer_Type );
+    PyModule_AddObject( p_module, "MediaPlayer",
+                        ( PyObject * )&vlcMediaPlayer_Type );
+
+    Py_INCREF( &vlcMedia_Type );
+    PyModule_AddObject( p_module, "Media",
+                        ( PyObject * )&vlcMedia_Type );
+
+    /* Constants */
+    PyModule_AddIntConstant( p_module, "AbsolutePosition",
+                             mediacontrol_AbsolutePosition );
+    PyModule_AddIntConstant( p_module, "RelativePosition",
+                             mediacontrol_RelativePosition );
+    PyModule_AddIntConstant( p_module, "ModuloPosition",
+                             mediacontrol_ModuloPosition );
+
+    PyModule_AddIntConstant( p_module, "ByteCount",
+                             mediacontrol_ByteCount );
+    PyModule_AddIntConstant( p_module, "SampleCount",
+                             mediacontrol_SampleCount );
+    PyModule_AddIntConstant( p_module, "MediaTime",
+                             mediacontrol_MediaTime );
+
+    PyModule_AddIntConstant( p_module, "PlayingStatus",
+                             mediacontrol_PlayingStatus );
+    PyModule_AddIntConstant( p_module, "PauseStatus",
+                             mediacontrol_PauseStatus );
+    PyModule_AddIntConstant( p_module, "InitStatus",
+                             mediacontrol_InitStatus );
+    PyModule_AddIntConstant( p_module, "EndStatus",
+                             mediacontrol_EndStatus );
+    PyModule_AddIntConstant( p_module, "UndefinedStatus",
+                             mediacontrol_UndefinedStatus );
+
+}
+
+/* Horrible hack... Please do not look.  Temporary workaround for the
+   forward declaration mess of python types (cf vlcglue.h). If we do a
+   separate compilation, we have to declare some types as extern. But
+   the recommended way to forward declared types in python is
+   static... I am sorting the mess but in the meantime, this will
+   produce a working python module.
+*/
+#include "vlc_mediacontrol.c"
+#include "vlc_position.c"
+#include "vlc_instance.c"
+#include "vlc_mediaplayer.c"
+#include "vlc_media.c"
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/vlc_position.c ./bindings/python/vlc_position.c
--- /arno/build/vlc-1.0.5/bindings/python/vlc_position.c	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/vlc_position.c	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,219 @@
+/*****************************************************************************
+ * vlc_position.c: vlc.Position binding
+ *****************************************************************************
+ * Copyright (C) 2006,2007,2008,2009 the VideoLAN team
+ * $Id$
+ *
+ * Authors: Olivier Aubert <olivier.aubert at liris.cnrs.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#include "vlcglue.h"
+
+/***********************************************************************
+ * Position
+ ***********************************************************************/
+
+static PyObject *
+PyPosition_new( PyTypeObject *type, PyObject *args, PyObject *kwds )
+{
+    PyPosition *self;
+    static char *kwlist[] = { "value", "origin", "key", NULL};
+
+    self = PyObject_New( PyPosition, &PyPosition_Type );
+
+    self->value=0;
+    self->origin=mediacontrol_AbsolutePosition;
+    self->key=mediacontrol_MediaTime;
+
+    if(! PyArg_ParseTupleAndKeywords( args, kwds, "|lii", kwlist,
+                                      &(self->value),
+                                      &(self->origin),
+                                      &(self->key) ) )
+    {
+        return NULL;
+    }
+
+    if( self->key != mediacontrol_MediaTime
+    && self->key != mediacontrol_ByteCount
+    && self->key != mediacontrol_SampleCount )
+    {
+        PyErr_SetString ( MediaControl_InternalException, "Invalid key value" );
+        return NULL;
+    }
+
+    if( self->origin != mediacontrol_AbsolutePosition
+    && self->origin != mediacontrol_RelativePosition
+    && self->origin != mediacontrol_ModuloPosition )
+    {
+        PyErr_SetString ( MediaControl_InternalException, "Invalid origin value" );
+        return NULL;
+    }
+
+    Py_INCREF( self );
+    return ( PyObject * )self;
+}
+
+mediacontrol_PositionKey
+positionKey_py_to_c( PyObject * py_key )
+{
+    mediacontrol_PositionKey key_position = mediacontrol_MediaTime;
+    int key;
+
+    if( !PyArg_Parse( py_key, "i", &key ) )
+    {
+        PyErr_SetString ( MediaControl_InternalException, "Invalid key value" );
+        return key_position;
+    }
+
+    switch ( key )
+    {
+    case 0: key = mediacontrol_ByteCount;   break;
+    case 1: key = mediacontrol_SampleCount; break;
+    case 2: key = mediacontrol_MediaTime;   break;
+    }
+    return key_position;
+}
+
+mediacontrol_PositionOrigin
+positionOrigin_py_to_c( PyObject * py_origin )
+{
+    mediacontrol_PositionOrigin  origin_position = mediacontrol_AbsolutePosition;
+    int origin;
+
+    if( !PyArg_Parse( py_origin,"i", &origin ) )
+    {
+        PyErr_SetString( MediaControl_InternalException,
+                         "Invalid origin value" );
+        return origin_position;
+    }
+
+    switch ( origin )
+    {
+    case 0: origin_position = mediacontrol_AbsolutePosition; break;
+    case 1: origin_position = mediacontrol_RelativePosition; break;
+    case 2: origin_position = mediacontrol_ModuloPosition;   break;
+    }
+
+    return origin_position;
+}
+
+/* Methods for transforming the Position Python object to Position structure*/
+mediacontrol_Position*
+position_py_to_c( PyObject * py_position )
+{
+    mediacontrol_Position * a_position = NULL;
+    PyPosition *pos = ( PyPosition* )py_position;
+
+    a_position = ( mediacontrol_Position* )malloc( sizeof( mediacontrol_Position ) );
+    if( !a_position )
+    {
+        PyErr_SetString( PyExc_MemoryError, "Out of memory" );
+        return NULL;
+    }
+
+    if( !py_position )
+    {
+        /* If we give a NULL value, it will be considered as
+           a 0 relative position in mediatime */
+        a_position->origin = mediacontrol_RelativePosition;
+        a_position->key    = mediacontrol_MediaTime;
+        a_position->value  = 0;
+    }
+    else if( PyObject_IsInstance( py_position, ( PyObject* )&PyPosition_Type ) )
+    {
+        a_position->origin = pos->origin;
+        a_position->key    = pos->key;
+        a_position->value  = ntohll(pos->value);
+    }
+    else
+    {
+        /* Feature: if we give an integer, it will be considered as
+           a relative position in mediatime */
+        a_position->origin = mediacontrol_RelativePosition;
+        a_position->key    = mediacontrol_MediaTime;
+        a_position->value  = PyLong_AsLongLong( py_position );
+    }
+    return a_position;
+}
+
+PyPosition*
+position_c_to_py( mediacontrol_Position *position )
+{
+    PyPosition* py_retval;
+
+    py_retval = PyObject_New( PyPosition, &PyPosition_Type );
+    py_retval->origin = position->origin;
+    py_retval->key    = position->key;
+    py_retval->value  = position->value;
+
+    return py_retval;
+}
+
+static PyMethodDef PyPosition_methods[] =
+{
+    { NULL }  /* Sentinel */
+};
+
+static PyMemberDef PyPosition_members[] =
+{
+    { "origin", T_INT, offsetof( PyPosition, origin ), 0, "Position origin" },
+    { "key",    T_INT, offsetof( PyPosition, key ),    0, "Position key" },
+    { "value",  T_ULONG, offsetof( PyPosition, value ), 0, "Position value" },
+    { NULL }  /* Sentinel */
+};
+
+static PyTypeObject PyPosition_Type =
+{
+    PyObject_HEAD_INIT( NULL )
+    0,                         /*ob_size*/
+    "vlc.Position",            /*tp_name*/
+    sizeof( PyPosition_Type ),   /*tp_basicsize*/
+    0,                         /*tp_itemsize*/
+    0,                         /*tp_dealloc*/
+    0,                         /*tp_print*/
+    0,                         /*tp_getattr*/
+    0,                         /*tp_setattr*/
+    0,                         /*tp_compare*/
+    0,                         /*tp_repr*/
+    0,                         /*tp_as_number*/
+    0,                         /*tp_as_sequence*/
+    0,                         /*tp_as_mapping*/
+    0,                         /*tp_hash */
+    0,                         /*tp_call*/
+    0,                         /*tp_str*/
+    0,                         /*tp_getattro*/
+    0,                         /*tp_setattro*/
+    0,                         /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
+    "Represent a Position with value, origin and key",  /* tp_doc */
+    0,                        /* tp_traverse */
+    0,                        /* tp_clear */
+    0,                         /* tp_richcompare */
+    0,                         /* tp_weaklistoffset */
+    0,                         /* tp_iter */
+    0,                          /* tp_iternext */
+    PyPosition_methods,             /* tp_methods */
+    PyPosition_members,             /* tp_members */
+    0,                         /* tp_getset */
+    0,                         /* tp_base */
+    0,                         /* tp_dict */
+    0,                         /* tp_descr_get */
+    0,                         /* tp_descr_set */
+    0,                         /* tp_dictoffset */
+    0,                         /* tp_init */
+    0,                         /* tp_alloc */
+    PyPosition_new,            /* tp_new */
+};
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/bindings/python/vlcwidget.py ./bindings/python/vlcwidget.py
--- /arno/build/vlc-1.0.5/bindings/python/vlcwidget.py	1970-01-01 01:00:00.000000000 +0100
+++ ./bindings/python/vlcwidget.py	2010-02-26 14:52:34.000000000 +0100
@@ -0,0 +1,114 @@
+#! /usr/bin/python
+
+"""VLC Widget classes.
+
+This module provides two helper classes, to ease the embedding of a
+VLC component inside a pygtk application.
+
+VLCWidget is a simple VLC widget.
+
+DecoratedVLCWidget provides simple player controls.
+
+$Id$
+"""
+
+import gtk
+import sys
+import vlc
+
+from gettext import gettext as _
+
+class VLCWidget(gtk.DrawingArea):
+    """Simple VLC widget.
+
+    Its player can be controlled through the 'player' attribute, which
+    is a MediaControl instance.
+    """
+    def __init__(self, *p):
+        gtk.DrawingArea.__init__(self)
+        self.player=vlc.MediaControl(*p)
+        def handle_embed(*p):
+            if sys.platform == 'win32':
+                xidattr='handle'
+            else:
+                xidattr='xid'
+            self.player.set_visual(getattr(self.window, xidattr))
+            return True
+        self.connect("map-event", handle_embed)
+        self.set_size_request(320, 200)
+
+
+class DecoratedVLCWidget(gtk.VBox):
+    """Decorated VLC widget.
+
+    VLC widget decorated with a player control toolbar.
+
+    Its player can be controlled through the 'player' attribute, which
+    is a MediaControl instance.
+    """
+    def __init__(self, *p):
+        gtk.VBox.__init__(self)
+        self._vlc_widget=VLCWidget(*p)
+        self.player=self._vlc_widget.player
+        self.pack_start(self._vlc_widget, expand=True)
+        self._toolbar = self.get_player_control_toolbar()
+        self.pack_start(self._toolbar, expand=False)
+
+    def get_player_control_toolbar(self):
+        """Return a player control toolbar
+        """
+        tb=gtk.Toolbar()
+        tb.set_style(gtk.TOOLBAR_ICONS)
+
+        def on_play(b):
+            self.player.start(0)
+            return True
+
+        def on_stop(b):
+            self.player.stop(0)
+            return True
+
+        def on_pause(b):
+            self.player.pause(0)
+            return True
+
+        tb_list = (
+            (_("Play"), _("Play"), gtk.STOCK_MEDIA_PLAY,
+             on_play),
+            (_("Pause"), _("Pause"), gtk.STOCK_MEDIA_PAUSE,
+             on_pause),
+            (_("Stop"), _("Stop"), gtk.STOCK_MEDIA_STOP,
+             on_stop),
+            )
+
+        for text, tooltip, stock, callback in tb_list:
+            b=gtk.ToolButton(stock)
+            b.connect("clicked", callback)
+            tb.insert(b, -1)
+        tb.show_all()
+        return tb
+
+class VideoPlayer:
+    """Example video player.
+    """
+    def __init__(self):
+        self.vlc = DecoratedVLCWidget()
+
+    def main(self, fname):
+        self.vlc.player.set_mrl(fname)
+        self.popup()
+        gtk.main()
+
+    def popup(self):
+        w=gtk.Window()
+        w.add(self.vlc)
+        w.show_all()
+        w.connect("destroy", gtk.main_quit)
+        return w
+
+if __name__ == '__main__':
+    if not sys.argv[1:]:
+       print "You must provide a movie filename"
+       sys.exit(1)
+    p=VideoPlayer()
+    p.main(sys.argv[1])
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/configure.ac ./configure.ac
--- /arno/build/vlc-1.0.5/configure.ac	2010-01-24 22:26:15.000000000 +0100
+++ ./configure.ac	2010-02-26 14:53:04.000000000 +0100
@@ -5766,6 +5766,17 @@
 AC_LANG_POP(C++)
 AM_CONDITIONAL(BUILD_MOZILLA,${mozilla})
 
+dnl
+dnl  Ivaylo's special access module for raw input from Python
+dnl
+AC_ARG_ENABLE(access-raw,
+  [  --enable-access-raw     Enable raw access module (default disabled)])
+if test "${enable_access_raw}" = "yes"
+then
+  VLC_ADD_PLUGIN([access_raw])
+fi
+
+
 dnl Tests for Osso and Xsp
 AC_CHECK_LIB(osso, osso_display_blanking_pause, [
   PKG_CHECK_MODULES(GLIB2, glib-2.0, [
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/asa-git.diff ./extras/contrib/src/Patches/asa-git.diff
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/asa-git.diff	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/asa-git.diff	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,39 @@
+diff -ur asa.orig/lib/Makefile.am asa/lib/Makefile.am
+--- asa.orig/lib/Makefile.am	2007-08-31 17:26:54.000000000 +0200
++++ asa/lib/Makefile.am	2008-03-08 23:17:27.000000000 +0100
+@@ -25,7 +25,9 @@
+ 	echo obj $(objname) pic $(picname)
+ 	$(NASM) -f elf $(ASMOPT) -o ${picname} $^
+ 	$(NASM) -f elf $(ASMOPT) -DNO_PIC -o ${objname} $^
+-	echo -e "# Generated by libtool\npic_object='../${picname}'\nnon_pic_object='../${objname}'" > $@
++	echo "# Generated by libtool" > $@
++	echo "pic_object='../${picname}'" >> $@
++	echo "non_pic_object='../${objname}'" >> $@
+ 
+ noinst_HEADERS = blitter_internal.h
+ lib_LTLIBRARIES = libasa.la
+@@ -51,11 +53,12 @@
+ 	../csri/subhelp/libsubhelp_la-openfile.lo \
+ 	../csri/subhelp/libsubhelp_la-logging.lo \
+ 	import/libimport.la \
++	$(PCRE_LIBS) \
+ 	$(ASM)
+ libasa_la_LDFLAGS = -version-info 0:0:0 -no-undefined
+ 
+ install-exec-hook:
+-	test -z "$(csrilibdir)" || $(MKDIR_P) "$(DESTDIR)$(csrilibdir)"
++	test -z "$(csrilibdir)" || $(mkdir_p) "$(DESTDIR)$(csrilibdir)"
+ 	$(LN_S) $(libdir)/libasa.so.0 \
+ 		$(DESTDIR)$(csrilibdir)/asa_csri.so
+ 
+diff -ur asa.orig/lib/import/Makefile.am asa/lib/import/Makefile.am
+--- asa.orig/lib/import/Makefile.am	2007-08-31 17:26:54.000000000 +0200
++++ asa/lib/import/Makefile.am	2008-03-08 23:01:50.000000000 +0100
+@@ -1,6 +1,6 @@
+ if IMPORTS_PREP
+ noinst_PROGRAMS = preparse
+-preparse_LDFLAGS = -limportparser
++preparse_LDFLAGS = -limportparser $(PCRE_LIBS)
+ 
+ BUILT_SOURCES = imports_prep.h
+ imports_prep.h: $(srcdir)/imports libimportparser.la preparse
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/caca_driver_cocoa.diff ./extras/contrib/src/Patches/caca_driver_cocoa.diff
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/caca_driver_cocoa.diff	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/caca_driver_cocoa.diff	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,53 @@
+--- libcaca-0.99.beta13b/caca/driver_cocoa.m	2007-11-25 15:00:34.000000000 +0100
++++ libcaca/caca/driver_cocoa.m	2008-01-21 17:39:14.000000000 +0100
+@@ -3,7 +3,7 @@
+  *  Copyright (c) 2006 Colin Delacroix <colin@zoy.org>
+  *                All Rights Reserved
+  *
+- *  $Id$
++ *  $Id: driver_cocoa.m 1445 2007-12-16 01:50:41Z sam $
+  *
+  *  This library is free software. It comes without any warranty, to
+  *  the extent permitted by applicable law. You can redistribute it
+@@ -722,7 +722,7 @@
+     return caca_keycode;
+ }
+ 
+-static BOOL handle_key_event(struct caca_event *ev, NSEvent* event)
++static BOOL handle_key_event(caca_privevent_t *ev, NSEvent* event)
+ {
+     if(!ev || !event)
+         return NO;
+@@ -774,7 +774,7 @@
+ }
+ 
+ // TODO: handle CACA_EVENT_RESIZE
+-static BOOL handle_mouse_event(caca_display_t *dp, struct caca_event *ev,
++static BOOL handle_mouse_event(caca_display_t *dp, caca_privevent_t *ev,
+                                NSEvent* event)
+ {
+     if(!ev || !event)
+@@ -884,7 +884,7 @@
+     [pool release];
+ }
+ 
+-static int cocoa_get_event(caca_display_t *dp, struct caca_event *ev)
++static int cocoa_get_event(caca_display_t *dp, caca_privevent_t *ev)
+ {
+     if(s_quit)
+     {
+@@ -970,12 +970,12 @@
+     return 0;
+ }
+ 
+-static unsigned int cocoa_get_display_width(caca_display_t *dp)
++static unsigned int cocoa_get_display_width(caca_display_t const *dp)
+ {
+     return [dp->drv.p->window frame].size.width;
+ }
+ 
+-static unsigned int cocoa_get_display_height(caca_display_t *dp)
++static unsigned int cocoa_get_display_height(caca_display_t const *dp)
+ {
+     return [dp->drv.p->window frame].size.height;
+ }
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/caca_macosx.diff ./extras/contrib/src/Patches/caca_macosx.diff
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/caca_macosx.diff	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/caca_macosx.diff	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,13 @@
+Index: src/mygetopt.c
+===================================================================
+--- libcaca.orig/src/mygetopt.c	(rÃ©vision 1516)
++++ libcaca/src/mygetopt.c	(copie de travail)
+@@ -25,7 +25,7 @@
+ #endif
+ 
+ /* DOS / Kernel driver */
+-#ifndef __intptr_t_defined
++#if !defined(__intptr_t_defined) && !defined(_UINTPTR_T)
+ typedef unsigned int		uintptr_t;
+ #endif
+ 
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/ffmpeg-macosx-intel-mmx.patch ./extras/contrib/src/Patches/ffmpeg-macosx-intel-mmx.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/ffmpeg-macosx-intel-mmx.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/ffmpeg-macosx-intel-mmx.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,173 @@
+Index: libavcodec/x86/motion_est_mmx.c
+===================================================================
+--- libavcodec/x86/motion_est_mmx.c	(revision 17470)
++++ libavcodec/x86/motion_est_mmx.c	(working copy)
+@@ -168,7 +168,7 @@
+ static inline void sad8_4_mmx2(uint8_t *blk1, uint8_t *blk2, int stride, int h)
+ {
+     __asm__ volatile(
+-        "movq "MANGLE(bone)", %%mm5     \n\t"
++        "movq %4, %%mm5                 \n\t"
+         "movq (%1), %%mm0               \n\t"
+         "pavgb 1(%1), %%mm0             \n\t"
+         "add %3, %1                     \n\t"
+@@ -191,7 +191,7 @@
+         "sub $2, %0                     \n\t"
+         " jg 1b                         \n\t"
+         : "+r" (h), "+r" (blk1), "+r" (blk2)
+-        : "r" ((x86_reg)stride)
++        : "r" ((x86_reg)stride), "m" (bone)
+     );
+ }
+ 
+@@ -259,7 +259,7 @@
+         "punpckhbw %%mm7, %%mm5         \n\t"
+         "paddw %%mm4, %%mm2             \n\t"
+         "paddw %%mm5, %%mm3             \n\t"
+-        "movq 16+"MANGLE(round_tab)", %%mm5 \n\t"
++        "movq 16+%5, %%mm5              \n\t"
+         "paddw %%mm2, %%mm0             \n\t"
+         "paddw %%mm3, %%mm1             \n\t"
+         "paddw %%mm5, %%mm0             \n\t"
+@@ -282,7 +282,7 @@
+         "add %4, %%"REG_a"              \n\t"
+         " js 1b                         \n\t"
+         : "+a" (len)
+-        : "r" (blk1 - len), "r" (blk1 -len + stride), "r" (blk2 - len), "r" ((x86_reg)stride)
++        : "r" (blk1 - len), "r" (blk1 -len + stride), "r" (blk2 - len), "r" ((x86_reg)stride), "m" (round_tab[0])
+     );
+ }
+ 
+Index: libavcodec/x86/simple_idct_mmx.c
+===================================================================
+--- libavcodec/x86/simple_idct_mmx.c	(revision 17470)
++++ libavcodec/x86/simple_idct_mmx.c	(working copy)
+@@ -364,7 +364,7 @@
+         "movq " #src4 ", %%mm1          \n\t" /* R6     R2      r6      r2 */\
+         "movq " #src1 ", %%mm2          \n\t" /* R3     R1      r3      r1 */\
+         "movq " #src5 ", %%mm3          \n\t" /* R7     R5      r7      r5 */\
+-        "movq "MANGLE(wm1010)", %%mm4   \n\t"\
++        "movq %3, %%mm4                 \n\t"\
+         "pand %%mm0, %%mm4              \n\t"\
+         "por %%mm1, %%mm4               \n\t"\
+         "por %%mm2, %%mm4               \n\t"\
+@@ -438,7 +438,7 @@
+         "jmp 2f                         \n\t"\
+         "1:                             \n\t"\
+         "pslld $16, %%mm0               \n\t"\
+-        "#paddd "MANGLE(d40000)", %%mm0 \n\t"\
++        "#paddd %4, %%mm0               \n\t"\
+         "psrad $13, %%mm0               \n\t"\
+         "packssdw %%mm0, %%mm0          \n\t"\
+         "movq %%mm0, " #dst "           \n\t"\
+@@ -472,7 +472,7 @@
+         "movq " #src4 ", %%mm1          \n\t" /* R6     R2      r6      r2 */\
+         "movq " #src1 ", %%mm2          \n\t" /* R3     R1      r3      r1 */\
+         "movq " #src5 ", %%mm3          \n\t" /* R7     R5      r7      r5 */\
+-        "movq "MANGLE(wm1010)", %%mm4   \n\t"\
++        "movq %3, %%mm4                 \n\t"\
+         "pand %%mm0, %%mm4              \n\t"\
+         "por %%mm1, %%mm4               \n\t"\
+         "por %%mm2, %%mm4               \n\t"\
+@@ -546,7 +546,7 @@
+         "jmp 2f                         \n\t"\
+         "1:                             \n\t"\
+         "pslld $16, %%mm0               \n\t"\
+-        "paddd "MANGLE(d40000)", %%mm0  \n\t"\
++        "paddd %4, %%mm0                \n\t"\
+         "psrad $13, %%mm0               \n\t"\
+         "packssdw %%mm0, %%mm0          \n\t"\
+         "movq %%mm0, " #dst "           \n\t"\
+@@ -1271,7 +1271,7 @@
+ */
+ 
+ "9: \n\t"
+-                :: "r" (block), "r" (temp), "r" (coeffs)
++                :: "r" (block), "r" (temp), "r" (coeffs), "m" (wm1010), "m"(d40000)
+                 : "%eax"
+         );
+ }
+Index: libavcodec/x86/cavsdsp_mmx.c
+===================================================================
+--- libavcodec/x86/cavsdsp_mmx.c	(revision 17470)
++++ libavcodec/x86/cavsdsp_mmx.c	(working copy)
+@@ -25,8 +25,30 @@
+ #include "libavutil/common.h"
+ #include "libavutil/x86_cpu.h"
+ #include "libavcodec/dsputil.h"
+-#include "dsputil_mmx.h"
+ 
++#define SUMSUB_BA( a, b ) \
++"paddw "#b", "#a" \n\t"\
++"paddw "#b", "#b" \n\t"\
++"psubw "#a", "#b" \n\t"
++
++#define SBUTTERFLY(a,b,t,n,m)\
++"mov" #m " " #a ", " #t "         \n\t" /* abcd */\
++"punpckl" #n " " #b ", " #a "     \n\t" /* aebf */\
++"punpckh" #n " " #b ", " #t "     \n\t" /* cgdh */\
++
++#define TRANSPOSE4(a,b,c,d,t)\
++SBUTTERFLY(a,b,t,wd,q) /* a=aebf t=cgdh */\
++SBUTTERFLY(c,d,b,wd,q) /* c=imjn b=kolp */\
++SBUTTERFLY(a,c,d,dq,q) /* a=aeim d=bfjn */\
++SBUTTERFLY(t,b,c,dq,q) /* t=cgko c=dhlp */
++
++DECLARE_ALIGNED_8(static const uint64_t,ff_pw_4 ) = 0x0004000400040004ULL;	 
++DECLARE_ALIGNED_8(static const uint64_t,ff_pw_5 ) = 0x0005000500050005ULL;	 
++DECLARE_ALIGNED_8(static const uint64_t,ff_pw_7 ) = 0x0007000700070007ULL;	 
++DECLARE_ALIGNED_8(static const uint64_t,ff_pw_42) = 0x002A002A002A002AULL;	 
++DECLARE_ALIGNED_8(static const uint64_t,ff_pw_64) = 0x0040004000400040ULL;	 
++DECLARE_ALIGNED_8(static const uint64_t,ff_pw_96) = 0x0060006000600060ULL;
++
+ /*****************************************************************************
+  *
+  * inverse transform
+@@ -148,7 +170,7 @@
+     }
+ 
+     for(i=0; i<2; i++){
+-        cavs_idct8_1d(b2+4*i, ff_pw_64.a);
++        cavs_idct8_1d(b2+4*i, ff_pw_64);
+ 
+         __asm__ volatile(
+             "psraw     $7, %%mm7  \n\t"
+Index: libavcodec/x86/flacdsp_mmx.c
+===================================================================
+--- libavcodec/x86/flacdsp_mmx.c	(revision 17470)
++++ libavcodec/x86/flacdsp_mmx.c	(working copy)
+@@ -27,7 +27,6 @@
+     double c = 2.0 / (len-1.0);
+     int n2 = len>>1;
+     x86_reg i = -n2*sizeof(int32_t);
+-    x86_reg j =  n2*sizeof(int32_t);
+     __asm__ volatile(
+         "movsd   %0,     %%xmm7                \n\t"
+         "movapd  "MANGLE(ff_pd_1)", %%xmm6     \n\t"
+@@ -55,7 +54,7 @@
+         "sub      $8,      %1                  \n\t"\
+         "add      $8,      %0                  \n\t"\
+         "jl 1b                                 \n\t"\
+-        :"+&r"(i), "+&r"(j)\
++        :"+&r"(i)\
+         :"r"(w_data+n2), "r"(data+n2)\
+     );
+     if(len&1)
+@@ -88,6 +87,8 @@
+                 "movsd    "MANGLE(ff_pd_1)", %%xmm0 \n\t"
+                 "movsd    "MANGLE(ff_pd_1)", %%xmm1 \n\t"
+                 "movsd    "MANGLE(ff_pd_1)", %%xmm2 \n\t"
++                :: "m"(*ff_pd_1) );
++            __asm__ volatile(
+                 "1:                                 \n\t"
+                 "movapd   (%4,%0), %%xmm3           \n\t"
+                 "movupd -8(%5,%0), %%xmm4           \n\t"
+@@ -116,6 +117,8 @@
+             __asm__ volatile(
+                 "movsd    "MANGLE(ff_pd_1)", %%xmm0 \n\t"
+                 "movsd    "MANGLE(ff_pd_1)", %%xmm1 \n\t"
++                :: "m"(*ff_pd_1) );
++            __asm__ volatile(
+                 "1:                                 \n\t"
+                 "movapd   (%3,%0), %%xmm3           \n\t"
+                 "movupd -8(%4,%0), %%xmm4           \n\t"
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/ffmpeg-svn-wince.patch ./extras/contrib/src/Patches/ffmpeg-svn-wince.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/ffmpeg-svn-wince.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/ffmpeg-svn-wince.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,626 @@
+Index: ../ffmpeg/libavcodec/4xm.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/4xm.c,v
+retrieving revision 1.15
+diff -u -r1.15 4xm.c
+--- ../ffmpeg/libavcodec/4xm.c	24 Apr 2005 17:21:07 -0000	1.15
++++ ../ffmpeg/libavcodec/4xm.c	27 Nov 2005 16:54:10 -0000
+@@ -26,9 +26,6 @@
+ #include "dsputil.h"
+ #include "mpegvideo.h"
+ 
+-//#undef NDEBUG
+-//#include <assert.h>
+-
+ #define BLOCK_TYPE_VLC_BITS 5
+ #define ACDC_VLC_BITS 9
+ 
+Index: ../ffmpeg/libavcodec/asv1.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/asv1.c,v
+retrieving revision 1.18
+diff -u -r1.18 asv1.c
+--- ../ffmpeg/libavcodec/asv1.c	7 May 2005 19:24:07 -0000	1.18
++++ ../ffmpeg/libavcodec/asv1.c	27 Nov 2005 16:54:10 -0000
+@@ -26,9 +26,6 @@
+ #include "dsputil.h"
+ #include "mpegvideo.h"
+ 
+-//#undef NDEBUG
+-//#include <assert.h>
+-
+ #define VLC_BITS 6
+ #define ASV2_LEVEL_VLC_BITS 10
+  
+Index: ../ffmpeg/libavcodec/cabac.h
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/cabac.h,v
+retrieving revision 1.11
+diff -u -r1.11 cabac.h
+--- ../ffmpeg/libavcodec/cabac.h	29 May 2005 18:18:13 -0000	1.11
++++ ../ffmpeg/libavcodec/cabac.h	27 Nov 2005 16:54:10 -0000
+@@ -26,9 +26,6 @@
+  */
+ 
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #define CABAC_BITS 8
+ #define CABAC_MASK ((1<<CABAC_BITS)-1)
+ 
+Index: ../ffmpeg/libavcodec/dv.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/dv.c,v
+retrieving revision 1.65
+diff -u -r1.65 dv.c
+--- ../ffmpeg/libavcodec/dv.c	2 Sep 2005 08:30:26 -0000	1.65
++++ ../ffmpeg/libavcodec/dv.c	27 Nov 2005 16:54:11 -0000
+@@ -34,9 +34,6 @@
+ #include "simple_idct.h"
+ #include "dvdata.h"
+ 
+-//#undef NDEBUG
+-//#include <assert.h>
+-
+ typedef struct DVVideoContext {
+     const DVprofile* sys;
+     AVFrame picture;
+Index: ../ffmpeg/libavcodec/dvdsubenc.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/dvdsubenc.c,v
+retrieving revision 1.1
+diff -u -r1.1 dvdsubenc.c
+--- ../ffmpeg/libavcodec/dvdsubenc.c	14 Nov 2005 22:17:29 -0000	1.1
++++ ../ffmpeg/libavcodec/dvdsubenc.c	27 Nov 2005 16:54:11 -0000
+@@ -18,9 +18,6 @@
+  */
+ #include "avcodec.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ typedef struct DVDSubtitleContext {
+ } DVDSubtitleContext;
+ 
+Index: ../ffmpeg/libavcodec/flac.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/flac.c,v
+retrieving revision 1.19
+diff -u -r1.19 flac.c
+--- ../ffmpeg/libavcodec/flac.c	5 Sep 2005 09:28:46 -0000	1.19
++++ ../ffmpeg/libavcodec/flac.c	27 Nov 2005 16:54:12 -0000
+@@ -37,9 +37,6 @@
+ #include "bitstream.h"
+ #include "golomb.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #define MAX_CHANNELS 8
+ #define MAX_BLOCKSIZE 65535
+ #define FLAC_STREAMINFO_SIZE 34
+Index: ../ffmpeg/libavcodec/h263.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/h263.c,v
+retrieving revision 1.291
+diff -u -r1.291 h263.c
+--- ../ffmpeg/libavcodec/h263.c	19 Sep 2005 12:03:51 -0000	1.291
++++ ../ffmpeg/libavcodec/h263.c	27 Nov 2005 16:54:15 -0000
+@@ -39,9 +39,6 @@
+ #include "h263data.h"
+ #include "mpeg4data.h"
+ 
+-//#undef NDEBUG
+-//#include <assert.h>
+-
+ #define INTRA_MCBPC_VLC_BITS 6
+ #define INTER_MCBPC_VLC_BITS 7
+ #define CBPY_VLC_BITS 6
+Index: ../ffmpeg/libavcodec/h264.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/h264.c,v
+retrieving revision 1.166
+diff -u -r1.166 h264.c
+--- ../ffmpeg/libavcodec/h264.c	10 Nov 2005 04:40:49 -0000	1.166
++++ ../ffmpeg/libavcodec/h264.c	27 Nov 2005 16:54:20 -0000
+@@ -33,9 +33,6 @@
+ 
+ #include "cabac.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #define interlaced_dct interlaced_dct_is_a_bad_name
+ #define mb_intra mb_intra_isnt_initalized_see_mb_type
+ 
+Index: ../ffmpeg/libavcodec/mdec.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/mdec.c,v
+retrieving revision 1.15
+diff -u -r1.15 mdec.c
+--- ../ffmpeg/libavcodec/mdec.c	13 Aug 2005 21:34:24 -0000	1.15
++++ ../ffmpeg/libavcodec/mdec.c	27 Nov 2005 16:54:21 -0000
+@@ -29,9 +29,6 @@
+ #include "dsputil.h"
+ #include "mpegvideo.h"
+ 
+-//#undef NDEBUG
+-//#include <assert.h>
+-
+ typedef struct MDECContext{
+     AVCodecContext *avctx;
+     DSPContext dsp;
+Index: ../ffmpeg/libavcodec/mjpeg.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/mjpeg.c,v
+retrieving revision 1.114
+diff -u -r1.114 mjpeg.c
+--- ../ffmpeg/libavcodec/mjpeg.c	18 Sep 2005 21:21:01 -0000	1.114
++++ ../ffmpeg/libavcodec/mjpeg.c	27 Nov 2005 16:54:22 -0000
+@@ -28,9 +28,6 @@
+  * MJPEG encoder and decoder.
+  */
+
+-//#define DEBUG
+-#include <assert.h>
+-
+ #include "avcodec.h"
+ #include "dsputil.h"
+ #include "mpegvideo.h"
+Index: ../ffmpeg/libavcodec/motion_est.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/motion_est.c,v
+retrieving revision 1.110
+diff -u -r1.110 motion_est.c
+--- ../ffmpeg/libavcodec/motion_est.c	26 Aug 2005 19:05:44 -0000	1.110
++++ ../ffmpeg/libavcodec/motion_est.c	27 Nov 2005 16:54:23 -0000
+@@ -33,9 +33,6 @@
+ #include "dsputil.h"
+ #include "mpegvideo.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #define SQ(a) ((a)*(a))
+ 
+ #define P_LEFT P[1]
+Index: ../ffmpeg/libavcodec/mpeg12.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/mpeg12.c,v
+retrieving revision 1.243
+diff -u -r1.243 mpeg12.c
+--- ../ffmpeg/libavcodec/mpeg12.c	20 Nov 2005 23:09:05 -0000	1.243
++++ ../ffmpeg/libavcodec/mpeg12.c	27 Nov 2005 16:54:25 -0000
+@@ -30,9 +30,6 @@
+ 
+ #include "mpeg12data.h"
+ 
+-//#undef NDEBUG
+-//#include <assert.h>
+-
+ 
+ /* Start codes. */
+ #define SEQ_END_CODE		0x000001b7
+Index: ../ffmpeg/libavcodec/mpegvideo.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/mpegvideo.c,v
+retrieving revision 1.489
+diff -u -r1.489 mpegvideo.c
+--- ../ffmpeg/libavcodec/mpegvideo.c	5 Nov 2005 00:16:03 -0000	1.489
++++ ../ffmpeg/libavcodec/mpegvideo.c	27 Nov 2005 16:54:29 -0000
+@@ -35,9 +35,6 @@
+ #include "fastmemcpy.h"
+ #endif
+ 
+-//#undef NDEBUG
+-//#include <assert.h>
+-
+ #ifdef CONFIG_ENCODERS
+ static void encode_picture(MpegEncContext *s, int picture_number);
+ #endif //CONFIG_ENCODERS
+Index: ../ffmpeg/libavcodec/oggvorbis.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/oggvorbis.c,v
+retrieving revision 1.24
+diff -u -r1.24 oggvorbis.c
+--- ../ffmpeg/libavcodec/oggvorbis.c	21 Sep 2005 23:09:16 -0000	1.24
++++ ../ffmpeg/libavcodec/oggvorbis.c	27 Nov 2005 16:54:29 -0000
+@@ -8,9 +8,6 @@
+ 
+ #include "avcodec.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #define OGGVORBIS_FRAME_SIZE 64
+ 
+ #define BUFFER_SIZE (1024*64)
+Index: ../ffmpeg/libavcodec/qdm2.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/qdm2.c,v
+retrieving revision 1.2
+diff -u -r1.2 qdm2.c
+--- ../ffmpeg/libavcodec/qdm2.c	19 Oct 2005 22:27:34 -0000	1.2
++++ ../ffmpeg/libavcodec/qdm2.c	27 Nov 2005 16:54:31 -0000
+@@ -46,9 +46,6 @@
+ 
+ #include "qdm2data.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ 
+ #define SOFTCLIP_THRESHOLD 27600
+ #define HARDCLIP_THRESHOLD 35716
+Index: ../ffmpeg/libavcodec/ratecontrol.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/ratecontrol.c,v
+retrieving revision 1.49
+diff -u -r1.49 ratecontrol.c
+--- ../ffmpeg/libavcodec/ratecontrol.c	30 Apr 2005 21:43:57 -0000	1.49
++++ ../ffmpeg/libavcodec/ratecontrol.c	27 Nov 2005 16:54:32 -0000
+@@ -27,9 +27,6 @@
+ #include "dsputil.h"
+ #include "mpegvideo.h"
+ 
+-#undef NDEBUG // allways check asserts, the speed effect is far too small to disable them
+-#include <assert.h>
+-
+ #ifndef M_E
+ #define M_E 2.718281828
+ #endif
+Index: ../ffmpeg/libavcodec/shorten.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/shorten.c,v
+retrieving revision 1.1
+diff -u -r1.1 shorten.c
+--- ../ffmpeg/libavcodec/shorten.c	26 Feb 2005 03:36:03 -0000	1.1
++++ ../ffmpeg/libavcodec/shorten.c	27 Nov 2005 16:54:32 -0000
+@@ -24,7 +24,6 @@
+  *
+  */
+ 
+-#define DEBUG
+ #include <limits.h>
+ #include "avcodec.h"
+ #include "bitstream.h"
+@@ -153,7 +152,7 @@
+             break;
+         default:
+             av_log(s->avctx, AV_LOG_ERROR, "unknown audio type");
+-            abort();
++            av_abort();
+     }
+ 
+     for (chan = 0; chan < s->channels; chan++)
+Index: ../ffmpeg/libavcodec/snow.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/snow.c,v
+retrieving revision 1.63
+diff -u -r1.63 snow.c
+--- ../ffmpeg/libavcodec/snow.c	21 Sep 2005 23:09:16 -0000	1.63
++++ ../ffmpeg/libavcodec/snow.c	27 Nov 2005 16:54:38 -0000
+@@ -25,9 +25,6 @@
+ 
+ #include "mpegvideo.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #define MAX_DECOMPOSITIONS 8
+ #define MAX_PLANES 4
+ #define DWTELEM int
+Index: ../ffmpeg/libavcodec/svq1.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/svq1.c,v
+retrieving revision 1.58
+diff -u -r1.58 svq1.c
+--- ../ffmpeg/libavcodec/svq1.c	5 Sep 2005 10:26:10 -0000	1.58
++++ ../ffmpeg/libavcodec/svq1.c	27 Nov 2005 16:54:38 -0000
+@@ -45,9 +45,6 @@
+ #include "mpegvideo.h"
+ #include "bswap.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ extern const uint8_t mvtab[33][2];
+ 
+ static VLC svq1_block_type;
+Index: ../ffmpeg/libavcodec/vc9.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/vc9.c,v
+retrieving revision 1.24
+diff -u -r1.24 vc9.c
+--- ../ffmpeg/libavcodec/vc9.c	21 Sep 2005 23:09:16 -0000	1.24
++++ ../ffmpeg/libavcodec/vc9.c	27 Nov 2005 16:54:38 -0000
+@@ -33,9 +33,6 @@
+ #include "mpegvideo.h"
+ #include "vc9data.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ extern const uint32_t ff_table0_dc_lum[120][2], ff_table1_dc_lum[120][2];
+ extern const uint32_t ff_table0_dc_chroma[120][2], ff_table1_dc_chroma[120][2];
+ extern VLC ff_msmp4_dc_luma_vlc[2], ff_msmp4_dc_chroma_vlc[2];
+Index: ../ffmpeg/libavcodec/vcr1.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/vcr1.c,v
+retrieving revision 1.8
+diff -u -r1.8 vcr1.c
+--- ../ffmpeg/libavcodec/vcr1.c	24 Feb 2005 19:08:50 -0000	1.8
++++ ../ffmpeg/libavcodec/vcr1.c	27 Nov 2005 16:54:38 -0000
+@@ -25,9 +25,6 @@
+ #include "avcodec.h"
+ #include "mpegvideo.h"
+ 
+-//#undef NDEBUG
+-//#include <assert.h>
+-
+ typedef struct VCR1Context{
+     AVCodecContext *avctx;
+     AVFrame picture;
+Index: ../ffmpeg/libavcodec/vorbis.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/vorbis.c,v
+retrieving revision 1.11
+diff -u -r1.11 vorbis.c
+--- ../ffmpeg/libavcodec/vorbis.c	30 May 2005 22:02:00 -0000	1.11
++++ ../ffmpeg/libavcodec/vorbis.c	27 Nov 2005 16:54:44 -0000
+@@ -38,9 +38,6 @@
+ #define AV_DEBUG(...)
+ #endif
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ /* Helper functions */
+ 
+ /**
+Index: ../ffmpeg/libavcodec/xvmcvideo.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavcodec/xvmcvideo.c,v
+retrieving revision 1.11
+diff -u -r1.11 xvmcvideo.c
+--- ../ffmpeg/libavcodec/xvmcvideo.c	24 Apr 2005 17:21:10 -0000	1.11
++++ ../ffmpeg/libavcodec/xvmcvideo.c	27 Nov 2005 16:54:44 -0000
+@@ -24,9 +24,6 @@
+ #include "dsputil.h"
+ #include "mpegvideo.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #ifdef USE_FASTMEMCPY
+ #include "fastmemcpy.h"
+ #endif
+Index: ../ffmpeg/libavformat/Makefile
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/Makefile,v
+retrieving revision 1.102
+retrieving revision 1.111
+diff -u -r1.111 Makefile
+--- Makefile    26 Jan 2006 23:42:29 -0000      1.111
++++ Makefile    28 Jan 2006 21:44:10 -0000
+@@ -12,8 +12,8 @@
+ PPOBJS=
+  
+ # demuxers
+-OBJS+=mpeg.o mpegts.o mpegtsenc.o ffm.o crc.o img.o img2.o raw.o rm.o \
+-      avienc.o avidec.o wav.o mmf.o swf.o au.o gif.o mov.o mpjpeg.o dv.o \
++OBJS+=mpeg.o mpegts.o ffm.o img.o img2.o raw.o rm.o \
++      avidec.o wav.o mmf.o swf.o au.o gif.o mov.o mpjpeg.o dv.o \
+       yuv4mpeg.o 4xm.o flvdec.o psxstr.o idroq.o ipmovie.o \
+       nut.o wc3movie.o mp3.o westwood.o segafilm.o idcin.o flic.o \
+       sierravmd.o matroska.o sol.o electronicarts.o nsvdec.o asf.o \
+@@ -21,7 +21,7 @@
+ 
+ # muxers
+ ifeq ($(CONFIG_MUXERS),yes)
+-OBJS+= flvenc.o movenc.o asf-enc.o adtsenc.o
++OBJS+= mpegtsenc.o crc.o avienc.o flvenc.o movenc.o asf-enc.o adtsenc.o
+ endif
+
+
+@@ -67,6 +67,10 @@
+ PPOBJS+= beosaudio.o
+ endif
+
++ifeq ($(CONFIG_FFSERVER),yes)
++OBJS+=ffm.o
++endif
++
+ # protocols I/O
+ OBJS+= avio.o aviobuf.o
+
+Index: ../ffmpeg/libavformat/allformats.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/allformats.c,v
+retrieving revision 1.53
+diff -u -r1.53 allformats.c
+--- allformats.c        21 Jan 2006 18:36:32 -0000      1.53
++++ allformats.c        28 Jan 2006 21:57:13 -0000
+@@ -88,7 +88,10 @@
+     libogg_init();
+ #endif
+
++#if defined(CONFIG_FFSERVER)
+     ffm_init();
++#endif
++    
+ #if defined(CONFIG_VIDEO4LINUX2)
+     v4l2_init();
+ #endif
+Index: ../ffmpeg/libavformat/asf-enc.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/asf-enc.c,v
+retrieving revision 1.73
+diff -u -r1.73 asf-enc.c
+--- ../ffmpeg/libavformat/asf-enc.c	23 Sep 2005 00:25:41 -0000	1.73
++++ ../ffmpeg/libavformat/asf-enc.c	27 Nov 2005 16:54:47 -0000
+@@ -20,9 +20,6 @@
+ #include "avi.h"
+ #include "asf.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #ifdef CONFIG_MUXERS
+ 
+ 
+Index: ../ffmpeg/libavformat/asf.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/asf.c,v
+retrieving revision 1.86
+diff -u -r1.86 asf.c
+--- ../ffmpeg/libavformat/asf.c	26 Oct 2005 12:15:09 -0000	1.86
++++ ../ffmpeg/libavformat/asf.c	27 Nov 2005 16:54:50 -0000
+@@ -21,9 +21,6 @@
+ #include "mpegaudio.h"
+ #include "asf.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #define FRAME_HEADER_SIZE 17
+ // Fix Me! FRAME_HEADER_SIZE may be different. 
+ 
+Index: ../ffmpeg/libavformat/avidec.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/avidec.c,v
+retrieving revision 1.76
+diff -u -r1.76 avidec.c
+--- ../ffmpeg/libavformat/avidec.c	6 Sep 2005 21:25:35 -0000	1.76
++++ ../ffmpeg/libavformat/avidec.c	27 Nov 2005 16:54:50 -0000
+@@ -20,9 +20,6 @@
+ #include "avi.h"
+ :q
+ #include "dv.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ //#define DEBUG
+ //#define DEBUG_SEEK
+ 
+Index: ../ffmpeg/libavformat/flvenc.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/flvenc.c,v
+retrieving revision 1.19
+diff -u -r1.19 flvenc.c
+--- ../ffmpeg/libavformat/flvenc.c	12 Nov 2005 20:01:23 -0000	1.19
++++ ../ffmpeg/libavformat/flvenc.c	27 Nov 2005 16:54:50 -0000
+@@ -18,9 +18,6 @@
+  */
+ #include "avformat.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ typedef struct FLVContext {
+     int hasAudio;
+     int hasVideo;
+Index: ../ffmpeg/libavformat/movenc.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/movenc.c,v
+retrieving revision 1.44
+diff -u -r1.44 movenc.c
+--- ../ffmpeg/libavformat/movenc.c	6 Sep 2005 21:25:35 -0000	1.44
++++ ../ffmpeg/libavformat/movenc.c	27 Nov 2005 16:54:56 -0000
+@@ -21,9 +21,6 @@
+ #include "avi.h"
+ #include "avio.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #define MOV_INDEX_CLUSTER_SIZE 16384
+ #define globalTimescale 1000
+ 
+Index: ../ffmpeg/libavformat/mpeg.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/mpeg.c,v
+retrieving revision 1.89
+diff -u -r1.89 mpeg.c
+--- ../ffmpeg/libavformat/mpeg.c	23 Sep 2005 00:25:41 -0000	1.89
++++ ../ffmpeg/libavformat/mpeg.c	27 Nov 2005 16:54:58 -0000
+@@ -22,9 +22,6 @@
+ #define MAX_PAYLOAD_SIZE 4096
+ //#define DEBUG_SEEK
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ typedef struct PacketDesc {
+     int64_t pts;
+     int64_t dts;
+Index: ../ffmpeg/libavformat/nut.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/nut.c,v
+retrieving revision 1.56
+diff -u -r1.56 nut.c
+--- ../ffmpeg/libavformat/nut.c	23 Sep 2005 00:25:41 -0000	1.56
++++ ../ffmpeg/libavformat/nut.c	27 Nov 2005 16:55:00 -0000
+@@ -35,9 +35,6 @@
+ #include "mpegaudio.h"
+ #include "avi.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ //#define TRACE
+ 
+ //from /dev/random
+Index: ../ffmpeg/libavformat/ogg.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/ogg.c,v
+retrieving revision 1.26
+diff -u -r1.26 ogg.c
+--- ../ffmpeg/libavformat/ogg.c	23 Sep 2005 00:25:41 -0000	1.26
++++ ../ffmpeg/libavformat/ogg.c	27 Nov 2005 16:55:00 -0000
+@@ -12,9 +12,6 @@
+ 
+ #include "avformat.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ #define DECODER_BUFFER_SIZE 4096
+ 
+ 
+Index: ../ffmpeg/libavformat/swf.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/swf.c,v
+retrieving revision 1.29
+diff -u -r1.29 swf.c
+--- ../ffmpeg/libavformat/swf.c	23 Sep 2005 00:25:41 -0000	1.29
++++ ../ffmpeg/libavformat/swf.c	27 Nov 2005 16:55:00 -0000
+@@ -54,9 +54,6 @@
+ #define VIDEO_ID 0
+ #define SHAPE_ID  1
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ typedef struct {
+ 
+     offset_t duration_pos;
+Index: ../ffmpeg/libavformat/utils.c
+===================================================================
+RCS file: /cvsroot/ffmpeg/ffmpeg/libavformat/utils.c,v
+retrieving revision 1.168
+diff -u -r1.168 utils.c
+--- ../ffmpeg/libavformat/utils.c	4 Nov 2005 23:50:11 -0000	1.168
++++ ../ffmpeg/libavformat/utils.c	27 Nov 2005 16:55:02 -0000
+@@ -18,9 +18,6 @@
+  */
+ #include "avformat.h"
+ 
+-#undef NDEBUG
+-#include <assert.h>
+-
+ /**
+  * @file libavformat/utils.c
+  * Various utility functions for using ffmpeg library.
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libass-cross.patch ./extras/contrib/src/Patches/libass-cross.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libass-cross.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/libass-cross.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,22 @@
+--- libass/configure.ac	2008-05-22 21:04:13.000000000 +0200
++++ libass.new/configure.ac	2008-08-03 09:10:02.000000000 +0200
+@@ -42,9 +42,9 @@
+ AC_TYPE_UINT8_T
+ 
+ # Checks for library functions.
+-AC_FUNC_MALLOC
++#AC_FUNC_MALLOC
+ AC_FUNC_MEMCMP
+-AC_FUNC_REALLOC
++#AC_FUNC_REALLOC
+ AC_FUNC_STAT
+ AC_FUNC_STRTOD
+ AC_FUNC_VPRINTF
+--- libass/Makefile.am.old	2008-08-12 08:55:47.000000000 +0200
++++ libass/Makefile.am	2008-08-12 08:56:05.000000000 +0200
+@@ -4,4 +4,4 @@
+ pkgconfigdir = $(libdir)/pkgconfig
+ pkgconfig_DATA = libass.pc
+ 
+-SUBDIRS = libass test
++SUBDIRS = libass
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libass_mplayer_updates.patch ./extras/contrib/src/Patches/libass_mplayer_updates.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libass_mplayer_updates.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/libass_mplayer_updates.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,1218 @@
+diff -ruN libass-0.9.6-orig/libass/ass.c libass-0.9.6/libass/ass.c
+--- libass-0.9.6-orig/libass/ass.c	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass.c	2009-06-28 02:48:51.000000000 +0200
+@@ -56,7 +56,7 @@
+ 
+ void ass_free_track(ass_track_t* track) {
+ 	int i;
+-	
++
+ 	if (track->parser_priv) {
+ 		if (track->parser_priv->fontname)
+ 			free(track->parser_priv->fontname);
+@@ -85,14 +85,14 @@
+ /// \return style id
+ int ass_alloc_style(ass_track_t* track) {
+ 	int sid;
+-	
++
+ 	assert(track->n_styles <= track->max_styles);
+ 
+ 	if (track->n_styles == track->max_styles) {
+ 		track->max_styles += ASS_STYLES_ALLOC;
+ 		track->styles = (ass_style_t*)realloc(track->styles, sizeof(ass_style_t)*track->max_styles);
+ 	}
+-	
++
+ 	sid = track->n_styles++;
+ 	memset(track->styles + sid, 0, sizeof(ass_style_t));
+ 	return sid;
+@@ -103,14 +103,14 @@
+ /// \return event id
+ int ass_alloc_event(ass_track_t* track) {
+ 	int eid;
+-	
++
+ 	assert(track->n_events <= track->max_events);
+ 
+ 	if (track->n_events == track->max_events) {
+ 		track->max_events += ASS_EVENTS_ALLOC;
+ 		track->events = (ass_event_t*)realloc(track->events, sizeof(ass_event_t)*track->max_events);
+ 	}
+-	
++
+ 	eid = track->n_events++;
+ 	memset(track->events + eid, 0, sizeof(ass_event_t));
+ 	return eid;
+@@ -217,7 +217,7 @@
+ 		if (target->name != NULL) free(target->name); \
+ 		target->name = strdup(token); \
+ 		mp_msg(MSGT_ASS, MSGL_DBG2, "%s = %s\n", #name, token);
+-		
++
+ #define COLORVAL(name) ANYVAL(name,string2color)
+ #define INTVAL(name) ANYVAL(name,atoi)
+ #define FPVAL(name) ANYVAL(name,atof)
+@@ -261,7 +261,7 @@
+  * \param event parsed data goes here
+  * \param str string to parse, zero-terminated
+  * \param n_ignored number of format options to skip at the beginning
+-*/ 
++*/
+ static int process_event_tail(ass_track_t* track, ass_event_t* event, char* str, int n_ignored)
+ {
+ 	char* token;
+@@ -329,9 +329,9 @@
+ 	ass_style_t* target;
+ 	int sid;
+ 	char** list = track->library->style_overrides;
+-	
++
+ 	if (!list) return;
+-	
++
+ 	for (fs = list; *fs; ++fs) {
+ 		eq = strrchr(*fs, '=');
+ 		if (!eq)
+@@ -398,7 +398,7 @@
+  * \param track track
+  * \param str string to parse, zero-terminated
+  * Allocates a new style struct.
+-*/ 
++*/
+ static int process_style(ass_track_t* track, char *str)
+ {
+ 
+@@ -426,9 +426,9 @@
+ 	}
+ 
+ 	q = format = strdup(track->style_format);
+-	
++
+ 	mp_msg(MSGT_ASS, MSGL_V, "[%p] Style: %s\n", track, str);
+-	
++
+ 	sid = ass_alloc_style(track);
+ 
+ 	style = track->styles + sid;
+@@ -436,13 +436,13 @@
+ // fill style with some default values
+ 	style->ScaleX = 100.;
+ 	style->ScaleY = 100.;
+-	
++
+ 	while (1) {
+ 		NEXT(q, tname);
+ 		NEXT(p, token);
+-		
++
+ //		ALIAS(TertiaryColour,OutlineColour) // ignore TertiaryColour; it appears only in SSA, and is overridden by BackColour
+-			
++
+ 		if (0) { // cool ;)
+ 			STRVAL(Name)
+ 				if ((strcmp(target->Name, "Default")==0) || (strcmp(target->Name, "*Default")==0))
+@@ -494,7 +494,7 @@
+ 	}
+ 	free(format);
+ 	return 0;
+-	
++
+ }
+ 
+ static int process_styles_line(ass_track_t* track, char *str)
+@@ -541,7 +541,7 @@
+ 		// called directly from demuxer
+ 		int eid;
+ 		ass_event_t* event;
+-		
++
+ 		str += 9;
+ 		skip_spaces(&str);
+ 
+@@ -600,7 +600,7 @@
+ 	}
+ 	dsize = q - buf;
+ 	assert(dsize <= size / 4 * 3 + 2);
+-	
++
+ 	if (track->library->extract_fonts) {
+ 		ass_add_font(track->library, track->parser_priv->fontname, (char*)buf, dsize);
+ 		buf = 0;
+@@ -631,7 +631,7 @@
+ 		mp_msg(MSGT_ASS, MSGL_V, "fontname: %s\n", track->parser_priv->fontname);
+ 		return 0;
+ 	}
+-	
++
+ 	if (!track->parser_priv->fontname) {
+ 		mp_msg(MSGT_ASS, MSGL_V, "Not understood: %s  \n", str);
+ 		return 0;
+@@ -648,7 +648,7 @@
+ 	}
+ 	memcpy(track->parser_priv->fontdata + track->parser_priv->fontdata_used, str, len);
+ 	track->parser_priv->fontdata_used += len;
+-	
++
+ 	return 0;
+ }
+ 
+@@ -656,7 +656,7 @@
+  * \brief Parse a header line
+  * \param track track
+  * \param str string to parse, zero-terminated
+-*/ 
++*/
+ static int process_line(ass_track_t* track, char *str)
+ {
+ 	if (!strncasecmp(str, "[Script Info]", 13)) {
+@@ -778,7 +778,7 @@
+  * \param size length of data
+  * \param timecode starting time of the event (milliseconds)
+  * \param duration duration of the event (milliseconds)
+-*/ 
++*/
+ void ass_process_chunk(ass_track_t* track, char *data, int size, long long timecode, long long duration)
+ {
+ 	char* str;
+@@ -791,7 +791,7 @@
+ 		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventFormatHeaderMissing);
+ 		return;
+ 	}
+-	
++
+ 	str = malloc(size + 1);
+ 	memcpy(str, data, size);
+ 	str[size] = '\0';
+@@ -801,8 +801,8 @@
+ 	event = track->events + eid;
+ 
+ 	p = str;
+-	
+-	do { 
++
++	do {
+ 		NEXT(p, token);
+ 		event->ReadOrder = atoi(token);
+ 		if (check_duplicate_event(track, event->ReadOrder))
+@@ -815,7 +815,7 @@
+ 
+ 		event->Start = timecode;
+ 		event->Duration = duration;
+-		
++
+ 		free(str);
+ 		return;
+ //		dump_events(tid);
+@@ -863,11 +863,11 @@
+ 		char* op;
+ 		size_t rc;
+ 		int clear = 0;
+-		
++
+ 		outbuf = malloc(osize);
+ 		ip = data;
+ 		op = outbuf;
+-		
++
+ 		while (1) {
+ 			if (ileft)
+ 				rc = iconv(icdsc, &ip, &ileft, &op, &oleft);
+@@ -898,7 +898,7 @@
+ 		icdsc = (iconv_t)(-1);
+ 		mp_msg(MSGT_ASS,MSGL_V,"LIBSUB: closed iconv descriptor.\n");
+ 	}
+-	
++
+ 	return outbuf;
+ }
+ #endif // ICONV
+@@ -927,7 +927,7 @@
+ 		fclose(fp);
+ 		return 0;
+ 	}
+-	
++
+ 	sz = ftell(fp);
+ 	rewind(fp);
+ 
+@@ -936,9 +936,9 @@
+ 		fclose(fp);
+ 		return 0;
+ 	}
+-	
++
+ 	mp_msg(MSGT_ASS, MSGL_V, "file size: %ld\n", sz);
+-	
++
+ 	buf = malloc(sz + 1);
+ 	assert(buf);
+ 	bytes_read = 0;
+@@ -954,7 +954,7 @@
+ 	} while (sz - bytes_read > 0);
+ 	buf[sz] = '\0';
+ 	fclose(fp);
+-	
++
+ 	if (bufsize)
+ 		*bufsize = sz;
+ 	return buf;
+@@ -967,9 +967,9 @@
+ {
+ 	ass_track_t* track;
+ 	int i;
+-	
++
+ 	track = ass_new_track(library);
+-	
++
+ 	// process header
+ 	process_text(track, buf);
+ 
+@@ -998,15 +998,15 @@
+  * \param bufsize size of buffer
+  * \param codepage recode buffer contents from given codepage
+  * \return newly allocated track
+-*/ 
++*/
+ ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage)
+ {
+ 	ass_track_t* track;
+ 	int need_free = 0;
+-	
++
+ 	if (!buf)
+ 		return 0;
+-	
++
+ #ifdef CONFIG_ICONV
+ 	if (codepage)
+ 		buf = sub_recode(buf, bufsize, codepage);
+@@ -1029,7 +1029,7 @@
+ {
+ 	char* buf;
+ 	size_t bufsize;
+-	
++
+ 	buf = read_file(fname, &bufsize);
+ 	if (!buf)
+ 		return 0;
+@@ -1052,7 +1052,7 @@
+  * \param fname file name
+  * \param codepage recode buffer contents from given codepage
+  * \return newly allocated track
+-*/ 
++*/
+ ass_track_t* ass_read_file(ass_library_t* library, char* fname, char* codepage)
+ {
+ 	char* buf;
+@@ -1066,11 +1066,11 @@
+ 	free(buf);
+ 	if (!track)
+ 		return 0;
+-	
++
+ 	track->name = strdup(fname);
+ 
+ 	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileFname, fname, track->n_styles, track->n_events);
+-	
++
+ //	dump_events(forced_tid);
+ 	return track;
+ }
+@@ -1111,12 +1111,12 @@
+ 
+ 	if (movement == 0) return 0;
+ 	if (track->n_events == 0) return 0;
+-	
++
+ 	if (movement < 0)
+ 		for (i = 0; (i < track->n_events) && ((long long)(track->events[i].Start + track->events[i].Duration) <= now); ++i) {}
+ 	else
+ 		for (i = track->n_events - 1; (i >= 0) && ((long long)(track->events[i].Start) > now); --i) {}
+-	
++
+ 	// -1 and n_events are ok
+ 	assert(i >= -1); assert(i <= track->n_events);
+ 	i += movement;
+diff -ruN libass-0.9.6-orig/libass/ass.h libass-0.9.6/libass/ass.h
+--- libass-0.9.6-orig/libass/ass.h	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass.h	2009-06-28 02:48:51.000000000 +0200
+@@ -195,7 +195,7 @@
+  * \param bufsize size of buffer
+  * \param codepage recode buffer contents from given codepage
+  * \return newly allocated track
+-*/ 
++*/
+ ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage);
+ /**
+  * \brief read styles from file into already initialized track
+diff -ruN libass-0.9.6-orig/libass/ass_bitmap.c libass-0.9.6/libass/ass_bitmap.c
+--- libass-0.9.6-orig/libass/ass_bitmap.c	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass_bitmap.c	2009-06-28 02:48:51.000000000 +0200
+@@ -237,7 +237,7 @@
+ 	unsigned char* g = bm_g->buffer + (t - bm_g->top) * bm_g->w + (l - bm_g->left);
+ 	unsigned char* o = bm_o->buffer + (t - bm_o->top) * bm_o->w + (l - bm_o->left);
+ 	unsigned char* s = bm_s->buffer + (t - bm_s->top) * bm_s->w + (l - bm_s->left);
+-	
++
+ 	for (y = 0; y < b - t; ++y) {
+ 		for (x = 0; x < r - l; ++x) {
+ 			unsigned char c_g, c_o;
+@@ -309,7 +309,7 @@
+ 	if (*bm_o)
+ 		resize_tmp(priv_blur, (*bm_o)->w, (*bm_o)->h);
+ 	resize_tmp(priv_blur, (*bm_g)->w, (*bm_g)->h);
+-	
++
+ 	if (be) {
+ 		while (be--) {
+ 			if (*bm_o)
+diff -ruN libass-0.9.6-orig/libass/ass_cache.c libass-0.9.6/libass/ass_cache.c
+--- libass-0.9.6-orig/libass/ass_cache.c	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass_cache.c	2009-06-28 02:48:51.000000000 +0200
+@@ -117,7 +117,7 @@
+ 	if (map->count > 0 || map->hit_count + map->miss_count > 0)
+ 		mp_msg(MSGT_ASS, MSGL_V, "cache statistics: \n  total accesses: %d\n  hits: %d\n  misses: %d\n  object count: %d\n",
+ 		       map->hit_count + map->miss_count, map->hit_count, map->miss_count, map->count);
+-	
++
+ 	for (i = 0; i < map->nbuckets; ++i) {
+ 		hashmap_item_t* item = map->root[i];
+ 		while (item) {
+@@ -254,7 +254,7 @@
+  * \brief Get a bitmap from bitmap cache.
+  * \param key hash key
+  * \return requested hash val or 0 if not found
+-*/ 
++*/
+ bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key)
+ {
+ 	return hashmap_find(bitmap_cache, key);
+@@ -302,7 +302,7 @@
+  * \brief Get a glyph from glyph cache.
+  * \param key hash key
+  * \return requested hash val or 0 if not found
+-*/ 
++*/
+ glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key)
+ {
+ 	return hashmap_find(glyph_cache, key);
+diff -ruN libass-0.9.6-orig/libass/ass_cache.h libass-0.9.6/libass/ass_cache.h
+--- libass-0.9.6-orig/libass/ass_cache.h	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass_cache.h	2009-06-28 02:48:51.000000000 +0200
+@@ -49,7 +49,7 @@
+ 	int shift_x, shift_y; // shift vector that was added to glyph before applying rotation
+ 	                      // = 0, if frx = fry = frx = 0
+ 	                      // = (glyph base point) - (rotation origin), otherwise
+-	
++
+ 	FT_Vector advance; // subpixel shift vector
+ } bitmap_hash_key_t;
+ 
+@@ -110,7 +110,7 @@
+ void ass_glyph_cache_reset(void);
+ void ass_glyph_cache_done(void);
+ 
+-typedef struct hashmap_s hashmap_t; 
++typedef struct hashmap_s hashmap_t;
+ typedef void (*hashmap_item_dtor_t)(void* key, size_t key_size, void* value, size_t value_size);
+ typedef int (*hashmap_key_compare_t)(void* key1, void* key2, size_t key_size);
+ typedef unsigned (*hashmap_hash_t)(void* key, size_t key_size);
+diff -ruN libass-0.9.6-orig/libass/ass_font.c libass-0.9.6/libass/ass_font.c
+--- libass-0.9.6-orig/libass/ass_font.c	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass_font.c	2009-06-28 02:48:51.000000000 +0200
+@@ -121,12 +121,14 @@
+ 	FT_Face face;
+ 	int error;
+ 	int mem_idx;
+-	
++
+ 	if (font->n_faces == ASS_FONT_MAX_FACES)
+ 		return -1;
+-	
++
+ 	path = fontconfig_select(fc_priv, font->desc.family, font->desc.treat_family_as_pattern, font->desc.bold,
+ 					      font->desc.italic, &index, ch);
++	if (!path)
++		return -1;
+ 
+ 	mem_idx = find_font(font->library, path);
+ 	if (mem_idx >= 0) {
+@@ -145,7 +147,7 @@
+ 	}
+ 	charmap_magic(face);
+ 	buggy_font_workaround(face);
+-	
++
+ 	font->faces[font->n_faces++] = face;
+ 	update_transform(font);
+ 	face_set_size(face, font->size);
+@@ -164,7 +166,7 @@
+ 	fontp = ass_font_cache_find(desc);
+ 	if (fontp)
+ 		return fontp;
+-	
++
+ 	font.library = library;
+ 	font.ftlibrary = ftlibrary;
+ 	font.n_faces = 0;
+@@ -256,7 +258,7 @@
+ 			return;
+ 		}
+ 	}
+-	
++
+ 	*asc = *desc = 0;
+ }
+ 
+@@ -308,18 +310,18 @@
+ 	case ASS_HINTING_NORMAL: flags = FT_LOAD_FORCE_AUTOHINT; break;
+ 	case ASS_HINTING_NATIVE: flags = 0; break;
+ 	}
+-	
++
+ 	error = FT_Load_Glyph(face, index, FT_LOAD_NO_BITMAP | flags);
+ 	if (error) {
+ 		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
+ 		return 0;
+ 	}
+-	
++
+ #if (FREETYPE_MAJOR > 2) || \
+     ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR >= 2)) || \
+     ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR == 1) && (FREETYPE_PATCH >= 10))
+ // FreeType >= 2.1.10 required
+-	if (!(face->style_flags & FT_STYLE_FLAG_ITALIC) && 
++	if (!(face->style_flags & FT_STYLE_FLAG_ITALIC) &&
+ 			(font->desc.italic > 55)) {
+ 		FT_GlyphSlot_Oblique(face->glyph);
+ 	}
+@@ -329,7 +331,7 @@
+ 		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
+ 		return 0;
+ 	}
+-	
++
+ 	return glyph;
+ }
+ 
+diff -ruN libass-0.9.6-orig/libass/ass_fontconfig.c libass-0.9.6/libass/ass_fontconfig.c
+--- libass-0.9.6-orig/libass/ass_fontconfig.c	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass_fontconfig.c	2009-06-28 02:48:51.000000000 +0200
+@@ -72,7 +72,7 @@
+  * \param index out: font index inside a file
+  * \param code: the character that should be present in the font, can be 0
+  * \return font file path
+-*/ 
++*/
+ static char* _select_font(fc_instance_t* priv, const char* family, int treat_family_as_pattern,
+ 			  unsigned bold, unsigned italic, int* index, uint32_t code)
+ {
+@@ -87,7 +87,7 @@
+ 	int curf;
+ 	char* retval = NULL;
+ 	int family_cnt;
+-	
++
+ 	*index = 0;
+ 
+ 	if (treat_family_as_pattern)
+@@ -97,7 +97,7 @@
+ 
+ 	if (!pat)
+ 		goto error;
+-	
++
+ 	if (!treat_family_as_pattern) {
+ 		FcPatternAddString(pat, FC_FAMILY, (const FcChar8*)family);
+ 
+@@ -130,7 +130,7 @@
+ 	FcPatternAddInteger(pat, FC_WEIGHT, bold);
+ 
+ 	FcDefaultSubstitute(pat);
+-	
++
+ 	rc = FcConfigSubstitute(priv->config, pat, FcMatchPattern);
+ 	if (!rc)
+ 		goto error;
+@@ -160,11 +160,13 @@
+ 		goto error;
+ 
+ #if (FC_VERSION >= 20297)
+-	// Remove all extra family names from original pattern.
+-	// After this, FcFontRenderPrepare will select the most relevant family
+-	// name in case there are more than one of them.
+-	for (; family_cnt > 1; --family_cnt)
+-		FcPatternRemove(pat, FC_FAMILY, family_cnt - 1);
++	if (!treat_family_as_pattern) {
++		// Remove all extra family names from original pattern.
++		// After this, FcFontRenderPrepare will select the most relevant family
++		// name in case there are more than one of them.
++		for (; family_cnt > 1; --family_cnt)
++			FcPatternRemove(pat, FC_FAMILY, family_cnt - 1);
++	}
+ #endif
+ 
+ 	rpat = FcFontRenderPrepare(priv->config, pat, fset->fonts[curf]);
+@@ -233,7 +235,7 @@
+  * \param index out: font index inside a file
+  * \param code: the character that should be present in the font, can be 0
+  * \return font file path
+-*/ 
++*/
+ char* fontconfig_select(fc_instance_t* priv, const char* family, int treat_family_as_pattern,
+ 			unsigned bold, unsigned italic, int* index, uint32_t code)
+ {
+@@ -247,23 +249,23 @@
+ 	if (!res && priv->family_default) {
+ 		res = _select_font(priv, priv->family_default, 0, bold, italic, index, code);
+ 		if (res)
+-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFontFamily, 
++			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFontFamily,
+ 					family, bold, italic, res, *index);
+ 	}
+ 	if (!res && priv->path_default) {
+ 		res = priv->path_default;
+ 		*index = priv->index_default;
+-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFont, 
++		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFont,
+ 		       family, bold, italic, res, *index);
+ 	}
+ 	if (!res) {
+ 		res = _select_font(priv, "Arial", 0, bold, italic, index, code);
+ 		if (res)
+-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingArialFontFamily, 
++			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingArialFontFamily,
+ 					family, bold, italic, res, *index);
+ 	}
+ 	if (res)
+-		mp_msg(MSGT_ASS, MSGL_V, "fontconfig_select: (%s, %d, %d) -> %s, %d\n", 
++		mp_msg(MSGT_ASS, MSGL_V, "fontconfig_select: (%s, %d, %d) -> %s, %d\n",
+ 				family, bold, italic, res, *index);
+ 	return res;
+ }
+@@ -314,7 +316,7 @@
+  * \param idx index of the processed font in library->fontdata
+  * With FontConfig >= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
+  * With older FontConfig versions, save the font to ~/.mplayer/fonts.
+-*/ 
++*/
+ static void process_fontdata(fc_instance_t* priv, ass_library_t* library, FT_Library ftlibrary, int idx)
+ {
+ 	int rc;
+@@ -345,7 +347,7 @@
+ 	} else if (!S_ISDIR(st.st_mode)) {
+ 		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NotADirectory, fonts_dir);
+ 	}
+-	
++
+ 	fname = validate_fname((char*)name);
+ 
+ 	snprintf(buf, 1000, "%s/%s", fonts_dir, fname);
+@@ -405,14 +407,14 @@
+  * \param family default font family
+  * \param path default font path
+  * \return pointer to fontconfig private data
+-*/ 
++*/
+ fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path, int fc)
+ {
+ 	int rc;
+ 	fc_instance_t* priv = calloc(1, sizeof(fc_instance_t));
+ 	const char* dir = library->fonts_dir;
+ 	int i;
+-	
++
+ 	if (!fc) {
+ 		mp_msg(MSGT_ASS, MSGL_WARN,
+ 		       MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed);
+@@ -495,9 +497,9 @@
+ 	fc_instance_t* priv;
+ 
+ 	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed);
+-	
++
+ 	priv = calloc(1, sizeof(fc_instance_t));
+-	
++
+ 	priv->path_default = strdup(path);
+ 	priv->index_default = 0;
+ 	return priv;
+diff -ruN libass-0.9.6-orig/libass/ass_library.c libass-0.9.6/libass/ass_library.c
+--- libass-0.9.6-orig/libass/ass_library.c	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass_library.c	2009-06-28 02:48:51.000000000 +0200
+@@ -62,13 +62,13 @@
+ 	char** p;
+ 	char** q;
+ 	int cnt;
+-	
++
+ 	if (priv->style_overrides) {
+ 		for (p = priv->style_overrides; *p; ++p)
+ 			free(*p);
+ 		free(priv->style_overrides);
+ 	}
+-	
++
+ 	if (!list) return;
+ 
+ 	for (p = list, cnt = 0; *p; ++p, ++cnt) {}
+@@ -91,14 +91,14 @@
+ 	if (!name || !data || !size)
+ 		return;
+ 	grow_array((void**)&priv->fontdata, priv->num_fontdata, sizeof(*priv->fontdata));
+-	
++
+ 	priv->fontdata[idx].name = strdup(name);
+-	
++
+ 	priv->fontdata[idx].data = malloc(size);
+ 	memcpy(priv->fontdata[idx].data, data, size);
+-	
++
+ 	priv->fontdata[idx].size = size;
+-	
++
+ 	priv->num_fontdata ++;
+ }
+ 
+diff -ruN libass-0.9.6-orig/libass/ass_render.c libass-0.9.6/libass/ass_render.c
+--- libass-0.9.6-orig/libass/ass_render.c	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass_render.c	2009-06-28 02:51:52.000000000 +0200
+@@ -119,7 +119,7 @@
+ 	double blur; // gaussian blur
+ 	double shadow;
+ 	double frx, fry, frz; // rotation
+-	
++
+ 	bitmap_hash_key_t hash_key;
+ } glyph_info_t;
+ 
+@@ -141,11 +141,11 @@
+ typedef struct render_context_s {
+ 	ass_event_t* event;
+ 	ass_style_t* style;
+-	
++
+ 	ass_font_t* font;
+ 	char* font_path;
+ 	double font_size;
+-	
++
+ 	FT_Stroker stroker;
+ 	int alignment; // alignment overrides go here; if zero, style value will be used
+ 	double frx, fry, frz;
+@@ -185,7 +185,7 @@
+ 	unsigned bold;
+ 	unsigned italic;
+ 	int treat_family_as_pattern;
+-	
++
+ } render_context_t;
+ 
+ // frame-global data
+@@ -248,13 +248,13 @@
+ 	FT_Library ft;
+ 	ass_renderer_t* priv = 0;
+ 	int vmajor, vminor, vpatch;
+-	
++
+ 	memset(&render_context, 0, sizeof(render_context));
+ 	memset(&frame_context, 0, sizeof(frame_context));
+ 	memset(&text_info, 0, sizeof(text_info));
+ 
+ 	error = FT_Init_FreeType( &ft );
+-	if ( error ) { 
++	if ( error ) {
+ 		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FT_Init_FreeTypeFailed);
+ 		goto ass_init_exit;
+ 	}
+@@ -276,14 +276,14 @@
+ 	priv->library = library;
+ 	priv->ftlibrary = ft;
+ 	// images_root and related stuff is zero-filled in calloc
+-	
++
+ 	ass_font_cache_init();
+ 	ass_bitmap_cache_init();
+ 	ass_composite_cache_init();
+ 	ass_glyph_cache_init();
+ 
+ 	text_info.glyphs = calloc(MAX_GLYPHS, sizeof(glyph_info_t));
+-	
++
+ ass_init_exit:
+ 	if (priv) mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_Init);
+ 	else mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_InitFailed);
+@@ -316,7 +316,7 @@
+ static ass_image_t* my_draw_bitmap(unsigned char* bitmap, int bitmap_w, int bitmap_h, int stride, int dst_x, int dst_y, uint32_t color)
+ {
+ 	ass_image_t* img = calloc(1, sizeof(ass_image_t));
+-	
++
+ 	img->w = bitmap_w;
+ 	img->h = bitmap_h;
+ 	img->stride = stride;
+@@ -353,7 +353,7 @@
+ 	dst_x += bm->left;
+ 	dst_y += bm->top;
+ 	brk -= bm->left;
+-	
++
+ 	// clipping
+ 	clip_x0 = render_context.clip_x0;
+ 	clip_y0 = render_context.clip_y0;
+@@ -363,7 +363,7 @@
+ 	b_y0 = 0;
+ 	b_x1 = bm->w;
+ 	b_y1 = bm->h;
+-	
++
+ 	tmp = dst_x - clip_x0;
+ 	if (tmp < 0) {
+ 		mp_msg(MSGT_ASS, MSGL_DBG2, "clip left\n");
+@@ -384,13 +384,13 @@
+ 		mp_msg(MSGT_ASS, MSGL_DBG2, "clip bottom\n");
+ 		b_y1 = bm->h + tmp;
+ 	}
+-	
++
+ 	if ((b_y0 >= b_y1) || (b_x0 >= b_x1))
+ 		return tail;
+ 
+ 	if (brk > b_x0) { // draw left part
+ 		if (brk > b_x1) brk = b_x1;
+-		img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + b_x0, 
++		img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + b_x0,
+ 			brk - b_x0, b_y1 - b_y0, bm->w,
+ 			dst_x + b_x0, dst_y + b_y0, color);
+ 		*tail = img;
+@@ -398,7 +398,7 @@
+ 	}
+ 	if (brk < b_x1) { // draw right part
+ 		if (brk < b_x0) brk = b_x0;
+-		img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + brk, 
++		img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + brk,
+ 			b_x1 - brk, b_y1 - b_y0, bm->w,
+ 			dst_x + brk, dst_y + b_y0, color2);
+ 		*tail = img;
+@@ -420,7 +420,7 @@
+ 	char m;
+ 	composite_hash_key_t hk;
+ 	composite_hash_val_t *hv;
+-	composite_hash_key_t *nhk;
++	composite_hash_val_t chv;
+ 	int ax = (*last_tail)->dst_x;
+ 	int ay = (*last_tail)->dst_y;
+ 	int aw = (*last_tail)->w;
+@@ -455,6 +455,7 @@
+ 	cur_top = top-by;
+ 
+ 	// Query cache
++	memset(&hk, 0, sizeof(hk));
+ 	memcpy(&hk.a, last_hash, sizeof(*last_hash));
+ 	memcpy(&hk.b, hash, sizeof(*hash));
+ 	hk.aw = aw;
+@@ -491,12 +492,9 @@
+ 		}
+ 
+ 	// Insert bitmaps into the cache
+-	nhk = calloc(1, sizeof(*nhk));
+-	memcpy(nhk, &hk, sizeof(*nhk));
+-	hv = calloc(1, sizeof(*hv));
+-	hv->a = (*last_tail)->bitmap;
+-	hv->b = (*tail)->bitmap;
+-	cache_add_composite(nhk, hv);
++	chv.a = (*last_tail)->bitmap;
++	chv.b = (*tail)->bitmap;
++	cache_add_composite( &hk, &chv);
+ }
+ 
+ /**
+@@ -540,7 +538,7 @@
+ 		pen_x = dst_x + info->pos.x;
+ 		pen_y = dst_y + info->pos.y;
+ 		bm = info->bm_o;
+-		
++
+ 		if ((info->effect_type == EF_KARAOKE_KO) && (info->effect_timing <= info->bbox.xMax)) {
+ 			// do nothing
+ 		} else {
+@@ -621,7 +619,7 @@
+ static void compute_string_bbox( text_info_t* info, FT_BBox *abbox ) {
+ 	FT_BBox bbox;
+ 	int i;
+-	
++
+ 	if (text_info.length > 0) {
+ 		bbox.xMin = 32000;
+ 		bbox.xMax = -32000;
+@@ -692,7 +690,7 @@
+ 
+ 	render_context.font = ass_font_new(priv->library, priv->ftlibrary, priv->fontconfig_priv, &desc);
+ 	free(desc.family);
+-	
++
+ 	if (render_context.font)
+ 		change_font_size(render_context.font_size);
+ }
+@@ -778,7 +776,7 @@
+  * \brief Calculate alpha value by piecewise linear function
+  * Used for \fad, \fade implementation.
+  */
+-static unsigned interpolate_alpha(long long now, 
++static unsigned interpolate_alpha(long long now,
+ 		long long t1, long long t2, long long t3, long long t4,
+ 		unsigned a1, unsigned a2, unsigned a3)
+ {
+@@ -811,7 +809,7 @@
+ static char* parse_tag(char* p, double pwr) {
+ #define skip_to(x) while ((*p != (x)) && (*p != '}') && (*p != 0)) { ++p;}
+ #define skip(x) if (*p == (x)) ++p; else { return p; }
+-	
++
+ 	skip_to('\\');
+ 	skip('\\');
+ 	if ((*p == '}') || (*p == 0))
+@@ -919,7 +917,7 @@
+ 			mystrtoll(&p, &t1);
+ 			skip(',');
+ 			mystrtoll(&p, &t2);
+-			mp_msg(MSGT_ASS, MSGL_DBG2, "movement6: (%f, %f) -> (%f, %f), (%" PRId64 " .. %" PRId64 ")\n", 
++			mp_msg(MSGT_ASS, MSGL_DBG2, "movement6: (%f, %f) -> (%f, %f), (%" PRId64 " .. %" PRId64 ")\n",
+ 				x1, y1, x2, y2, (int64_t)t1, (int64_t)t2);
+ 		} else {
+ 			t1 = 0;
+@@ -1111,7 +1109,7 @@
+ 			k = pow(((double)(t - t1)) / delta_t, v3);
+ 		}
+ 		while (*p == '\\')
+-			p = parse_tag(p, k); // maybe k*pwr ? no, specs forbid nested \t's 
++			p = parse_tag(p, k); // maybe k*pwr ? no, specs forbid nested \t's
+ 		skip_to(')'); // in case there is some unknown tag or a comment
+ 		skip(')');
+ 	} else if (mystrcmp(&p, "clip")) {
+@@ -1293,7 +1291,7 @@
+ 	while (cnt < 4 && (p = strchr(p, ';'))) {
+ 		v[cnt++] = atoi(++p);
+ 	}
+-	
++
+ 	if (strncmp(event->Effect, "Banner;", 7) == 0) {
+ 		int delay;
+ 		if (cnt < 1) {
+@@ -1406,7 +1404,7 @@
+ 	render_context.effect_type = EF_NONE;
+ 	render_context.effect_timing = 0;
+ 	render_context.effect_skip_timing = 0;
+-	
++
+ 	apply_transition_effects(event);
+ }
+ 
+@@ -1429,6 +1427,7 @@
+ 	int error;
+ 	glyph_hash_val_t* val;
+ 	glyph_hash_key_t key;
++	memset(&key, 0, sizeof(key));
+ 	key.font = render_context.font;
+ 	key.size = render_context.font_size;
+ 	key.ch = symbol;
+@@ -1490,10 +1489,10 @@
+ {
+ 	bitmap_hash_val_t* val;
+ 	bitmap_hash_key_t* key = &info->hash_key;
+-	
++
+ 	val = cache_find_bitmap(key);
+ /* 	val = 0; */
+-	
++
+ 	if (val) {
+ 		info->bm = val->bm;
+ 		info->bm_o = val->bm_o;
+@@ -1600,8 +1599,8 @@
+ 			break_at = i;
+ 			mp_msg(MSGT_ASS, MSGL_DBG2, "forced line break at %d\n", break_at);
+ 		}
+-		
+-		if (len >= max_text_width) {
++
++		if ((len >= max_text_width) && (frame_context.track->WrapStyle != 2)) {
+ 			break_type = 1;
+ 			break_at = last_space;
+ 			if (break_at == -1)
+@@ -1617,7 +1616,7 @@
+ 			// marking break_at+1 as start of a new line
+ 			int lead = break_at + 1; // the first symbol of the new line
+ 			if (text_info.n_lines >= MAX_LINES) {
+-				// to many lines ! 
++				// to many lines !
+ 				// no more linebreaks
+ 				for (j = lead; j < text_info.length; ++j)
+ 					text_info.glyphs[j].linebreak = 0;
+@@ -1630,7 +1629,7 @@
+ 			s_offset = s1->bbox.xMin + s1->pos.x;
+ 			text_info.n_lines ++;
+ 		}
+-		
++
+ 		if (cur->symbol == ' ')
+ 			last_space = i;
+ 
+@@ -1676,11 +1675,11 @@
+ 			if (i == text_info.length)
+ 				break;
+ 		}
+-		
++
+ 	}
+ 	assert(text_info.n_lines >= 1);
+ #undef DIFF
+-	
++
+ 	measure_text();
+ 
+ 	pen_shift_x = 0;
+@@ -1704,7 +1703,7 @@
+  * \brief determine karaoke effects
+  * Karaoke effects cannot be calculated during parse stage (get_next_char()),
+  * so they are done in a separate step.
+- * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's 
++ * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's
+  * (the first glyph of the karaoke word)'s effect_type and effect_timing.
+  * This function:
+  * 1. sets effect_type for all glyphs in the word (_karaoke_ word)
+@@ -1873,12 +1872,13 @@
+ /**
+  * \brief Main ass rendering function, glues everything together
+  * \param event event to render
++ * \param event_images struct containing resulting images, will also be initialized
+  * Process event, appending resulting ass_image_t's to images_root.
+  */
+ static int ass_render_event(ass_event_t* event, event_images_t* event_images)
+ {
+ 	char* p;
+-	FT_UInt previous; 
++	FT_UInt previous;
+ 	FT_UInt num_glyphs;
+ 	FT_Vector pen;
+ 	unsigned code;
+@@ -1914,7 +1914,7 @@
+ 		do {
+ 			code = get_next_char(&p);
+ 		} while (code && render_context.drawing_mode); // skip everything in drawing mode
+-		
++
+ 		// face could have been changed in get_next_char
+ 		if (!render_context.font) {
+ 			free_render_context();
+@@ -1925,7 +1925,7 @@
+ 			break;
+ 
+ 		if (text_info.length >= MAX_GLYPHS) {
+-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_MAX_GLYPHS_Reached, 
++			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_MAX_GLYPHS_Reached,
+ 					(int)(event - frame_context.track->events), event->Start, event->Duration, event->Text);
+ 			break;
+ 		}
+@@ -1951,14 +1951,14 @@
+ 				       &shift );
+ 
+ 		get_outline_glyph(code, text_info.glyphs + text_info.length, &shift);
+-		
++
+ 		text_info.glyphs[text_info.length].pos.x = pen.x >> 6;
+ 		text_info.glyphs[text_info.length].pos.y = pen.y >> 6;
+-		
++
+ 		pen.x += text_info.glyphs[text_info.length].advance.x;
+ 		pen.x += double_to_d6(render_context.hspacing);
+ 		pen.y += text_info.glyphs[text_info.length].advance.y;
+-		
++
+ 		previous = code;
+ 
+ 		text_info.glyphs[text_info.length].symbol = code;
+@@ -2005,23 +2005,23 @@
+ 		render_context.effect_timing = 0;
+ 		render_context.effect_skip_timing = 0;
+ 	}
+-	
++
+ 	if (text_info.length == 0) {
+ 		// no valid symbols in the event; this can be smth like {comment}
+ 		free_render_context();
+ 		return 1;
+ 	}
+-	
++
+ 	// depends on glyph x coordinates being monotonous, so it should be done before line wrap
+ 	process_karaoke_effects();
+-	
++
+ 	// alignments
+ 	alignment = render_context.alignment;
+ 	halign = alignment & 3;
+ 	valign = alignment & 12;
+ 
+-	MarginL = (event->MarginL) ? event->MarginL : render_context.style->MarginL; 
+-	MarginR = (event->MarginR) ? event->MarginR : render_context.style->MarginR; 
++	MarginL = (event->MarginL) ? event->MarginL : render_context.style->MarginL;
++	MarginR = (event->MarginR) ? event->MarginR : render_context.style->MarginR;
+ 	MarginV = (event->MarginV) ? event->MarginV : render_context.style->MarginV;
+ 
+ 	if (render_context.evt_type != EVENT_HSCROLL) {
+@@ -2061,12 +2061,12 @@
+ 	} else { // render_context.evt_type == EVENT_HSCROLL
+ 		measure_text();
+ 	}
+-	
++
+ 	// determing text bounding box
+ 	compute_string_bbox(&text_info, &bbox);
+-	
++
+ 	// determine device coordinates for text
+-	
++
+ 	// x coordinate for everything except positioned events
+ 	if (render_context.evt_type == EVENT_NORMAL ||
+ 	    render_context.evt_type == EVENT_VSCROLL) {
+@@ -2111,7 +2111,7 @@
+ 		device_x = x2scr_pos(render_context.pos_x) - base_x;
+ 		device_y = y2scr_pos(render_context.pos_y) - base_y;
+ 	}
+-	
++
+ 	// fix clip coordinates (they depend on alignment)
+ 	if (render_context.evt_type == EVENT_NORMAL ||
+ 	    render_context.evt_type == EVENT_HSCROLL ||
+@@ -2138,7 +2138,7 @@
+ 	// calculate rotation parameters
+ 	{
+ 		FT_Vector center;
+-		
++
+ 		if (render_context.have_origin) {
+ 			center.x = x2scr(render_context.org_x);
+ 			center.y = y2scr(render_context.org_y);
+@@ -2166,6 +2166,7 @@
+ 	for (i = 0; i < text_info.length; ++i)
+ 		get_bitmap_glyph(text_info.glyphs + i);
+ 
++	memset(event_images, 0, sizeof(*event_images));
+ 	event_images->top = device_y - d6_to_int(text_info.lines[0].asc);
+ 	event_images->height = d6_to_int(text_info.height);
+ 	event_images->detect_collisions = render_context.detect_collisions;
+@@ -2174,7 +2175,7 @@
+ 	event_images->imgs = render_text(&text_info, device_x, device_y);
+ 
+ 	free_render_context();
+-	
++
+ 	return 0;
+ }
+ 
+@@ -2300,7 +2301,7 @@
+ 
+ 	if (track->n_events == 0)
+ 		return 1; // nothing to do
+-	
++
+ 	frame_context.ass_priv = priv;
+ 	frame_context.width = global_settings->frame_width;
+ 	frame_context.height = global_settings->frame_height;
+@@ -2316,7 +2317,7 @@
+ 	frame_context.time = now;
+ 
+ 	ass_lazy_track_init();
+-	
++
+ 	frame_context.font_scale = global_settings->font_size_coeff *
+ 	                           frame_context.orig_height / frame_context.track->PlayResY;
+ 	if (frame_context.track->ScaledBorderAndShadow)
+@@ -2426,7 +2427,7 @@
+ 	fixed[*cnt].b = s->b + shift;
+ 	(*cnt)++;
+ 	qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
+-	
++
+ 	return shift;
+ }
+ 
+@@ -2481,7 +2482,7 @@
+ 			priv->top = imgs[i].top;
+ 			priv->height = imgs[i].height;
+ 		}
+-		
++
+ 	}
+ }
+ 
+@@ -2554,7 +2555,7 @@
+ 	int i, cnt, rc;
+ 	event_images_t* last;
+ 	ass_image_t** tail;
+-	
++
+ 	// init frame
+ 	rc = ass_start_frame(priv, track, now);
+ 	if (rc != 0)
+@@ -2600,7 +2601,7 @@
+ 
+ 	if (detect_change)
+ 		*detect_change = ass_detect_change(priv);
+-	
++
+ 	// free the previous image list
+ 	ass_free_images(priv->prev_images_root);
+ 	priv->prev_images_root = 0;
+diff -ruN libass-0.9.6-orig/libass/ass_types.h libass-0.9.6/libass/ass_types.h
+--- libass-0.9.6-orig/libass/ass_types.h	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass_types.h	2009-06-28 02:48:51.000000000 +0200
+@@ -100,7 +100,7 @@
+ 	char* event_format; // event format line
+ 
+ 	enum {TRACK_TYPE_UNKNOWN = 0, TRACK_TYPE_ASS, TRACK_TYPE_SSA} track_type;
+-	
++
+ 	// script header fields
+ 	int PlayResX;
+ 	int PlayResY;
+@@ -108,7 +108,7 @@
+ 	int WrapStyle;
+ 	char ScaledBorderAndShadow;
+ 
+-	
++
+ 	int default_style; // index of default style
+ 	char* name; // file name in case of external subs, 0 for streams
+ 
+diff -ruN libass-0.9.6-orig/libass/ass_utils.c libass-0.9.6/libass/ass_utils.c
+--- libass-0.9.6-orig/libass/ass_utils.c	2009-03-13 18:37:09.000000000 +0100
++++ libass-0.9.6/libass/ass_utils.c	2009-06-28 02:48:51.000000000 +0200
+@@ -72,17 +72,17 @@
+ 	uint32_t color = 0;
+ 	int result;
+ 	char* p = *q;
+-	
+-	if (*p == '&') ++p; 
++
++	if (*p == '&') ++p;
+ 	else mp_msg(MSGT_ASS, MSGL_DBG2, "suspicious color format: \"%s\"\n", p);
+-	
+-	if (*p == 'H' || *p == 'h') { 
++
++	if (*p == 'H' || *p == 'h') {
+ 		++p;
+ 		result = mystrtou32(&p, 16, &color);
+ 	} else {
+ 		result = mystrtou32(&p, 0, &color);
+ 	}
+-	
++
+ 	{
+ 		unsigned char* tmp = (unsigned char*)(&color);
+ 		unsigned char b;
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libvorbis.patch ./extras/contrib/src/Patches/libvorbis.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libvorbis.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/libvorbis.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,71 @@
+diff -ruN libvorbis-1.1.1/configure.in libvorbis/configure.in
+--- libvorbis-1.1.1/configure.in	2005-06-21 15:47:45.000000000 +0200
++++ libvorbis/configure.in	2005-11-14 22:40:18.000000000 +0100
+@@ -86,15 +86,15 @@
+ 			CC=cc
+ 		fi
+ 		DEBUG="-g -signed" 
+-		CFLAGS="-O2 -w -signed"
++		EXTRA_CFLAGS="-O2 -w -signed"
+ 		PROFILE="-p -g3 -O2 -signed" ;;
+ 	sparc-sun-solaris*)
+ 		DEBUG="-v -g"
+-		CFLAGS="-xO4 -fast -w -fsimple -native -xcg92"
++		EXTRA_CFLAGS="-xO4 -fast -w -fsimple -native -xcg92"
+ 		PROFILE="-v -xpg -g -xO4 -fast -native -fsimple -xcg92 -Dsuncc" ;;
+ 	*)
+ 		DEBUG="-g"
+-		CFLAGS="-O"
++		EXTRA_CFLAGS="-O"
+ 		PROFILE="-g -p" ;;
+         esac
+ else
+@@ -102,7 +102,7 @@
+ 	case $host in 
+ 	*86-*-linux*)
+ 		DEBUG="-g -Wall -W -D_REENTRANT -D__NO_MATH_INLINES -fsigned-char"
+-		CFLAGS="-O20 -ffast-math -mno-ieee-fp -D_REENTRANT -fsigned-char"
++		EXTRA_CFLAGS="-O20 -ffast-math -mno-ieee-fp -D_REENTRANT -fsigned-char"
+ #              	PROFILE="-Wall -W -pg -g -O20 -ffast-math -D_REENTRANT -fsigned-char -fno-inline -static"
+ 		PROFILE="-Wall -W -pg -g -O20 -ffast-math -mno-ieee-fp -D_REENTRANT -fsigned-char -fno-inline"
+ 
+@@ -142,33 +142,33 @@
+  AC_MSG_WARN([********************************************************])
+  AC_MSG_WARN([                                                        ])
+ 
+-  		CFLAGS=${OPT}" -D__NO_MATH_INLINES"
++  		EXTRA_CFLAGS=${OPT}" -D__NO_MATH_INLINES"
+   		PROFILE=${PROFILE}" -D__NO_MATH_INLINES"
+   		fi;;
+ 	powerpc-*-linux*)
+ 		DEBUG="-g -Wall -W -D_REENTRANT -D__NO_MATH_INLINES"
+-		CFLAGS="-O3 -ffast-math -mfused-madd -mcpu=750 -D_REENTRANT"
++		EXTRA_CFLAGS="-O3 -ffast-math -mfused-madd -mcpu=750 -D_REENTRANT"
+ 		PROFILE="-pg -g -O3 -ffast-math -mfused-madd -mcpu=750 -D_REENTRANT";;
+ 	*-*-linux*)
+ 		DEBUG="-g -Wall -W -D_REENTRANT -D__NO_MATH_INLINES -fsigned-char"
+-		CFLAGS="-O20 -ffast-math -D_REENTRANT -fsigned-char"
++		EXTRA_CFLAGS="-O20 -ffast-math -D_REENTRANT -fsigned-char"
+ 		PROFILE="-pg -g -O20 -ffast-math -D_REENTRANT -fsigned-char";;
+ 	sparc-sun-*)
+ 		DEBUG="-g -Wall -W -D__NO_MATH_INLINES -fsigned-char -mv8"
+-		CFLAGS="-O20 -ffast-math -D__NO_MATH_INLINES -fsigned-char -mv8"
++		EXTRA_CFLAGS="-O20 -ffast-math -D__NO_MATH_INLINES -fsigned-char -mv8"
+ 		PROFILE="-pg -g -O20 -D__NO_MATH_INLINES -fsigned-char -mv8" ;;
+ 	*-*-darwin*)
+ 		DEBUG="-DDARWIN -fno-common -force_cpusubtype_ALL -Wall -g -O0 -fsigned-char"
+-		CFLAGS="-DDARWIN -fno-common -force_cpusubtype_ALL -Wall -g -O4 -ffast-math -fsigned-char"
++		EXTRA_CFLAGS="-DDARWIN -fno-common -force_cpusubtype_ALL -Wall -g -O4 -ffast-math -fsigned-char"
+ 		PROFILE="-DDARWIN -fno-common -force_cpusubtype_ALL -Wall -g -pg -O4 -ffast-math -fsigned-char";;
+ 	*)
+ 		DEBUG="-g -Wall -W -D__NO_MATH_INLINES -fsigned-char"
+-		CFLAGS="-O20 -D__NO_MATH_INLINES -fsigned-char"
++		EXTRA_CFLAGS="-O20 -D__NO_MATH_INLINES -fsigned-char"
+ 		PROFILE="-O20 -g -pg -D__NO_MATH_INLINES -fsigned-char" ;;
+         esac
+ fi
+-CFLAGS="$CFLAGS $cflags_save"
++CFLAGS="$EXTRA_CFLAGS $cflags_save"
+ 
+ dnl --------------------------------------------------
+ dnl Check for headers
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libvorbis-r14598-CVE-2008-1420.patch ./extras/contrib/src/Patches/libvorbis-r14598-CVE-2008-1420.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libvorbis-r14598-CVE-2008-1420.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/libvorbis-r14598-CVE-2008-1420.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,34 @@
+Index: lib/res0.c
+===================================================================
+--- lib/res0.c	(revision 14597)
++++ lib/res0.c	(revision 14598)
+@@ -223,6 +223,20 @@
+   for(j=0;j<acc;j++)
+     if(info->booklist[j]>=ci->books)goto errout;
+ 
++  /* verify the phrasebook is not specifying an impossible or
++     inconsistent partitioning scheme. */
++  {
++    int entries = ci->book_param[info->groupbook]->entries;
++    int dim = ci->book_param[info->groupbook]->dim;
++    int partvals = 1;
++    while(dim>0){
++      partvals *= info->partitions;
++      if(partvals > entries) goto errout;
++      dim--;
++    }
++    if(partvals != entries) goto errout;
++  }
++
+   return(info);
+  errout:
+   res0_free_info(info);
+@@ -263,7 +277,7 @@
+     }
+   }
+ 
+-  look->partvals=rint(pow((float)look->parts,(float)dim));
++  look->partvals=look->phrasebook->entries;
+   look->stages=maxstage;
+   look->decodemap=_ogg_malloc(look->partvals*sizeof(*look->decodemap));
+   for(j=0;j<look->partvals;j++){
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libvorbis-r14602-CVE-2008-1419.patch ./extras/contrib/src/Patches/libvorbis-r14602-CVE-2008-1419.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libvorbis-r14602-CVE-2008-1419.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/libvorbis-r14602-CVE-2008-1419.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,13 @@
+Index: lib/codebook.c
+===================================================================
+--- lib/codebook.c	(revision 14601)
++++ lib/codebook.c	(revision 14602)
+@@ -225,7 +225,7 @@
+       int quantvals=0;
+       switch(s->maptype){
+       case 1:
+-	quantvals=_book_maptype1_quantvals(s);
++	quantvals=(s->dim==0?0:_book_maptype1_quantvals(s));
+ 	break;
+       case 2:
+ 	quantvals=s->entries*s->dim;
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libvorbis-r14602-CVE-2008-1423.patch ./extras/contrib/src/Patches/libvorbis-r14602-CVE-2008-1423.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/libvorbis-r14602-CVE-2008-1423.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/libvorbis-r14602-CVE-2008-1423.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,13 @@
+Index: lib/codebook.c
+===================================================================
+--- lib/codebook.c	(revision 14603)
++++ lib/codebook.c	(revision 14604)
+@@ -159,6 +159,8 @@
+   s->entries=oggpack_read(opb,24);
+   if(s->entries==-1)goto _eofout;
+ 
++  if(_ilog(s->dim)+_ilog(s->entries)>24)goto _eofout;
++
+   /* codeword ordering.... length ordered or unordered? */
+   switch((int)oggpack_read(opb,1)){
+   case 0:
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/live-win32.patch ./extras/contrib/src/Patches/live-win32.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/live-win32.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/live-win32.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,170 @@
+Copyright (C) 2009 Laurent Aimar.
+Licensed under GNU General Public License version 2 or higher.
+diff -ur live/BasicUsageEnvironment/BasicTaskScheduler.cpp live-fix/BasicUsageEnvironment/BasicTaskScheduler.cpp
+--- live/BasicUsageEnvironment/BasicTaskScheduler.cpp	2009-04-07 04:18:59.000000000 +0200
++++ live-fix/BasicUsageEnvironment/BasicTaskScheduler.cpp	2009-04-16 00:33:19.000000000 +0200
+@@ -80,7 +80,7 @@
+       int dummySocketNum = socket(AF_INET, SOCK_DGRAM, 0);
+       FD_SET((unsigned)dummySocketNum, &fReadSet);
+     }
+-    if (err != 0) {
++    if (err != EINTR) {
+ #else
+     if (errno != EINTR && errno != EAGAIN) {
+ #endif
+diff -ur live/BasicUsageEnvironment/BasicUsageEnvironment.cpp live-fix/BasicUsageEnvironment/BasicUsageEnvironment.cpp
+--- live/BasicUsageEnvironment/BasicUsageEnvironment.cpp	2009-04-07 04:18:59.000000000 +0200
++++ live-fix/BasicUsageEnvironment/BasicUsageEnvironment.cpp	2009-04-16 00:30:33.000000000 +0200
+@@ -61,6 +61,20 @@
+ #endif
+ }
+ 
++int BasicUsageEnvironment::getNetErrno() const {
++#if defined(__WIN32__) || defined(_WIN32)
++#ifndef _WIN32_WCE
++    errno = WSAGetLastError();
++#endif
++#endif
++#if defined(_WIN32_WCE)
++  return WSAGetLastError();
++#else
++  return errno;
++#endif
++}
++
++
+ UsageEnvironment& BasicUsageEnvironment::operator<<(char const* str) {
+ 	fprintf(stderr, "%s", str);
+ 	return *this;
+diff -ur live/BasicUsageEnvironment/include/BasicUsageEnvironment.hh live-fix/BasicUsageEnvironment/include/BasicUsageEnvironment.hh
+--- live/BasicUsageEnvironment/include/BasicUsageEnvironment.hh	2009-04-07 04:18:59.000000000 +0200
++++ live-fix/BasicUsageEnvironment/include/BasicUsageEnvironment.hh	2009-04-16 00:30:33.000000000 +0200
+@@ -30,6 +30,7 @@
+ 
+   // redefined virtual functions:
+   virtual int getErrno() const;
++  virtual int getNetErrno() const;
+ 
+   virtual UsageEnvironment& operator<<(char const* str);
+   virtual UsageEnvironment& operator<<(int i);
+diff -ur live/groupsock/GroupsockHelper.cpp live-fix/groupsock/GroupsockHelper.cpp
+--- live/groupsock/GroupsockHelper.cpp	2009-04-07 04:18:59.000000000 +0200
++++ live-fix/groupsock/GroupsockHelper.cpp	2009-04-16 00:30:33.000000000 +0200
+@@ -230,10 +230,13 @@
+     if (timeout != NULL && result == 0) {
+       break; // this is OK - timeout occurred
+     } else if (result <= 0) {
++      if (env.getNetErrno() == EINTR ||
+ #if defined(__WIN32__) || defined(_WIN32)
++          env.getNetErrno() == EWOULDBLOCK
+ #else
+-      if (errno == EINTR || errno == EAGAIN) continue;
++          env.getNetErrno() == EAGAIN
+ #endif
++         ) continue;
+       socketErr(env, "select() error: ");
+       break;
+     }
+@@ -271,7 +274,7 @@
+ 			 &addressSize);
+     if (bytesRead < 0) {
+       //##### HACK to work around bugs in Linux and Windows:
+-      int err = env.getErrno();
++      int err = env.getNetErrno();
+       if (err == 111 /*ECONNREFUSED (Linux)*/
+ #if defined(__WIN32__) || defined(_WIN32)
+ 	  // What a piece of crap Windows is.  Sometimes
+@@ -432,7 +435,7 @@
+   if (setsockopt(socket, IPPROTO_IP, IP_ADD_MEMBERSHIP,
+ 		 (const char*)&imr, sizeof (struct ip_mreq)) < 0) {
+ #if defined(__WIN32__) || defined(_WIN32)
+-    if (env.getErrno() != 0) {
++    if (env.getNetErrno() != 0) {
+       // That piece-of-shit toy operating system (Windows) sometimes lies
+       // about setsockopt() failing!
+ #endif
+diff -ur live/groupsock/include/NetCommon.h live-fix/groupsock/include/NetCommon.h
+--- live/groupsock/include/NetCommon.h	2009-04-07 04:18:59.000000000 +0200
++++ live-fix/groupsock/include/NetCommon.h	2009-04-16 00:30:33.000000000 +0200
+@@ -36,6 +36,8 @@
+ 
+ #define closeSocket closesocket
+ #define EWOULDBLOCK WSAEWOULDBLOCK
++#define EINPROGRESS WSAEWOULDBLOCK
++#define EINTR WSAEINTR
+ 
+ #if defined(_WIN32_WCE)
+ #define NO_STRSTREAM 1
+diff -ur live/liveMedia/HTTPSink.cpp live-fix/liveMedia/HTTPSink.cpp
+--- live/liveMedia/HTTPSink.cpp	2009-04-07 04:19:00.000000000 +0200
++++ live-fix/liveMedia/HTTPSink.cpp	2009-04-16 00:30:33.000000000 +0200
+@@ -107,7 +107,7 @@
+     fClientSocket = accept(fSocket, (struct sockaddr*)&clientAddr,
+ 			   &clientAddrLen);
+     if (fClientSocket < 0) {
+-      int err = envir().getErrno();
++      int err = envir().getNetErrno();
+       if (err != EWOULDBLOCK) {
+ 	envir().setResultErrMsg("accept() failed: ");
+ 	return False;
+@@ -158,7 +158,7 @@
+     int sendResult
+       = send(fClientSocket, (char*)(&fBuffer[0]), frameSize, 0);
+     if (sendResult < 0) {
+-      int err = envir().getErrno();
++      int err = envir().getNetErrno();
+       if (err != EWOULDBLOCK) {
+ 	// The client appears to have gone; close him down,
+ 	// and consider ourselves done:
+diff -ur live/liveMedia/RTSPClient.cpp live-fix/liveMedia/RTSPClient.cpp
+--- live/liveMedia/RTSPClient.cpp	2009-04-16 00:31:40.000000000 +0200
++++ live-fix/liveMedia/RTSPClient.cpp	2009-04-16 00:30:33.000000000 +0200
+@@ -1834,11 +1834,7 @@
+         makeSocketNonBlocking(fInputSocketNum);
+       }
+       if (connect(fInputSocketNum, (struct sockaddr*) &remoteName, sizeof remoteName) != 0) {
+-#if defined(__WIN32__) || defined(_WIN32)
+-        if (errno != WSAEINPROGRESS && errno != WSAEWOULDBLOCK) {
+-#else
+-        if (errno != EINPROGRESS) {
+-#endif
++        if (envir().getNetErrno() != EINPROGRESS && envir().getNetErrno() != EWOULDBLOCK) {
+           envir().setResultErrMsg("connect() failed: ");
+           break;
+         }
+diff -ur live/liveMedia/RTSPOverHTTPServer.cpp live-fix/liveMedia/RTSPOverHTTPServer.cpp
+--- live/liveMedia/RTSPOverHTTPServer.cpp	2009-04-07 04:19:00.000000000 +0200
++++ live-fix/liveMedia/RTSPOverHTTPServer.cpp	2009-04-16 00:30:33.000000000 +0200
+@@ -119,7 +119,7 @@
+   int clientSocket = accept(fServerSocket, (struct sockaddr*)&clientAddr,
+                             &clientAddrLen);
+   if (clientSocket < 0) {
+-    int err = envir().getErrno();
++    int err = envir().getNetErrno();
+     if (err != EWOULDBLOCK) {
+       envir().setResultErrMsg("accept() failed: ");
+     }
+diff -ur live/liveMedia/RTSPServer.cpp live-fix/liveMedia/RTSPServer.cpp
+--- live/liveMedia/RTSPServer.cpp	2009-04-07 04:19:00.000000000 +0200
++++ live-fix/liveMedia/RTSPServer.cpp	2009-04-16 00:30:33.000000000 +0200
+@@ -226,7 +226,7 @@
+   int clientSocket = accept(fServerSocket, (struct sockaddr*)&clientAddr,
+ 			    &clientAddrLen);
+   if (clientSocket < 0) {
+-    int err = envir().getErrno();
++    int err = envir().getNetErrno();
+     if (err != EWOULDBLOCK) {
+         envir().setResultErrMsg("accept() failed: ");
+     }
+diff -ur live/UsageEnvironment/include/UsageEnvironment.hh live-fix/UsageEnvironment/include/UsageEnvironment.hh
+--- live/UsageEnvironment/include/UsageEnvironment.hh	2009-04-07 04:18:59.000000000 +0200
++++ live-fix/UsageEnvironment/include/UsageEnvironment.hh	2009-04-16 00:30:33.000000000 +0200
+@@ -71,6 +71,7 @@
+ 
+   // 'errno'
+   virtual int getErrno() const = 0;
++  virtual int getNetErrno() const = 0;
+ 
+   // 'console' output:
+   virtual UsageEnvironment& operator<<(char const* str) = 0;
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/SDL_image-CVE-2006-4484.patch ./extras/contrib/src/Patches/SDL_image-CVE-2006-4484.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/SDL_image-CVE-2006-4484.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/SDL_image-CVE-2006-4484.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,13 @@
+--- SDL_image/IMG_gif.orig.c	2008-02-01 11:58:19.000000000 +0100
++++ SDL_image/IMG_gif.c	2008-02-01 11:58:28.000000000 +0100
+@@ -415,6 +415,10 @@
+     static int table[2][(1 << MAX_LWZ_BITS)];
+     static int stack[(1 << (MAX_LWZ_BITS)) * 2], *sp;
+     register int i;
++    
++    /* Fixed buffer overflow found by Michael Skladnikiewicz */
++    if( input_code_size > MAX_LWZ_BITS )
++        return -1;
+ 
+     if (flag) {
+ 	set_code_size = input_code_size;
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/taglib.patch ./extras/contrib/src/Patches/taglib.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/taglib.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/taglib.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,15 @@
+diff -ru taglib-1.5/taglib/taglib_export.h taglib/taglib/taglib_export.h
+--- taglib-1.5/taglib/taglib_export.h	2008-02-04 15:14:46.000000000 +0000
++++ taglib/taglib/taglib_export.h	2008-04-13 18:25:29.000000000 +0100
+@@ -28,9 +28,9 @@
+ 
+ #if defined(_WIN32) || defined(_WIN64)
+ #ifdef MAKE_TAGLIB_LIB
+-#define TAGLIB_EXPORT __declspec(dllexport)
++#define TAGLIB_EXPORT 
+ #else
+-#define TAGLIB_EXPORT __declspec(dllimport)
++#define TAGLIB_EXPORT 
+ #endif
+ #else
+ #define TAGLIB_EXPORT
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/extras/contrib/src/Patches/x264-svn-darwin.patch ./extras/contrib/src/Patches/x264-svn-darwin.patch
--- /arno/build/vlc-1.0.5/extras/contrib/src/Patches/x264-svn-darwin.patch	1970-01-01 01:00:00.000000000 +0100
+++ ./extras/contrib/src/Patches/x264-svn-darwin.patch	2010-02-26 14:52:38.000000000 +0100
@@ -0,0 +1,27 @@
+Index: configure
+===================================================================
+--- configure	(revision 715)
++++ configure	(working copy)
+@@ -396,7 +396,7 @@
+     CFLAGS="$CFLAGS -fPIC"
+     ASFLAGS="$ASFLAGS -D__PIC__"
+     # resolve textrels in the x86 asm
+-    cc_check stdio.h -Wl,-Bsymbolic && LDFLAGS="$LDFLAGS -Wl,-Bsymbolic"
++    cc_check stdio.h -Wl && LDFLAGS="$LDFLAGS -Wl"
+ fi
+ 
+ if [ "$debug" != "yes" -a "$gprof" != "yes" ]; then
+
+Index: common/common.h
+===================================================================
+--- common/common.h	(revision 701)
++++ common/common.h	(working copy)
+@@ -67,7 +67,7 @@
+ #include <stdlib.h>
+ #include <string.h>
+ #include <assert.h>
+-#include "x264.h"
++#include "../x264.h"
+ #include "bs.h"
+ #include "set.h"
+ #include "predict.h"
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/include/vlc/mediacontrol.h ./include/vlc/mediacontrol.h
--- /arno/build/vlc-1.0.5/include/vlc/mediacontrol.h	2009-12-20 18:43:39.000000000 +0100
+++ ./include/vlc/mediacontrol.h	2010-02-26 14:53:02.000000000 +0100
@@ -225,6 +225,30 @@
 VLC_PUBLIC_API char * mediacontrol_get_mrl( mediacontrol_Instance *self,
                                             mediacontrol_Exception *exception );
 
+
+
+/**
+ *  Added by Ivaylo:
+ *
+ * Set the size and ID of the content to be played, and the callback functions
+ * for reading and seeking in the content via the raw C access module.
+ *
+ * \param self the mediacontrol instance
+ * \param read_callback the function for VLC to call when it wants to read
+ * \param seek_callback the function for VLC to call when it wants to seek
+ * \param i_fsize size of the content
+ * \param id unique ID of the content
+ * \param exception an initialized exception pointer
+ */
+VLC_PUBLIC_API void mediacontrol_set_raw_callbacks( mediacontrol_Instance *self,
+							      raw_read_fnc_ptr read_callback,
+								  raw_seek_fnc_ptr seek_callback,
+								  int i_fsize,
+								  int id,
+                                  mediacontrol_Exception *exception );
+
+
+
 /*****************************************************************************
  * A/V functions
  *****************************************************************************/
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/include/vlc/mediacontrol_structures.h ./include/vlc/mediacontrol_structures.h
--- /arno/build/vlc-1.0.5/include/vlc/mediacontrol_structures.h	2009-12-20 18:43:39.000000000 +0100
+++ ./include/vlc/mediacontrol_structures.h	2010-02-26 14:53:02.000000000 +0100
@@ -135,6 +135,14 @@
 } mediacontrol_StreamInformation;
 
 
+/**
+ * For Ivaylo's mediacontrol_set_raw_callbacks()
+ */
+
+typedef int (* raw_read_fnc_ptr) ( uint8_t *p_data, int i_data, int id );
+typedef	int (* raw_seek_fnc_ptr) ( int64_t i_pos, int id );
+
+
 # ifdef __cplusplus
 }
 # endif
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/access/Makefile.am ./modules/access/Makefile.am
--- /arno/build/vlc-1.0.5/modules/access/Makefile.am	2010-01-24 22:28:08.000000000 +0100
+++ ./modules/access/Makefile.am	2010-02-26 14:52:49.000000000 +0100
@@ -3,7 +3,7 @@
 
 basedir = access
 dir = access
-mods = access_alsa access_directory access_dv access_eyetv access_fake access_file access_ftp access_gnomevfs access_http access_jack access_mmap access_mtp access_oss access_smb access_tcp access_udp cdda dc1394 dvdnav dvdread pvr qtcapture v4l v4l2
+mods = access_alsa access_directory access_dv access_eyetv access_fake access_file access_ftp access_gnomevfs access_http access_jack access_mmap access_mtp access_oss access_raw access_smb access_tcp access_udp cdda dc1394 dvdnav dvdread pvr qtcapture v4l v4l2
 libvlc_LTLIBRARIES =  $(LTLIBaccess_alsa) $(LTLIBaccess_dv) $(LTLIBaccess_eyetv) $(LTLIBaccess_gnomevfs) $(LTLIBaccess_jack) $(LTLIBaccess_mmap) $(LTLIBaccess_mtp) $(LTLIBaccess_oss) $(LTLIBaccess_smb) $(LTLIBcdda) $(LTLIBdc1394) $(LTLIBdvdnav) $(LTLIBdvdread) $(LTLIBpvr) $(LTLIBqtcapture) $(LTLIBv4l) $(LTLIBv4l2)
 EXTRA_LTLIBRARIES =  libaccess_alsa_plugin.la libaccess_dv_plugin.la libaccess_eyetv_plugin.la libaccess_gnomevfs_plugin.la libaccess_jack_plugin.la libaccess_mmap_plugin.la libaccess_mtp_plugin.la libaccess_oss_plugin.la libaccess_smb_plugin.la libcdda_plugin.la libdc1394_plugin.la libdvdnav_plugin.la libdvdread_plugin.la libpvr_plugin.la libqtcapture_plugin.la libv4l_plugin.la libv4l2_plugin.la
 
@@ -152,6 +152,17 @@
 libaccess_oss_plugin_la_LIBADD = $(AM_LIBADD)
 libaccess_oss_plugin_la_DEPENDENCIES = $(top_srcdir)/src/libvlccore.sym
 
+# The access_raw plugin
+libaccess_raw_plugin_la_SOURCES = $(SOURCES_access_raw)
+nodist_libaccess_raw_plugin_la_SOURCES = $(nodist_SOURCES_access_raw)
+# Force per-target objects:
+libaccess_raw_plugin_la_CFLAGS = $(AM_CFLAGS)
+libaccess_raw_plugin_la_CXXFLAGS = $(AM_CXXFLAGS)
+libaccess_raw_plugin_la_OBJCFLAGS = $(AM_OBJCFLAGS)
+# Set LIBADD and DEPENDENCIES manually:
+libaccess_raw_plugin_la_LIBADD = $(AM_LIBADD)
+libaccess_raw_plugin_la_DEPENDENCIES = $(top_srcdir)/src/libvlccore.sym
+
 # The access_smb plugin
 libaccess_smb_plugin_la_SOURCES = $(SOURCES_access_smb)
 nodist_libaccess_smb_plugin_la_SOURCES = $(nodist_SOURCES_access_smb)
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/access/Modules.am ./modules/access/Modules.am
--- /arno/build/vlc-1.0.5/modules/access/Modules.am	2009-12-20 18:43:39.000000000 +0100
+++ ./modules/access/Modules.am	2010-02-26 14:52:49.000000000 +0100
@@ -41,6 +41,7 @@
 SOURCES_access_alsa = alsa.c
 SOURCES_access_oss = oss.c
 SOURCES_access_mtp = mtp.c
+SOURCES_access_raw = raw.c
 
 libaccess_rtmp_plugin_la_SOURCES = \
         rtmp/access.c \
@@ -60,5 +61,6 @@
 	libaccess_http_plugin.la \
 	libaccess_ftp_plugin.la \
 	libaccess_fake_plugin.la \
+	libaccess_raw_plugin.la \
 	libaccess_rtmp_plugin.la \
 	$(NULL)
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/access/raw.c ./modules/access/raw.c
--- /arno/build/vlc-1.0.5/modules/access/raw.c	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/access/raw.c	2010-02-26 14:52:49.000000000 +0100
@@ -0,0 +1,335 @@
+/*****************************************************************************
+ * raw.c: Raw input module for reading input directly from a C program in the same
+ * address space, for example, and in particular, Python.
+ *
+ *****************************************************************************
+* Copyright (C) 2008-2009  Delft University of Technology. All rights reserved.
+ *
+ * Author: Ivaylo Haratcherev <I.J.Haratcherev@tudelft.nl>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_access.h>
+#include <vlc_demux.h>
+#include <vlc_image.h>
+
+
+#include <stdlib.h>
+#include <string.h>
+#if defined( WIN32 )
+    #define strtok_r(s,d,p) strtok(s,d)
+#endif
+
+#include <vlc/mediacontrol_structures.h>
+
+
+/*****************************************************************************
+ * Module descriptor
+ *****************************************************************************/
+static int  Open ( vlc_object_t * );
+static void Close( vlc_object_t * );
+
+
+#define CACHING_TEXT N_("Caching value in ms")
+#define CACHING_LONGTEXT N_( \
+    "Caching value for raw streams. This " \
+    "value should be set in milliseconds." )
+
+vlc_module_begin();
+    set_description( _("Raw input") );
+    set_shortname( _( "Raw" ) );
+    set_category( CAT_INPUT );
+    set_subcategory( SUBCAT_INPUT_ACCESS );
+    add_integer( "raw-caching", DEFAULT_PTS_DELAY / 1000, NULL, CACHING_TEXT, CACHING_LONGTEXT, true )
+    //  Ivaylo: What the heck is the second parameter in set_capability?
+    set_capability( "access", 10 );
+    add_shortcut( "raw" );
+    set_callbacks( Open, Close );
+vlc_module_end();
+
+
+/*****************************************************************************
+ * Exported prototypes
+ *****************************************************************************/
+static ssize_t Read( access_t *, uint8_t *, size_t );
+static int Seek( access_t *, int64_t );
+static int Control( access_t *, int, va_list );
+
+static int process_options( access_t *p_access );
+
+
+/*****************************************************************************
+ * Local prototypes
+ *****************************************************************************/
+struct access_sys_t
+{
+    int fd;
+
+    bool b_seekable;
+
+/* callback pointers */
+    raw_read_fnc_ptr    read_callback;
+    raw_seek_fnc_ptr    seek_callback;
+    int fsize;
+};
+
+
+
+
+/*****************************************************************************
+ * Open:
+ *****************************************************************************/
+static int Open( vlc_object_t *p_this )
+{
+    access_t     *p_access = (access_t*)p_this;
+    access_sys_t *p_sys;
+
+    /* Set up p_access */
+    p_access->pf_read = Read;
+    p_access->pf_block = NULL;
+    p_access->pf_control = Control;
+    p_access->pf_seek = Seek;
+    p_access->info.i_update = 0;
+    p_access->info.i_size = 0;
+    p_access->info.i_pos = 0;
+    p_access->info.b_eof = false;
+    p_access->info.i_title = 0;
+    p_access->info.i_seekpoint = 0;
+    p_access->p_sys = p_sys = malloc( sizeof( access_sys_t ) );
+    memset( p_sys, 0, sizeof( access_sys_t ) );
+    p_sys->fd = -1;
+    p_sys->b_seekable = true;
+    p_sys->read_callback = NULL;
+    p_sys->seek_callback = NULL;
+    p_sys->fsize = 0;
+    msg_Dbg( p_access, "Open raw before process options. MRL was: %s", p_access->psz_path );
+
+    if ( process_options(p_access) != VLC_SUCCESS )
+    {
+        msg_Err( p_access, "Bad MRL, please check the option line "
+                          "(MRL was: %s)",
+                          p_access->psz_path );
+        free( p_sys );
+        p_access->p_sys = NULL;
+        return VLC_EGENERIC;
+    }
+    p_access->info.i_size = p_sys->fsize;
+    msg_Dbg( p_access, "   read_callback %p, seek_callback %p, fsize %d",
+        p_sys->read_callback, p_sys->seek_callback, p_sys->fsize);
+
+     /* PTS delay */
+    var_Create( p_access, "raw-caching", VLC_VAR_INTEGER |VLC_VAR_DOINHERIT );
+
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * Close:
+ *****************************************************************************/
+static void Close( vlc_object_t *p_this )
+{
+    access_t     *p_access = (access_t*)p_this;
+    access_sys_t *p_sys = p_access->p_sys;
+
+    msg_Dbg( p_access, "Close raw...");
+
+    free( p_sys );
+}
+
+/*****************************************************************************
+ * Read: Read up to i_len bytes from the raw connection and place in
+ * p_buffer. Return the actual number of bytes read
+ *****************************************************************************/
+static ssize_t Read( access_t *p_access, uint8_t *p_buffer, size_t i_len )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    int i_read;
+
+/*    msg_Err( p_access, "Read...");*/
+
+    if( p_access->info.i_size > 0 &&
+        i_len + p_access->info.i_pos > p_access->info.i_size )
+    {
+        if( ( i_len = p_access->info.i_size - p_access->info.i_pos ) == 0 )
+        {
+            p_access->info.b_eof = true;
+            return 0;
+        }
+    }
+
+
+    if( p_sys->read_callback )
+        i_read = p_sys->read_callback(p_buffer, i_len, p_sys->fd);
+    else
+        i_read = 0;
+
+    if( i_read > 0 )
+        p_access->info.i_pos += i_read;
+
+    //msg_Dbg( p_access, "Read: i_read= %d", i_read );
+    return i_read;
+}
+
+
+
+/*****************************************************************************
+ * Seek: close and re-open a connection at the right place
+ *****************************************************************************/
+static int Seek( access_t *p_access, int64_t i_pos )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    msg_Dbg( p_access, "trying to seek to %lld", i_pos );
+
+    if( p_sys->seek_callback ) {
+        if (!p_sys->seek_callback(i_pos, p_sys->fd)) {
+            p_access->info.i_pos = i_pos;
+            if( p_access->info.i_size < p_access->info.i_pos )
+            {
+                msg_Err( p_access, "seeking too far" );
+                p_access->info.i_pos = p_access->info.i_size;
+            }
+            else if( p_access->info.i_pos < 0 )
+            {
+                msg_Err( p_access, "seeking too early" );
+                p_access->info.i_pos = 0;
+            }
+            /* Reset eof */
+            p_access->info.b_eof = false;
+            return VLC_SUCCESS;
+        }
+    }
+
+    return VLC_EGENERIC;
+}
+
+
+/*****************************************************************************
+ * Control:
+ *****************************************************************************/
+static int Control( access_t *p_access, int i_query, va_list args )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+    bool   *pb_bool;
+    int64_t      *pi_64;
+
+    msg_Dbg( p_access, "Control...");
+    switch( i_query )
+    {
+        /* */
+        case ACCESS_CAN_SEEK:
+            pb_bool = (bool *)va_arg( args, bool* );
+            *pb_bool = p_sys->b_seekable;
+            break;
+        case ACCESS_CAN_FASTSEEK:
+            pb_bool = (bool*)va_arg( args, bool* );
+            *pb_bool = true; // Arno: Hack to get AVI seeking to work
+            break;
+        case ACCESS_CAN_PAUSE:
+        case ACCESS_CAN_CONTROL_PACE:
+            pb_bool = (bool*)va_arg( args, bool* );
+            *pb_bool = true;
+            break;
+
+         /* */
+        case ACCESS_GET_PTS_DELAY:
+            pi_64 = (int64_t*)va_arg( args, int64_t * );
+            *pi_64 = (int64_t)var_GetInteger( p_access, "raw-caching" ) * 1000;
+            break;
+
+        case ACCESS_SET_PAUSE_STATE:
+            /* Nothing to do */
+            break;
+
+        case ACCESS_GET_TITLE_INFO:
+        case ACCESS_SET_TITLE:
+        case ACCESS_SET_SEEKPOINT:
+        case ACCESS_SET_PRIVATE_ID_STATE:
+        case ACCESS_GET_META:
+        case ACCESS_GET_PRIVATE_ID_STATE:
+        case ACCESS_GET_CONTENT_TYPE:
+            return VLC_EGENERIC;
+
+        default:
+            msg_Warn( p_access, "unimplemented query %d in control", i_query );
+            return VLC_EGENERIC;
+
+    }
+    return VLC_SUCCESS;
+}
+
+
+static int process_options( access_t *p_access )
+{
+    access_sys_t *p_sys = p_access->p_sys;
+
+    char *psz_dup;
+    char *psz_parser;
+    char *token = NULL;
+    char *state = NULL;
+
+    if( strncmp(p_access->psz_path,"raw",3) != 0 )
+        return VLC_EGENERIC;
+
+    psz_dup = strdup( p_access->psz_path );
+    psz_parser = psz_dup;
+    for( token = strtok_r( psz_parser,":",&state); token;
+         token = strtok_r( NULL, ":", &state ) )
+    {
+        if( strncmp( token, "rptr=", strlen("rptr=") ) == 0)
+        {
+            token += strlen("rptr=");
+            sscanf( token, "0x%p", &p_sys->read_callback );
+            if (p_sys->read_callback == NULL)
+            {
+               // snprintf in src/control/mediacontrol_core.c prints 0x0xADDR
+               // on crosscompiled Win32
+               sscanf( token, "0x0x%p", &p_sys->read_callback );
+            }
+        }
+        else if( strncmp( token, "sptr=", strlen("sptr=") ) == 0)
+        {
+            token += strlen("sptr=");
+            sscanf( token, "0x%p", &p_sys->seek_callback );
+            if (p_sys->seek_callback == NULL)
+            {
+                // snprintf in src/control/mediacontrol_core.c prints 0x0xADDR
+                // on crosscompiled Win32
+                sscanf( token, "0x0x%p", &p_sys->seek_callback );
+            }
+        }
+        else if( strncmp( token, "fsize=", strlen("fsize=") ) == 0)
+        {
+            token += strlen("fsize=");
+            sscanf( token, "%d", &p_sys->fsize );  // Arno: TODO: shouldn't this be int64 like seek's offset?
+        }
+        else if( strncmp( token, "id=", strlen("id=") ) == 0)
+        {
+            token += strlen("id=");
+            sscanf( token, "%d", &p_sys->fd );
+        }
+    }
+    if( psz_dup ) free( psz_dup );
+    return VLC_SUCCESS;
+}
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/access/rtmp/Makefile.am ./modules/access/rtmp/Makefile.am
--- /arno/build/vlc-1.0.5/modules/access/rtmp/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/access/rtmp/Makefile.am	2010-02-26 14:52:48.000000000 +0100
@@ -0,0 +1,22 @@
+# modules/access/rtmp/Makefile.am automatically generated from modules/access/rtmp/Modules.am by modules/genmf
+# DO NOT EDIT THIS FILE DIRECTLY! See Modules.am instead.
+
+basedir = access
+dir = access/rtmp
+mods = access_rtmp
+libvlc_LTLIBRARIES = 
+EXTRA_LTLIBRARIES = 
+
+include $(top_srcdir)/modules/common.am
+
+# The access_rtmp plugin
+libaccess_rtmp_plugin_la_SOURCES = $(SOURCES_access_rtmp)
+nodist_libaccess_rtmp_plugin_la_SOURCES = $(nodist_SOURCES_access_rtmp)
+# Force per-target objects:
+libaccess_rtmp_plugin_la_CFLAGS = $(AM_CFLAGS)
+libaccess_rtmp_plugin_la_CXXFLAGS = $(AM_CXXFLAGS)
+libaccess_rtmp_plugin_la_OBJCFLAGS = $(AM_OBJCFLAGS)
+# Set LIBADD and DEPENDENCIES manually:
+libaccess_rtmp_plugin_la_LIBADD = $(AM_LIBADD)
+libaccess_rtmp_plugin_la_DEPENDENCIES = $(top_srcdir)/src/libvlccore.sym
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/access/rtmp/Makefile.in ./modules/access/rtmp/Makefile.in
--- /arno/build/vlc-1.0.5/modules/access/rtmp/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/access/rtmp/Makefile.in	2010-02-26 14:52:48.000000000 +0100
@@ -0,0 +1,1007 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+# modules/access/rtmp/Makefile.am automatically generated from modules/access/rtmp/Modules.am by modules/genmf
+# DO NOT EDIT THIS FILE DIRECTLY! See Modules.am instead.
+
+# Common code for VLC modules/.../Makefile.am
+#
+# Copyright (C) 2005-2007 the VideoLAN team
+# Copyright (C) 2005-2008 RÃ©mi Denis-Courmont
+#
+# Authors: Sam Hocevar <sam@zoy.org>
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(srcdir)/Modules.am $(top_srcdir)/modules/common.am
+subdir = modules/access/rtmp
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/flags.m4 \
+	$(top_srcdir)/m4/gettext.m4 $(top_srcdir)/m4/iconv.m4 \
+	$(top_srcdir)/m4/intlmacosx.m4 $(top_srcdir)/m4/lib-ld.m4 \
+	$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \
+	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
+	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
+	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/m4/nls.m4 \
+	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/progtest.m4 \
+	$(top_srcdir)/m4/vlc.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libvlcdir)"
+libvlcLTLIBRARIES_INSTALL = $(INSTALL)
+LTLIBRARIES = $(libvlc_LTLIBRARIES)
+am__DEPENDENCIES_1 = `$(VLC_CONFIG) plugin $@` $(LTLIBVLCCORE) \
+	$(top_builddir)/compat/libcompat.la
+am__objects_1 =
+am__objects_2 = libaccess_rtmp_plugin_la-access.lo \
+	libaccess_rtmp_plugin_la-rtmp_amf_flv.lo $(am__objects_1)
+am_libaccess_rtmp_plugin_la_OBJECTS = $(am__objects_2)
+nodist_libaccess_rtmp_plugin_la_OBJECTS =
+libaccess_rtmp_plugin_la_OBJECTS =  \
+	$(am_libaccess_rtmp_plugin_la_OBJECTS) \
+	$(nodist_libaccess_rtmp_plugin_la_OBJECTS)
+libaccess_rtmp_plugin_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libaccess_rtmp_plugin_la_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/autotools/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libaccess_rtmp_plugin_la_SOURCES) \
+	$(nodist_libaccess_rtmp_plugin_la_SOURCES)
+DIST_SOURCES = $(libaccess_rtmp_plugin_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALIASES = @ALIASES@
+ALLOCA = @ALLOCA@
+AMTAR = @AMTAR@
+AM_CPPFLAGS = @AM_CPPFLAGS@
+AR = @AR@
+ARCH = @ARCH@
+AS = @AS@
+ASM = @ASM@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AVCODEC_CFLAGS = @AVCODEC_CFLAGS@
+AVCODEC_LIBS = @AVCODEC_LIBS@
+AVFORMAT_CFLAGS = @AVFORMAT_CFLAGS@
+AVFORMAT_LIBS = @AVFORMAT_LIBS@
+AWK = @AWK@
+BONJOUR_CFLAGS = @BONJOUR_CFLAGS@
+BONJOUR_LIBS = @BONJOUR_LIBS@
+CACA_CONFIG = @CACA_CONFIG@
+CC = @CC@
+CCAS = @CCAS@
+CCASDEPMODE = @CCASDEPMODE@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CONTRIB_DIR = @CONTRIB_DIR@
+COPYRIGHT_MESSAGE = @COPYRIGHT_MESSAGE@
+COPYRIGHT_YEARS = @COPYRIGHT_YEARS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CSRI_CFLAGS = @CSRI_CFLAGS@
+CSRI_LIBS = @CSRI_LIBS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH = @CYGPATH@
+CYGPATH_W = @CYGPATH_W@
+DBUS_CFLAGS = @DBUS_CFLAGS@
+DBUS_LIBS = @DBUS_LIBS@
+DCA_CFLAGS = @DCA_CFLAGS@
+DCA_LIBS = @DCA_LIBS@
+DEFS = @DEFS@
+DEFS_BIGENDIAN = @DEFS_BIGENDIAN@
+DEPDIR = @DEPDIR@
+DIRAC_CFLAGS = @DIRAC_CFLAGS@
+DIRAC_LIBS = @DIRAC_LIBS@
+DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
+DIRECTFB_CONFIG = @DIRECTFB_CONFIG@
+DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DLLTOOL = @DLLTOOL@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+DVDNAV_CONFIG = @DVDNAV_CONFIG@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+FILE_LIBVLCCORE_DLL = @FILE_LIBVLCCORE_DLL@
+FILE_LIBVLC_DLL = @FILE_LIBVLC_DLL@
+FLUIDSYNTH_CFLAGS = @FLUIDSYNTH_CFLAGS@
+FLUIDSYNTH_LIBS = @FLUIDSYNTH_LIBS@
+FREETYPE_CFLAGS = @FREETYPE_CFLAGS@
+FREETYPE_LIBS = @FREETYPE_LIBS@
+FRIBIDI_CFLAGS = @FRIBIDI_CFLAGS@
+FRIBIDI_LIBS = @FRIBIDI_LIBS@
+GETTEXT_MACRO_VERSION = @GETTEXT_MACRO_VERSION@
+GLIB2_CFLAGS = @GLIB2_CFLAGS@
+GLIB2_LIBS = @GLIB2_LIBS@
+GMSGFMT = @GMSGFMT@
+GMSGFMT_015 = @GMSGFMT_015@
+GNOMEVFS_CFLAGS = @GNOMEVFS_CFLAGS@
+GNOMEVFS_LIBS = @GNOMEVFS_LIBS@
+GNUTLS_CFLAGS = @GNUTLS_CFLAGS@
+GNUTLS_LIBS = @GNUTLS_LIBS@
+GREP = @GREP@
+GTK2_CFLAGS = @GTK2_CFLAGS@
+GTK2_LIBS = @GTK2_LIBS@
+HAL_CFLAGS = @HAL_CFLAGS@
+HAL_LIBS = @HAL_LIBS@
+HILDON_CFLAGS = @HILDON_CFLAGS@
+HILDON_LIBS = @HILDON_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INTLLIBS = @INTLLIBS@
+INTL_MACOSX_LIBS = @INTL_MACOSX_LIBS@
+KATE_CFLAGS = @KATE_CFLAGS@
+KATE_LIBS = @KATE_LIBS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBASS_CFLAGS = @LIBASS_CFLAGS@
+LIBASS_LIBS = @LIBASS_LIBS@
+LIBCDDB_CFLAGS = @LIBCDDB_CFLAGS@
+LIBCDDB_LIBS = @LIBCDDB_LIBS@
+LIBCDIO_CFLAGS = @LIBCDIO_CFLAGS@
+LIBCDIO_LIBS = @LIBCDIO_LIBS@
+LIBCDIO_PARANOIA_CFLAGS = @LIBCDIO_PARANOIA_CFLAGS@
+LIBCDIO_PARANOIA_LIBS = @LIBCDIO_PARANOIA_LIBS@
+LIBEXT = @LIBEXT@
+LIBGCRYPT_CFLAGS = @LIBGCRYPT_CFLAGS@
+LIBGCRYPT_CONFIG = @LIBGCRYPT_CONFIG@
+LIBGCRYPT_LIBS = @LIBGCRYPT_LIBS@
+LIBICONV = @LIBICONV@
+LIBINTL = @LIBINTL@
+LIBMPEG2_CFLAGS = @LIBMPEG2_CFLAGS@
+LIBMPEG2_LIBS = @LIBMPEG2_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBPROXY_CFLAGS = @LIBPROXY_CFLAGS@
+LIBPROXY_LIBS = @LIBPROXY_LIBS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIBV4L2_CFLAGS = @LIBV4L2_CFLAGS@
+LIBV4L2_LIBS = @LIBV4L2_LIBS@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
+LTLIBOBJS = @LTLIBOBJS@
+LTLIBa52tofloat32 = @LTLIBa52tofloat32@
+LTLIBa52tospdif = @LTLIBa52tospdif@
+LTLIBaa = @LTLIBaa@
+LTLIBaccess_alsa = @LTLIBaccess_alsa@
+LTLIBaccess_dv = @LTLIBaccess_dv@
+LTLIBaccess_eyetv = @LTLIBaccess_eyetv@
+LTLIBaccess_gnomevfs = @LTLIBaccess_gnomevfs@
+LTLIBaccess_jack = @LTLIBaccess_jack@
+LTLIBaccess_mmap = @LTLIBaccess_mmap@
+LTLIBaccess_mtp = @LTLIBaccess_mtp@
+LTLIBaccess_oss = @LTLIBaccess_oss@
+LTLIBaccess_output_shout = @LTLIBaccess_output_shout@
+LTLIBaccess_realrtsp = @LTLIBaccess_realrtsp@
+LTLIBaccess_smb = @LTLIBaccess_smb@
+LTLIBadjust = @LTLIBadjust@
+LTLIBalphamask = @LTLIBalphamask@
+LTLIBalsa = @LTLIBalsa@
+LTLIBaout_directx = @LTLIBaout_directx@
+LTLIBaout_file = @LTLIBaout_file@
+LTLIBaout_sdl = @LTLIBaout_sdl@
+LTLIBasademux = @LTLIBasademux@
+LTLIBatmo = @LTLIBatmo@
+LTLIBaudio_format = @LTLIBaudio_format@
+LTLIBaudioscrobbler = @LTLIBaudioscrobbler@
+LTLIBauhal = @LTLIBauhal@
+LTLIBavcodec = @LTLIBavcodec@
+LTLIBavformat = @LTLIBavformat@
+LTLIBbandlimited_resampler = @LTLIBbandlimited_resampler@
+LTLIBbda = @LTLIBbda@
+LTLIBbeos = @LTLIBbeos@
+LTLIBblend = @LTLIBblend@
+LTLIBblendbench = @LTLIBblendbench@
+LTLIBbluescreen = @LTLIBbluescreen@
+LTLIBbonjour = @LTLIBbonjour@
+LTLIBcaca = @LTLIBcaca@
+LTLIBcanvas = @LTLIBcanvas@
+LTLIBcdda = @LTLIBcdda@
+LTLIBcddax = @LTLIBcddax@
+LTLIBchain = @LTLIBchain@
+LTLIBclone = @LTLIBclone@
+LTLIBcmml = @LTLIBcmml@
+LTLIBcolorthres = @LTLIBcolorthres@
+LTLIBconverter_float = @LTLIBconverter_float@
+LTLIBcrop = @LTLIBcrop@
+LTLIBcroppadd = @LTLIBcroppadd@
+LTLIBcsri = @LTLIBcsri@
+LTLIBdbus = @LTLIBdbus@
+LTLIBdc1394 = @LTLIBdc1394@
+LTLIBdeinterlace = @LTLIBdeinterlace@
+LTLIBdirac = @LTLIBdirac@
+LTLIBdirect3d = @LTLIBdirect3d@
+LTLIBdirectfb = @LTLIBdirectfb@
+LTLIBdmo = @LTLIBdmo@
+LTLIBdolby_surround_decoder = @LTLIBdolby_surround_decoder@
+LTLIBdshow = @LTLIBdshow@
+LTLIBdtstofloat32 = @LTLIBdtstofloat32@
+LTLIBdtstospdif = @LTLIBdtstospdif@
+LTLIBdvb = @LTLIBdvb@
+LTLIBdvdnav = @LTLIBdvdnav@
+LTLIBdvdread = @LTLIBdvdread@
+LTLIBdynamicoverlay = @LTLIBdynamicoverlay@
+LTLIBequalizer = @LTLIBequalizer@
+LTLIBerase = @LTLIBerase@
+LTLIBextract = @LTLIBextract@
+LTLIBfaad = @LTLIBfaad@
+LTLIBfake = @LTLIBfake@
+LTLIBfb = @LTLIBfb@
+LTLIBfbosd = @LTLIBfbosd@
+LTLIBfloat32_mixer = @LTLIBfloat32_mixer@
+LTLIBfluidsynth = @LTLIBfluidsynth@
+LTLIBfolder = @LTLIBfolder@
+LTLIBfreetype = @LTLIBfreetype@
+LTLIBgalaktos = @LTLIBgalaktos@
+LTLIBgaussianblur = @LTLIBgaussianblur@
+LTLIBgestures = @LTLIBgestures@
+LTLIBggi = @LTLIBggi@
+LTLIBglobalhotkeys = @LTLIBglobalhotkeys@
+LTLIBglwin32 = @LTLIBglwin32@
+LTLIBglx = @LTLIBglx@
+LTLIBgme = @LTLIBgme@
+LTLIBgnome2_main = @LTLIBgnome2_main@
+LTLIBgnome_main = @LTLIBgnome_main@
+LTLIBgnutls = @LTLIBgnutls@
+LTLIBgoom = @LTLIBgoom@
+LTLIBgradient = @LTLIBgradient@
+LTLIBgrain = @LTLIBgrain@
+LTLIBgrowl = @LTLIBgrowl@
+LTLIBgrowl_udp = @LTLIBgrowl_udp@
+LTLIBgtk2_main = @LTLIBgtk2_main@
+LTLIBgtk_main = @LTLIBgtk_main@
+LTLIBhal = @LTLIBhal@
+LTLIBhd1000a = @LTLIBhd1000a@
+LTLIBhd1000v = @LTLIBhd1000v@
+LTLIBheadphone_channel_mixer = @LTLIBheadphone_channel_mixer@
+LTLIBhotkeys = @LTLIBhotkeys@
+LTLIBhttp = @LTLIBhttp@
+LTLIBi420_rgb_mmx = @LTLIBi420_rgb_mmx@
+LTLIBi420_rgb_sse2 = @LTLIBi420_rgb_sse2@
+LTLIBi420_ymga = @LTLIBi420_ymga@
+LTLIBi420_ymga_mmx = @LTLIBi420_ymga_mmx@
+LTLIBi420_yuy2 = @LTLIBi420_yuy2@
+LTLIBi420_yuy2_altivec = @LTLIBi420_yuy2_altivec@
+LTLIBi420_yuy2_mmx = @LTLIBi420_yuy2_mmx@
+LTLIBi420_yuy2_sse2 = @LTLIBi420_yuy2_sse2@
+LTLIBi422_i420 = @LTLIBi422_i420@
+LTLIBi422_yuy2 = @LTLIBi422_yuy2@
+LTLIBi422_yuy2_mmx = @LTLIBi422_yuy2_mmx@
+LTLIBi422_yuy2_sse2 = @LTLIBi422_yuy2_sse2@
+LTLIBid3tag = @LTLIBid3tag@
+LTLIBinhibit = @LTLIBinhibit@
+LTLIBinvert = @LTLIBinvert@
+LTLIBjack = @LTLIBjack@
+LTLIBkate = @LTLIBkate@
+LTLIBlibass = @LTLIBlibass@
+LTLIBlibmpeg2 = @LTLIBlibmpeg2@
+LTLIBlinear_resampler = @LTLIBlinear_resampler@
+LTLIBlirc = @LTLIBlirc@
+LTLIBlive555 = @LTLIBlive555@
+LTLIBlogo = @LTLIBlogo@
+LTLIBmacosx = @LTLIBmacosx@
+LTLIBmaemo = @LTLIBmaemo@
+LTLIBmagnify = @LTLIBmagnify@
+LTLIBmarq = @LTLIBmarq@
+LTLIBmemcpy3dn = @LTLIBmemcpy3dn@
+LTLIBmemcpyaltivec = @LTLIBmemcpyaltivec@
+LTLIBmemcpymmx = @LTLIBmemcpymmx@
+LTLIBmemcpymmxext = @LTLIBmemcpymmxext@
+LTLIBmga = @LTLIBmga@
+LTLIBminimal_macosx = @LTLIBminimal_macosx@
+LTLIBmkv = @LTLIBmkv@
+LTLIBmod = @LTLIBmod@
+LTLIBmosaic = @LTLIBmosaic@
+LTLIBmotion = @LTLIBmotion@
+LTLIBmotionblur = @LTLIBmotionblur@
+LTLIBmotiondetect = @LTLIBmotiondetect@
+LTLIBmozilla = @LTLIBmozilla@
+LTLIBmpc = @LTLIBmpc@
+LTLIBmpgatofixed32 = @LTLIBmpgatofixed32@
+LTLIBmsn = @LTLIBmsn@
+LTLIBmtp = @LTLIBmtp@
+LTLIBmux_ogg = @LTLIBmux_ogg@
+LTLIBmux_ts = @LTLIBmux_ts@
+LTLIBncurses = @LTLIBncurses@
+LTLIBnoise = @LTLIBnoise@
+LTLIBnormvol = @LTLIBnormvol@
+LTLIBnotify = @LTLIBnotify@
+LTLIBntservice = @LTLIBntservice@
+LTLIBogg = @LTLIBogg@
+LTLIBomapfb = @LTLIBomapfb@
+LTLIBopencv_example = @LTLIBopencv_example@
+LTLIBopencv_wrapper = @LTLIBopencv_wrapper@
+LTLIBopengl = @LTLIBopengl@
+LTLIBopengllayer = @LTLIBopengllayer@
+LTLIBopie = @LTLIBopie@
+LTLIBosd_parser = @LTLIBosd_parser@
+LTLIBosdmenu = @LTLIBosdmenu@
+LTLIBoss = @LTLIBoss@
+LTLIBpanoramix = @LTLIBpanoramix@
+LTLIBparam_eq = @LTLIBparam_eq@
+LTLIBpda = @LTLIBpda@
+LTLIBpng = @LTLIBpng@
+LTLIBpodcast = @LTLIBpodcast@
+LTLIBportaudio = @LTLIBportaudio@
+LTLIBpostproc = @LTLIBpostproc@
+LTLIBprobe_hal = @LTLIBprobe_hal@
+LTLIBpsychedelic = @LTLIBpsychedelic@
+LTLIBpulse = @LTLIBpulse@
+LTLIBpuzzle = @LTLIBpuzzle@
+LTLIBpvr = @LTLIBpvr@
+LTLIBqnx = @LTLIBqnx@
+LTLIBqt4 = @LTLIBqt4@
+LTLIBqtcapture = @LTLIBqtcapture@
+LTLIBqte = @LTLIBqte@
+LTLIBqte_main = @LTLIBqte_main@
+LTLIBquartztext = @LTLIBquartztext@
+LTLIBquicktime = @LTLIBquicktime@
+LTLIBrc = @LTLIBrc@
+LTLIBrealaudio = @LTLIBrealaudio@
+LTLIBrealvideo = @LTLIBrealvideo@
+LTLIBremoteosd = @LTLIBremoteosd@
+LTLIBripple = @LTLIBripple@
+LTLIBrotate = @LTLIBrotate@
+LTLIBrss = @LTLIBrss@
+LTLIBrv32 = @LTLIBrv32@
+LTLIBsap = @LTLIBsap@
+LTLIBscale = @LTLIBscale@
+LTLIBscaletempo = @LTLIBscaletempo@
+LTLIBscene = @LTLIBscene@
+LTLIBschroedinger = @LTLIBschroedinger@
+LTLIBscreen = @LTLIBscreen@
+LTLIBscreensaver = @LTLIBscreensaver@
+LTLIBsdl_image = @LTLIBsdl_image@
+LTLIBsharpen = @LTLIBsharpen@
+LTLIBshine = @LTLIBshine@
+LTLIBshout = @LTLIBshout@
+LTLIBshowintf = @LTLIBshowintf@
+LTLIBsignals = @LTLIBsignals@
+LTLIBsimple_channel_mixer = @LTLIBsimple_channel_mixer@
+LTLIBskins2 = @LTLIBskins2@
+LTLIBsnapshot = @LTLIBsnapshot@
+LTLIBspatializer = @LTLIBspatializer@
+LTLIBspdif_mixer = @LTLIBspdif_mixer@
+LTLIBspeex = @LTLIBspeex@
+LTLIBstream_out_raop = @LTLIBstream_out_raop@
+LTLIBsvg = @LTLIBsvg@
+LTLIBsvgalib = @LTLIBsvgalib@
+LTLIBswscale = @LTLIBswscale@
+LTLIBswscale_maemo = @LTLIBswscale_maemo@
+LTLIBtaglib = @LTLIBtaglib@
+LTLIBtarkin = @LTLIBtarkin@
+LTLIBtelepathy = @LTLIBtelepathy@
+LTLIBtelnet = @LTLIBtelnet@
+LTLIBtelx = @LTLIBtelx@
+LTLIBtest1 = @LTLIBtest1@
+LTLIBtest2 = @LTLIBtest2@
+LTLIBtest3 = @LTLIBtest3@
+LTLIBtest4 = @LTLIBtest4@
+LTLIBtheora = @LTLIBtheora@
+LTLIBtransform = @LTLIBtransform@
+LTLIBtremor = @LTLIBtremor@
+LTLIBts = @LTLIBts@
+LTLIBtwolame = @LTLIBtwolame@
+LTLIBunzip = @LTLIBunzip@
+LTLIBupnp_cc = @LTLIBupnp_cc@
+LTLIBupnp_intel = @LTLIBupnp_intel@
+LTLIBv4l = @LTLIBv4l@
+LTLIBv4l2 = @LTLIBv4l2@
+LTLIBvcd = @LTLIBvcd@
+LTLIBvcdx = @LTLIBvcdx@
+LTLIBvisual = @LTLIBvisual@
+LTLIBvmem = @LTLIBvmem@
+LTLIBvorbis = @LTLIBvorbis@
+LTLIBvout_directx = @LTLIBvout_directx@
+LTLIBvout_sdl = @LTLIBvout_sdl@
+LTLIBwall = @LTLIBwall@
+LTLIBwave = @LTLIBwave@
+LTLIBwaveout = @LTLIBwaveout@
+LTLIBwin32text = @LTLIBwin32text@
+LTLIBwince = @LTLIBwince@
+LTLIBwingapi = @LTLIBwingapi@
+LTLIBwingdi = @LTLIBwingdi@
+LTLIBwma_fixed = @LTLIBwma_fixed@
+LTLIBx11 = @LTLIBx11@
+LTLIBx11_screen = @LTLIBx11_screen@
+LTLIBx264 = @LTLIBx264@
+LTLIBxcb = @LTLIBxcb@
+LTLIBxcb_window = @LTLIBxcb_window@
+LTLIBxcb_xv = @LTLIBxcb_xv@
+LTLIBxml = @LTLIBxml@
+LTLIBxosd = @LTLIBxosd@
+LTLIBxvideo = @LTLIBxvideo@
+LTLIBxvmc = @LTLIBxvmc@
+LTLIByuv = @LTLIByuv@
+LTLIByuvp = @LTLIByuvp@
+LTLIByuy2_i420 = @LTLIByuy2_i420@
+LTLIByuy2_i422 = @LTLIByuy2_i422@
+LTLIBzip = @LTLIBzip@
+LTLIBzvbi = @LTLIBzvbi@
+LUA_CFLAGS = @LUA_CFLAGS@
+LUA_LIBS = @LUA_LIBS@
+MACOSX_DEPLOYMENT_TARGET = @MACOSX_DEPLOYMENT_TARGET@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MIDL = @MIDL@
+MINIZIP_CFLAGS = @MINIZIP_CFLAGS@
+MINIZIP_LIBS = @MINIZIP_LIBS@
+MKDIR_P = @MKDIR_P@
+MOC = @MOC@
+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@
+MOZILLA_CONFIG = @MOZILLA_CONFIG@
+MOZILLA_LIBS = @MOZILLA_LIBS@
+MOZILLA_SDK_PATH = @MOZILLA_SDK_PATH@
+MSGFMT = @MSGFMT@
+MSGFMT_015 = @MSGFMT_015@
+MSGMERGE = @MSGMERGE@
+MTP_CFLAGS = @MTP_CFLAGS@
+MTP_LIBS = @MTP_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+NOTIFY_CFLAGS = @NOTIFY_CFLAGS@
+NOTIFY_LIBS = @NOTIFY_LIBS@
+OBJC = @OBJC@
+OBJCDEPMODE = @OBJCDEPMODE@
+OBJCFLAGS = @OBJCFLAGS@
+OBJCOPY = @OBJCOPY@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OPENCV_CFLAGS = @OPENCV_CFLAGS@
+OPENCV_LIBS = @OPENCV_LIBS@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PCRE_CFLAGS = @PCRE_CFLAGS@
+PCRE_LIBS = @PCRE_LIBS@
+PKGDIR = @PKGDIR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+POSTPROC_CFLAGS = @POSTPROC_CFLAGS@
+POSTPROC_LIBS = @POSTPROC_LIBS@
+POSUB = @POSUB@
+PULSE_CFLAGS = @PULSE_CFLAGS@
+PULSE_LIBS = @PULSE_LIBS@
+QT4LOCALEDIR = @QT4LOCALEDIR@
+QT4_CFLAGS = @QT4_CFLAGS@
+QT4_LIBS = @QT4_LIBS@
+RANLIB = @RANLIB@
+RCC = @RCC@
+SCHROEDINGER_CFLAGS = @SCHROEDINGER_CFLAGS@
+SCHROEDINGER_LIBS = @SCHROEDINGER_LIBS@
+SDL11_CONFIG = @SDL11_CONFIG@
+SDL12_CONFIG = @SDL12_CONFIG@
+SDL_CONFIG = @SDL_CONFIG@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SHOUT_CFLAGS = @SHOUT_CFLAGS@
+SHOUT_LIBS = @SHOUT_LIBS@
+STRIP = @STRIP@
+SVG_CFLAGS = @SVG_CFLAGS@
+SVG_LIBS = @SVG_LIBS@
+SWSCALE_CFLAGS = @SWSCALE_CFLAGS@
+SWSCALE_LIBS = @SWSCALE_LIBS@
+SYS = @SYS@
+TAGLIB_CFLAGS = @TAGLIB_CFLAGS@
+TAGLIB_LIBS = @TAGLIB_LIBS@
+TIGER_CFLAGS = @TIGER_CFLAGS@
+TIGER_LIBS = @TIGER_LIBS@
+UIC = @UIC@
+USE_NLS = @USE_NLS@
+VCDINFO_CFLAGS = @VCDINFO_CFLAGS@
+VCDINFO_LIBS = @VCDINFO_LIBS@
+VERSION = @VERSION@
+VERSION_EXTRA = @VERSION_EXTRA@
+VERSION_EXTRA_RC = @VERSION_EXTRA_RC@
+VERSION_MAJOR = @VERSION_MAJOR@
+VERSION_MESSAGE = @VERSION_MESSAGE@
+VERSION_MINOR = @VERSION_MINOR@
+VERSION_REVISION = @VERSION_REVISION@
+VLC_CONFIG = @VLC_CONFIG@
+WIDL = @WIDL@
+WINDRES = @WINDRES@
+WINE_SDK_PATH = @WINE_SDK_PATH@
+X264_CFLAGS = @X264_CFLAGS@
+X264_LIBS = @X264_LIBS@
+XCB_CFLAGS = @XCB_CFLAGS@
+XCB_KEYSYMS_CFLAGS = @XCB_KEYSYMS_CFLAGS@
+XCB_KEYSYMS_LIBS = @XCB_KEYSYMS_LIBS@
+XCB_LIBS = @XCB_LIBS@
+XCB_SHM_CFLAGS = @XCB_SHM_CFLAGS@
+XCB_SHM_LIBS = @XCB_SHM_LIBS@
+XCB_XV_CFLAGS = @XCB_XV_CFLAGS@
+XCB_XV_LIBS = @XCB_XV_LIBS@
+XGETTEXT = @XGETTEXT@
+XGETTEXT_015 = @XGETTEXT_015@
+XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
+XMKMF = @XMKMF@
+XML2_CFLAGS = @XML2_CFLAGS@
+XML2_LIBS = @XML2_LIBS@
+XPM_CFLAGS = @XPM_CFLAGS@
+XPM_LIBS = @XPM_LIBS@
+XPROTO_CFLAGS = @XPROTO_CFLAGS@
+XPROTO_LIBS = @XPROTO_LIBS@
+X_CFLAGS = @X_CFLAGS@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_LIBS = @X_LIBS@
+X_PRE_LIBS = @X_PRE_LIBS@
+ZVBI_CFLAGS = @ZVBI_CFLAGS@
+ZVBI_LIBS = @ZVBI_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+ac_ct_OBJC = @ac_ct_OBJC@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+vlcdatadir = @vlcdatadir@
+vlclibdir = @vlclibdir@
+basedir = access
+dir = access/rtmp
+mods = access_rtmp
+libvlc_LTLIBRARIES = libaccess_rtmp_plugin.la
+EXTRA_LTLIBRARIES = 
+NULL = 
+SUFFIXES = 
+libvlcdir = $(vlclibdir)/$(basedir)
+EXTRA_DIST = Modules.am
+BUILT_SOURCES = 
+CLEANFILES = $(BUILT_SOURCES)
+LTLIBVLCCORE = $(top_builddir)/src/libvlccore.la
+AM_CFLAGS = `$(VLC_CONFIG) --cflags plugin $@`
+AM_CXXFLAGS = `$(VLC_CONFIG) --cxxflags plugin $@`
+AM_OBJCFLAGS = `$(VLC_CONFIG) --objcflags plugin $@`
+AM_LDFLAGS = -rpath '$(libvlcdir)' \
+	-avoid-version -module \
+	-export-symbol-regex ^vlc_entry \
+	-shrext $(LIBEXT) \
+	-no-undefined \
+	 `$(VLC_CONFIG) --ldflags plugin $@`
+
+AM_LIBADD = `$(VLC_CONFIG) -libs plugin $@` \
+	$(LTLIBVLCCORE) $(top_builddir)/compat/libcompat.la
+
+SOURCES_access_rtmp = \
+        access.c \
+        rtmp_amf_flv.c \
+        rtmp_amf_flv.h \
+        $(NULL)
+
+
+# The access_rtmp plugin
+libaccess_rtmp_plugin_la_SOURCES = $(SOURCES_access_rtmp)
+nodist_libaccess_rtmp_plugin_la_SOURCES = $(nodist_SOURCES_access_rtmp)
+# Force per-target objects:
+libaccess_rtmp_plugin_la_CFLAGS = $(AM_CFLAGS)
+libaccess_rtmp_plugin_la_CXXFLAGS = $(AM_CXXFLAGS)
+libaccess_rtmp_plugin_la_OBJCFLAGS = $(AM_OBJCFLAGS)
+# Set LIBADD and DEPENDENCIES manually:
+libaccess_rtmp_plugin_la_LIBADD = $(AM_LIBADD)
+libaccess_rtmp_plugin_la_DEPENDENCIES = $(top_srcdir)/src/libvlccore.sym
+all: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/modules/common.am $(srcdir)/Modules.am $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  modules/access/rtmp/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  modules/access/rtmp/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-libvlcLTLIBRARIES: $(libvlc_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(libvlcdir)" || $(MKDIR_P) "$(DESTDIR)$(libvlcdir)"
+	@list='$(libvlc_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=$(am__strip_dir) \
+	    echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(libvlcLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(libvlcdir)/$$f'"; \
+	    $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(libvlcLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(libvlcdir)/$$f"; \
+	  else :; fi; \
+	done
+
+uninstall-libvlcLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libvlc_LTLIBRARIES)'; for p in $$list; do \
+	  p=$(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libvlcdir)/$$p'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libvlcdir)/$$p"; \
+	done
+
+clean-libvlcLTLIBRARIES:
+	-test -z "$(libvlc_LTLIBRARIES)" || rm -f $(libvlc_LTLIBRARIES)
+	@list='$(libvlc_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libaccess_rtmp_plugin.la: $(libaccess_rtmp_plugin_la_OBJECTS) $(libaccess_rtmp_plugin_la_DEPENDENCIES) 
+	$(libaccess_rtmp_plugin_la_LINK) -rpath $(libvlcdir) $(libaccess_rtmp_plugin_la_OBJECTS) $(libaccess_rtmp_plugin_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libaccess_rtmp_plugin_la-access.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libaccess_rtmp_plugin_la-rtmp_amf_flv.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+libaccess_rtmp_plugin_la-access.lo: access.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libaccess_rtmp_plugin_la_CFLAGS) $(CFLAGS) -MT libaccess_rtmp_plugin_la-access.lo -MD -MP -MF $(DEPDIR)/libaccess_rtmp_plugin_la-access.Tpo -c -o libaccess_rtmp_plugin_la-access.lo `test -f 'access.c' || echo '$(srcdir)/'`access.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libaccess_rtmp_plugin_la-access.Tpo $(DEPDIR)/libaccess_rtmp_plugin_la-access.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='access.c' object='libaccess_rtmp_plugin_la-access.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libaccess_rtmp_plugin_la_CFLAGS) $(CFLAGS) -c -o libaccess_rtmp_plugin_la-access.lo `test -f 'access.c' || echo '$(srcdir)/'`access.c
+
+libaccess_rtmp_plugin_la-rtmp_amf_flv.lo: rtmp_amf_flv.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libaccess_rtmp_plugin_la_CFLAGS) $(CFLAGS) -MT libaccess_rtmp_plugin_la-rtmp_amf_flv.lo -MD -MP -MF $(DEPDIR)/libaccess_rtmp_plugin_la-rtmp_amf_flv.Tpo -c -o libaccess_rtmp_plugin_la-rtmp_amf_flv.lo `test -f 'rtmp_amf_flv.c' || echo '$(srcdir)/'`rtmp_amf_flv.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libaccess_rtmp_plugin_la-rtmp_amf_flv.Tpo $(DEPDIR)/libaccess_rtmp_plugin_la-rtmp_amf_flv.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='rtmp_amf_flv.c' object='libaccess_rtmp_plugin_la-rtmp_amf_flv.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libaccess_rtmp_plugin_la_CFLAGS) $(CFLAGS) -c -o libaccess_rtmp_plugin_la-rtmp_amf_flv.lo `test -f 'rtmp_amf_flv.c' || echo '$(srcdir)/'`rtmp_amf_flv.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(libvlcdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-libvlcLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libvlcLTLIBRARIES
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libvlcLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-libvlcLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-libvlcLTLIBRARIES install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libvlcLTLIBRARIES
+
+
+@MAINTAINER_MODE_TRUE@$(srcdir)/Makefile.am: $(srcdir)/Modules.am $(top_srcdir)/modules/genmf
+@MAINTAINER_MODE_TRUE@	cd \$(top_srcdir) && \$(SHELL) modules/genmf $(dir)
+
+nice:
+	$(top_builddir)/compile
+
+.PHONY: nice
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/access/rtmp/Modules.am ./modules/access/rtmp/Modules.am
--- /arno/build/vlc-1.0.5/modules/access/rtmp/Modules.am	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/access/rtmp/Modules.am	2010-02-26 14:52:48.000000000 +0100
@@ -0,0 +1,6 @@
+SOURCES_access_rtmp = \
+        access.c \
+        rtmp_amf_flv.c \
+        rtmp_amf_flv.h \
+        $(NULL)
+libvlc_LTLIBRARIES += libaccess_rtmp_plugin.la
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/demux/ts.c ./modules/demux/ts.c
--- /arno/build/vlc-1.0.5/modules/demux/ts.c	2009-12-20 18:43:39.000000000 +0100
+++ ./modules/demux/ts.c	2010-02-26 14:52:42.000000000 +0100
@@ -485,9 +485,10 @@
     {
         i_packet_size = TS_PACKET_SIZE_204;
     }
-    else if( p_demux->b_force )
+    else if( 1 || p_demux->b_force ) /* Arno: Patch so VLC will continue to interpret stream as MPEGTS */
     {
         i_packet_size = TS_PACKET_SIZE_188;
+        msg_Warn( p_demux, "TS module forced (lost sync)" );
     }
     else if( b_topfield )
     {
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/stream_out/transrate/block.c ./modules/stream_out/transrate/block.c
--- /arno/build/vlc-1.0.5/modules/stream_out/transrate/block.c	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/stream_out/transrate/block.c	2010-02-26 14:52:41.000000000 +0100
@@ -0,0 +1,808 @@
+/*****************************************************************************
+ * block.c: MPEG2 video transrating module
+ *****************************************************************************
+ * Copyright (C) 2003-2004 the VideoLAN team
+ * Copyright (C) 2003 Antoine Missout
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ * $Id: ff42b4fe035793fc400b510892350be8882205ac $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          Laurent Aimar <fenrir@via.ecp.fr>
+ *          Antoine Missout
+ *          Michel Lespinasse <walken@zoy.org>
+ *          Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#define NDEBUG 1
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <assert.h>
+#include <math.h>
+
+#include <vlc_common.h>
+#include <vlc_sout.h>
+#include <vlc_codec.h>
+
+#include "transrate.h"
+
+/****************************************************************************
+ * transrater, code from M2VRequantizer http://www.metakine.com/
+ ****************************************************************************/
+
+/////---- begin ext mpeg code
+
+#include "getvlc.h"
+#include "putvlc.h"
+
+static inline int saturate( int i_value )
+{
+    if ( i_value > 2047 )
+        return 2047;
+    if ( i_value < -2048 )
+        return -2048;
+    return i_value;
+}
+
+static int64_t get_score( const RunLevel *blk, RunLevel *new_blk, int i_qscale, int i_qscale_new )
+{
+    int64_t score = 0;
+    int i1 = -1, i2 = -1;
+
+    while ( new_blk->level )
+    {
+        int new_level = new_blk->level;
+        int level = blk->level;
+    if ( i1 > 64 || i2 > 64 || !blk->run || !new_blk->run ) return score;
+        if ( i1 + blk->run == i2 + new_blk->run )
+        {
+            int64_t tmp = saturate(level * i_qscale)
+                            - saturate(new_level * i_qscale_new);
+            i1 += blk->run;
+            i2 += new_blk->run;
+            score += tmp * tmp;
+            blk++;
+            new_blk++;
+        }
+        else
+        {
+            int64_t tmp = saturate(level * i_qscale);
+            i1 += blk->run;
+            score += tmp * tmp;
+            blk++;
+        }
+    }
+
+    while ( blk->level )
+    {
+        int level = blk->level;
+        int64_t tmp = saturate(level * i_qscale);
+        i1 += blk->run;
+        score += tmp * tmp;
+        blk++;
+    }
+
+    return score;
+}
+
+static void change_qscale( const RunLevel *blk, RunLevel *new_blk, int i_qscale, int i_qscale_new, int intra )
+{
+    int i = 0, li = 0;
+    int rounding;
+    if ( intra )
+        rounding = i_qscale_new / 3;
+    else
+        rounding = i_qscale_new / 6;
+
+    while ( blk->level )
+    {
+        int level = blk->level > 0 ? blk->level : -blk->level;
+        int new_level = saturate(level * i_qscale) / i_qscale_new;
+        i += blk->run;
+
+        if ( new_level )
+        {
+            new_blk->run = i - li;
+            new_blk->level = blk->level > 0 ? new_level : -new_level;
+            new_blk++;
+            li = i;
+        }
+        blk++;
+    }
+    new_blk->level = 0;
+}
+
+static const uint8_t non_linear_mquant_table[32] =
+{
+    0, 1, 2, 3, 4, 5, 6, 7,
+    8,10,12,14,16,18,20,22,
+    24,28,32,36,40,44,48,52,
+    56,64,72,80,88,96,104,112
+};
+static const uint8_t map_non_linear_mquant[113] =
+{
+    0,1,2,3,4,5,6,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,
+    16,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,
+    22,22,23,23,23,23,24,24,24,24,24,24,24,25,25,25,25,25,25,25,26,26,
+    26,26,26,26,26,26,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,29,
+    29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,31,31,31,31,31
+};
+
+int scale_quant( transrate_t *tr, double qrate )
+{
+    int i_quant = floor( tr->quantizer_scale * qrate + 0.5 );
+
+    if ( tr->q_scale_type )
+    {
+        if ( i_quant < 1 )
+            i_quant = 1;
+        if ( i_quant > 112 )
+            i_quant = 112;
+        i_quant = non_linear_mquant_table[map_non_linear_mquant[i_quant]];
+    }
+    else
+    {
+        if ( i_quant < 2 )
+            i_quant = 2;
+        if ( i_quant > 62 )
+            i_quant = 62;
+        i_quant = (i_quant / 2) * 2; // Must be *even*
+    }
+
+    return i_quant;
+}
+
+static int increment_quant( transrate_t *tr, int i_quant )
+{
+    if ( tr->q_scale_type )
+    {
+        assert( i_quant >= 1 && i_quant <= 112 );
+        i_quant = map_non_linear_mquant[i_quant] + 1;
+        if ( i_quant > 31 )
+            i_quant = 31;
+        i_quant = non_linear_mquant_table[i_quant];
+    }
+    else
+    {
+        assert(!(i_quant & 1));
+        i_quant += 2;
+        if ( i_quant > 62 )
+            i_quant = 62;
+    }
+    return i_quant;
+}
+
+
+static int decrement_quant( transrate_t *tr, int i_quant )
+{
+    if ( tr->q_scale_type )
+    {
+        assert( i_quant >= 1 && i_quant <= 112 );
+        i_quant = map_non_linear_mquant[i_quant] - 1;
+        if ( i_quant < 1 )
+            i_quant = 1;
+        i_quant = non_linear_mquant_table[i_quant];
+    }
+    else
+    {
+        assert(!(i_quant & 1));
+        i_quant -= 2;
+        if ( i_quant < 2 )
+            i_quant = 2;
+    }
+    return i_quant;
+}
+
+static void quantize_block( transrate_t *tr, RunLevel *new_blk, int intra )
+{
+    RunLevel old_blk[65];
+    RunLevel *blk = old_blk;
+    const uint8_t *old_matrix, *new_matrix;
+    int i = 0, li = 0;
+
+    memcpy( blk, new_blk, 65 * sizeof(RunLevel) );
+    if ( intra )
+    {
+        old_matrix = tr->intra_quantizer_matrix;
+        new_matrix = mpeg4_default_intra_matrix;
+    }
+    else
+    {
+        old_matrix = tr->non_intra_quantizer_matrix;
+        new_matrix = mpeg4_default_non_intra_matrix;
+    }
+
+    while ( blk->level )
+    {
+        int level = blk->level > 0 ? blk->level : -blk->level;
+        int new_level = (level * old_matrix[i] + new_matrix[i]/2)
+                            / new_matrix[i];
+        i += blk->run;
+
+        if (new_level)
+        {
+            new_blk->run = i - li;
+            new_blk->level = blk->level > 0 ? new_level : -new_level;
+            new_blk++;
+            li = i;
+        }
+        blk++;
+    }
+    new_blk->level = 0;
+}
+
+int transrate_mb( transrate_t *tr, RunLevel blk[6][65], RunLevel new_blk[6][65],
+                  int i_cbp, int intra )
+{
+    int i_qscale = tr->quantizer_scale;
+    int i_guessed_qscale = tr->new_quantizer_scale;
+    int64_t i_last_error = 0;
+    int i_last_qscale;
+    int i_last_qscale_same_error = 0;
+    int i_direction = 0;
+    int i_new_cbp;
+    int i_nb_blocks = 0;
+    int i_nb_coeffs = 0;
+    int i;
+
+    for ( i = 0; i < 6; i++ )
+    {
+        if ( i_cbp & (1 << (5 - i)) )
+        {
+            RunLevel *cur_blk = blk[i];
+            i_nb_blocks++;
+            while ( cur_blk->level )
+            {
+                cur_blk++;
+                i_nb_coeffs++;
+            }
+        }
+    }
+
+    /* See if we can change quantizer scale */
+    for ( ; ; )
+    {
+        int64_t i_error = 0;
+        i_new_cbp = 0;
+
+        for ( i = 0; i < 6; i++ )
+        {
+            if ( i_cbp & (1 << (5 - i)) )
+            {
+                int64_t i_block_error;
+                change_qscale( blk[i], new_blk[i], i_qscale, i_guessed_qscale,
+                               intra );
+                i_block_error = get_score( blk[i], new_blk[i],
+                                           i_qscale, i_guessed_qscale );
+                if ( i > 3 ) i_block_error *= 4;
+                if ( i_block_error > i_error )
+                    i_error = i_block_error;
+                if ( new_blk[i]->level )
+                    i_new_cbp |= (1 << (5 - i));
+            }
+        }
+
+        if ( i_error >= (int64_t)tr->i_minimum_error
+                && i_error <= (int64_t)tr->i_admissible_error )
+        {
+            break;
+        }
+        if ( i_nb_coeffs <= 15 && i_error <= (int64_t)tr->i_admissible_error )
+        {
+            /* There is no interest in changing the qscale (takes up 5 bits
+             * we won't regain) */
+            break;
+        }
+
+        if ( !i_direction )
+        {
+            if ( i_error > (int64_t)tr->i_admissible_error )
+            {
+                i_direction = -1;
+                i_last_qscale = i_guessed_qscale;
+                i_guessed_qscale = decrement_quant( tr, i_guessed_qscale );
+            }
+            else
+            {
+                i_direction = +1;
+                i_last_qscale = i_guessed_qscale;
+                i_guessed_qscale = increment_quant( tr, i_guessed_qscale );
+                i_last_error = i_error;
+                i_last_qscale_same_error = i_last_qscale;
+            }
+            if ( i_guessed_qscale == i_last_qscale )
+                break;
+        }
+        else if ( i_direction < 0 )
+        {
+            if ( i_error > (int64_t)tr->i_admissible_error )
+            {
+                i_last_qscale = i_guessed_qscale;
+                i_guessed_qscale = decrement_quant( tr, i_guessed_qscale );
+                if ( i_guessed_qscale == i_last_qscale )
+                    break;
+            }
+            else
+            {
+                break;
+            }
+        }
+        else
+        {
+            if ( i_error < (int64_t)tr->i_minimum_error )
+            {
+                i_last_qscale = i_guessed_qscale;
+                i_guessed_qscale = increment_quant( tr, i_guessed_qscale );
+                if ( i_error > i_last_error )
+                {
+                    i_last_error = i_error;
+                    i_last_qscale_same_error = i_last_qscale;
+                }
+                if ( i_guessed_qscale == i_last_qscale )
+                {
+                    if ( i_last_error == i_error )
+                    {
+                        i_guessed_qscale = i_last_qscale_same_error;
+                        if ( i_guessed_qscale == i_qscale )
+                        {
+                            memcpy( new_blk, blk, sizeof(RunLevel)*65*6 );
+                            i_new_cbp = i_cbp;
+                        }
+                        else
+                        {
+                            i_new_cbp = 0;
+                            for ( i = 0; i < 6; i++ )
+                            {
+                                if ( i_cbp & (1 << (5 - i)) )
+                                {
+                                    change_qscale( blk[i], new_blk[i],
+                                                   i_qscale, i_guessed_qscale,
+                                                   intra );
+                                    if ( new_blk[i]->level )
+                                        i_new_cbp |= (1 << (5 - i));
+                                }
+                            }
+                        }
+                    }
+                    break;
+                }
+            }
+            else
+            {
+                if ( i_error > (int64_t)tr->i_admissible_error
+                        || i_last_error == i_error )
+                {
+                    i_guessed_qscale = i_last_qscale_same_error;
+                    if ( i_guessed_qscale == i_qscale )
+                    {
+                        memcpy( new_blk, blk, sizeof(RunLevel)*65*6 );
+                        i_new_cbp = i_cbp;
+                    }
+                    else
+                    {
+                        i_new_cbp = 0;
+                        for ( i = 0; i < 6; i++ )
+                        {
+                            if ( i_cbp & (1 << (5 - i)) )
+                            {
+                                change_qscale( blk[i], new_blk[i],
+                                               i_qscale, i_guessed_qscale,
+                                               intra );
+                                if ( new_blk[i]->level )
+                                    i_new_cbp |= (1 << (5 - i));
+                            }
+                        }
+                    }
+                }
+                break;
+            }
+        }
+    }
+
+    tr->new_quantizer_scale = i_guessed_qscale;
+
+#if 0
+    /* Now see if we can drop coeffs */
+    for ( i = 0; i < 6; i++ )
+    {
+        if ( i_new_cbp & (1 << (5 - i)) )
+        {
+            for ( ; ; )
+            {
+                RunLevel *last_blk = new_blk[i];
+                uint8_t old_level;
+
+                while ( last_blk[1].level )
+                    last_blk++;
+                if ( last_blk == new_blk[i] )
+                    break;
+                old_level = last_blk->level;
+                last_blk->level = 0;
+                i_error = get_score( blk[i], new_blk[i],
+                                     i_qscale, i_guessed_qscale );
+                if ( i_error > tr->i_admissible_error )
+                {
+                    last_blk->level = old_level;
+                    break;
+                }
+            }
+        }
+    }
+#endif
+
+    return i_new_cbp;
+}
+
+void get_intra_block_B14( transrate_t *tr, RunLevel *blk )
+{
+    bs_transrate_t *bs = &tr->bs;
+    int i, li;
+    int val;
+    const DCTtab * tab;
+
+    li = i = 0;
+
+    for( ;; )
+    {
+        if (bs->i_bit_in_cache >= 0x28000000)
+        {
+            tab = DCT_B14AC_5 + (UBITS (bs->i_bit_in_cache, 5) - 5);
+
+            i += tab->run;
+            if (i >= 64) break; /* end of block */
+
+    normal_code:
+            bs_flush( bs, tab->len );
+            val = tab->level;
+            val = (val ^ SBITS (bs->i_bit_in_cache, 1)) - SBITS (bs->i_bit_in_cache, 1);
+            blk->level = val;
+            blk->run = i - li - 1;
+            li = i;
+            blk++;
+
+            bs_flush( bs, 1 );
+            continue;
+        }
+        else if (bs->i_bit_in_cache >= 0x04000000)
+        {
+            tab = DCT_B14_8 + (UBITS (bs->i_bit_in_cache, 8) - 4);
+
+            i += tab->run;
+            if (i < 64) goto normal_code;
+
+            /* escape code */
+            i += (UBITS (bs->i_bit_in_cache, 12) & 0x3F) - 64;
+            if (i >= 64) break; /* illegal, check needed to avoid buffer overflow */
+
+            bs_flush( bs, 12 );
+            val = SBITS (bs->i_bit_in_cache, 12);
+            blk->level = val;
+            blk->run = i - li - 1;
+            li = i;
+            blk++;
+
+            bs_flush( bs, 12 );
+
+            continue;
+        }
+        else if (bs->i_bit_in_cache >= 0x02000000)
+        {
+            tab = DCT_B14_10 + (UBITS (bs->i_bit_in_cache, 10) - 8);
+            i += tab->run;
+            if (i < 64 ) goto normal_code;
+        }
+        else if (bs->i_bit_in_cache >= 0x00800000)
+        {
+            tab = DCT_13 + (UBITS (bs->i_bit_in_cache, 13) - 16);
+            i += tab->run;
+            if (i < 64 ) goto normal_code;
+        }
+        else if (bs->i_bit_in_cache >= 0x00200000)
+        {
+            tab = DCT_15 + (UBITS (bs->i_bit_in_cache, 15) - 16);
+            i += tab->run;
+            if (i < 64 ) goto normal_code;
+        }
+        else
+        {
+            tab = DCT_16 + UBITS (bs->i_bit_in_cache, 16);
+            bs_flush( bs, 16 );
+            i += tab->run;
+            if (i < 64 ) goto normal_code;
+        }
+        fprintf(stderr, "Err in B14\n");
+    tr->b_error = 1;
+        break;  /* illegal, check needed to avoid buffer overflow */
+    }
+    bs_flush( bs, 2 );    /* dump end of block code */
+    blk->level = 0;
+
+    if ( tr->mpeg4_matrix )
+        quantize_block( tr, blk, 1 );
+}
+
+void get_intra_block_B15( transrate_t *tr, RunLevel *blk )
+{
+    bs_transrate_t *bs = &tr->bs;
+    int i, li;
+    int val;
+    const DCTtab * tab;
+
+    li = i = 0;
+
+    for( ;; )
+    {
+        if (bs->i_bit_in_cache >= 0x04000000)
+        {
+            tab = DCT_B15_8 + (UBITS (bs->i_bit_in_cache, 8) - 4);
+
+            i += tab->run;
+            if (i < 64)
+            {
+    normal_code:
+                bs_flush( bs, tab->len );
+
+                val = tab->level;
+                val = (val ^ SBITS (bs->i_bit_in_cache, 1)) - SBITS (bs->i_bit_in_cache, 1);
+                blk->level = val;
+                blk->run = i - li - 1;
+                li = i;
+                blk++;
+
+                bs_flush( bs, 1 );
+                continue;
+            }
+            else
+            {
+                i += (UBITS (bs->i_bit_in_cache, 12) & 0x3F) - 64;
+
+                if (i >= 64) break; /* illegal, check against buffer overflow */
+
+                bs_flush( bs, 12 );
+                val = SBITS (bs->i_bit_in_cache, 12);
+                blk->level = val;
+                blk->run = i - li - 1;
+                li = i;
+                blk++;
+
+                bs_flush( bs, 12 );
+                continue;
+            }
+        }
+        else if (bs->i_bit_in_cache >= 0x02000000)
+        {
+            tab = DCT_B15_10 + (UBITS (bs->i_bit_in_cache, 10) - 8);
+            i += tab->run;
+            if (i < 64) goto normal_code;
+        }
+        else if (bs->i_bit_in_cache >= 0x00800000)
+        {
+            tab = DCT_13 + (UBITS (bs->i_bit_in_cache, 13) - 16);
+            i += tab->run;
+            if (i < 64) goto normal_code;
+        }
+        else if (bs->i_bit_in_cache >= 0x00200000)
+        {
+            tab = DCT_15 + (UBITS (bs->i_bit_in_cache, 15) - 16);
+            i += tab->run;
+            if (i < 64) goto normal_code;
+        }
+        else
+        {
+            tab = DCT_16 + UBITS (bs->i_bit_in_cache, 16);
+            bs_flush( bs, 16 );
+            i += tab->run;
+            if (i < 64) goto normal_code;
+        }
+        fprintf(stderr, "Err in B15\n");
+    tr->b_error = 1;
+        break;  /* illegal, check needed to avoid buffer overflow */
+    }
+    bs_flush( bs, 4 );    /* dump end of block code */
+    blk->level = 0;
+
+    if ( tr->mpeg4_matrix )
+        quantize_block( tr, blk, 1 );
+}
+
+
+int get_non_intra_block( transrate_t *tr, RunLevel *blk )
+{
+    bs_transrate_t *bs = &tr->bs;
+    int i, li;
+    int val;
+    const DCTtab * tab;
+
+    li = i = -1;
+
+    if (bs->i_bit_in_cache >= 0x28000000)
+    {
+        tab = DCT_B14DC_5 + (UBITS (bs->i_bit_in_cache, 5) - 5);
+        goto entry_1;
+    }
+    else goto entry_2;
+
+    for( ;; )
+    {
+        if (bs->i_bit_in_cache >= 0x28000000)
+        {
+            tab = DCT_B14AC_5 + (UBITS (bs->i_bit_in_cache, 5) - 5);
+
+    entry_1:
+            i += tab->run;
+            if (i >= 64)
+            break;  /* end of block */
+
+    normal_code:
+
+            bs_flush( bs, tab->len );
+            val = tab->level;
+            val = (val ^ SBITS (bs->i_bit_in_cache, 1)) - SBITS (bs->i_bit_in_cache, 1);
+            blk->level = val;
+            blk->run = i - li - 1;
+            li = i;
+            blk++;
+
+            //if ( ((val) && (tab->level < tst)) || ((!val) && (tab->level >= tst)) )
+            //  LOGF("level: %i val: %i tst : %i q: %i nq : %i\n", tab->level, val, tst, q, nq);
+
+            bs_flush( bs, 1 );
+            continue;
+        }
+
+    entry_2:
+        if (bs->i_bit_in_cache >= 0x04000000)
+        {
+            tab = DCT_B14_8 + (UBITS (bs->i_bit_in_cache, 8) - 4);
+
+            i += tab->run;
+            if (i < 64) goto normal_code;
+
+            /* escape code */
+
+            i += (UBITS (bs->i_bit_in_cache, 12) & 0x3F) - 64;
+
+            if (i >= 64) break; /* illegal, check needed to avoid buffer overflow */
+
+            bs_flush( bs, 12 );
+            val = SBITS (bs->i_bit_in_cache, 12);
+            blk->level = val;
+            blk->run = i - li - 1;
+            li = i;
+            blk++;
+
+            bs_flush( bs, 12 );
+            continue;
+        }
+        else if (bs->i_bit_in_cache >= 0x02000000)
+        {
+            tab = DCT_B14_10 + (UBITS (bs->i_bit_in_cache, 10) - 8);
+            i += tab->run;
+            if (i < 64) goto normal_code;
+        }
+        else if (bs->i_bit_in_cache >= 0x00800000)
+        {
+            tab = DCT_13 + (UBITS (bs->i_bit_in_cache, 13) - 16);
+            i += tab->run;
+            if (i < 64) goto normal_code;
+        }
+        else if (bs->i_bit_in_cache >= 0x00200000)
+        {
+            tab = DCT_15 + (UBITS (bs->i_bit_in_cache, 15) - 16);
+            i += tab->run;
+            if (i < 64) goto normal_code;
+        }
+        else
+        {
+            tab = DCT_16 + UBITS (bs->i_bit_in_cache, 16);
+            bs_flush( bs, 16 );
+
+            i += tab->run;
+            if (i < 64) goto normal_code;
+        }
+        fprintf(stderr, "Err in non-intra\n");
+    tr->b_error = 1;
+        break;  /* illegal, check needed to avoid buffer overflow */
+    }
+    bs_flush( bs, 2 );    /* dump end of block code */
+    blk->level = 0;
+
+    if ( tr->mpeg4_matrix )
+        quantize_block( tr, blk, 0 );
+
+    return i;
+}
+
+static inline void putAC( bs_transrate_t *bs, int run, int signed_level, int vlcformat)
+{
+    int level, len;
+    const VLCtable *ptab = NULL;
+
+    level = (signed_level<0) ? -signed_level : signed_level; /* abs(signed_level) */
+
+    assert(!(run<0 || run>63 || level==0 || level>2047));
+
+    len = 0;
+
+    if (run<2 && level<41)
+    {
+        if (vlcformat)  ptab = &dct_code_tab1a[run][level-1];
+        else ptab = &dct_code_tab1[run][level-1];
+        len = ptab->len;
+    }
+    else if (run<32 && level<6)
+    {
+        if (vlcformat) ptab = &dct_code_tab2a[run-2][level-1];
+        else ptab = &dct_code_tab2[run-2][level-1];
+        len = ptab->len;
+    }
+
+    if (len) /* a VLC code exists */
+    {
+        bs_write( bs, ptab->code, len);
+        bs_write( bs, signed_level<0, 1); /* sign */
+    }
+    else
+    {
+        bs_write( bs, 1l, 6); /* Escape */
+        bs_write( bs, run, 6); /* 6 bit code for run */
+        bs_write( bs, ((unsigned int)signed_level) & 0xFFF, 12);
+    }
+}
+
+
+static inline void putACfirst( bs_transrate_t *bs, int run, int val)
+{
+    if (run==0 && (val==1 || val==-1)) bs_write( bs, 2|(val<0), 2 );
+    else putAC( bs, run, val, 0);
+}
+
+void putnonintrablk( bs_transrate_t *bs, RunLevel *blk)
+{
+    assert(blk->level);
+
+    putACfirst( bs, blk->run, blk->level );
+    blk++;
+
+    while (blk->level)
+    {
+        putAC( bs, blk->run, blk->level, 0 );
+        blk++;
+    }
+
+    bs_write( bs, 2, 2 );
+}
+
+void putintrablk( bs_transrate_t *bs, RunLevel *blk, int vlcformat)
+{
+    while (blk->level)
+    {
+        putAC( bs, blk->run, blk->level, vlcformat );
+        blk++;
+    }
+
+    if (vlcformat)
+        bs_write( bs, 6, 4 );
+    else
+        bs_write( bs, 2, 2 );
+}
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/stream_out/transrate/frame.c ./modules/stream_out/transrate/frame.c
--- /arno/build/vlc-1.0.5/modules/stream_out/transrate/frame.c	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/stream_out/transrate/frame.c	2010-02-26 14:52:41.000000000 +0100
@@ -0,0 +1,1354 @@
+/*****************************************************************************
+ * frame.c: MPEG2 video transrating module
+ *****************************************************************************
+ * Copyright (C) 2003-2004 the VideoLAN team
+ * Copyright (C) 2003 Antoine Missout <antoine.missout@metakine.com>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ * $Id: 4b474d16f5a3c23ac0b21987fad76c07fe22eb5d $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          Laurent Aimar <fenrir@via.ecp.fr>
+ *          Antoine Missout <antoine.missout@metakine.com>
+ *          Michel Lespinasse <walken@zoy.org>
+ *          Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#define NDEBUG 1
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <assert.h>
+#include <math.h>
+
+#include <vlc_common.h>
+#include <vlc_sout.h>
+#include <vlc_codec.h>
+
+#include "transrate.h"
+
+/****************************************************************************
+ * transrater, code from M2VRequantizer http://www.metakine.com/
+ ****************************************************************************/
+
+// useful constants
+enum
+{
+    I_TYPE = 1,
+    P_TYPE = 2,
+    B_TYPE = 3
+};
+
+
+/////---- begin ext mpeg code
+
+#include "putvlc.h"
+
+#include "getvlc.h"
+
+static const int non_linear_quantizer_scale [] =
+{
+     0,  1,  2,  3,  4,  5,   6,   7,
+     8, 10, 12, 14, 16, 18,  20,  22,
+    24, 28, 32, 36, 40, 44,  48,  52,
+    56, 64, 72, 80, 88, 96, 104, 112
+};
+
+static inline int get_macroblock_modes( transrate_t *tr )
+{
+    bs_transrate_t *bs = &tr->bs;
+
+    int macroblock_modes;
+    const MBtab * tab;
+
+    switch( tr->picture_coding_type )
+    {
+        case I_TYPE:
+
+            tab = MB_I + UBITS (bs->i_bit_in_cache, 1);
+            bs_flush( bs, tab->len );
+            macroblock_modes = tab->modes;
+
+            if ((!(tr->frame_pred_frame_dct)) && (tr->picture_structure == FRAME_PICTURE))
+            {
+                macroblock_modes |= UBITS (bs->i_bit_in_cache, 1) * DCT_TYPE_INTERLACED;
+                bs_flush( bs, 1 );
+            }
+
+            return macroblock_modes;
+
+        case P_TYPE:
+
+            tab = MB_P + UBITS (bs->i_bit_in_cache, 5);
+            bs_flush( bs, tab->len );
+            macroblock_modes = tab->modes;
+
+            if (tr->picture_structure != FRAME_PICTURE)
+            {
+                if (macroblock_modes & MACROBLOCK_MOTION_FORWARD)
+                {
+                    macroblock_modes |= UBITS (bs->i_bit_in_cache, 2) * MOTION_TYPE_BASE;
+                    bs_flush( bs, 2 );
+                }
+                return macroblock_modes;
+            }
+            else if (tr->frame_pred_frame_dct)
+            {
+                if (macroblock_modes & MACROBLOCK_MOTION_FORWARD)
+                    macroblock_modes |= MC_FRAME;
+                return macroblock_modes;
+            }
+            else
+            {
+                if (macroblock_modes & MACROBLOCK_MOTION_FORWARD)
+                {
+                    macroblock_modes |= UBITS (bs->i_bit_in_cache, 2) * MOTION_TYPE_BASE;
+                    bs_flush( bs, 2 );
+                }
+                if (macroblock_modes & (MACROBLOCK_INTRA | MACROBLOCK_PATTERN))
+                {
+                    macroblock_modes |= UBITS (bs->i_bit_in_cache, 1) * DCT_TYPE_INTERLACED;
+                    bs_flush( bs, 1 );
+                }
+                return macroblock_modes;
+            }
+
+        case B_TYPE:
+
+            tab = MB_B + UBITS (bs->i_bit_in_cache, 6);
+            bs_flush( bs, tab->len );
+            macroblock_modes = tab->modes;
+
+            if( tr->picture_structure != FRAME_PICTURE)
+            {
+                if (! (macroblock_modes & MACROBLOCK_INTRA))
+                {
+                    macroblock_modes |= UBITS (bs->i_bit_in_cache, 2) * MOTION_TYPE_BASE;
+                    bs_flush( bs, 2 );
+                }
+                return macroblock_modes;
+            }
+            else if (tr->frame_pred_frame_dct)
+            {
+                /* if (! (macroblock_modes & MACROBLOCK_INTRA)) */
+                macroblock_modes |= MC_FRAME;
+                return macroblock_modes;
+            }
+            else
+            {
+                if (macroblock_modes & MACROBLOCK_INTRA) goto intra;
+                macroblock_modes |= UBITS (bs->i_bit_in_cache, 2) * MOTION_TYPE_BASE;
+                bs_flush( bs, 2 );
+                if (macroblock_modes & (MACROBLOCK_INTRA | MACROBLOCK_PATTERN))
+                {
+                    intra:
+                    macroblock_modes |= UBITS (bs->i_bit_in_cache, 1) * DCT_TYPE_INTERLACED;
+                    bs_flush( bs, 1 );
+                }
+                return macroblock_modes;
+            }
+
+        default:
+            return 0;
+    }
+
+}
+
+static inline int get_quantizer_scale( transrate_t *tr )
+{
+    bs_transrate_t *bs = &tr->bs;
+
+    int quantizer_scale_code;
+
+    quantizer_scale_code = UBITS (bs->i_bit_in_cache, 5);
+    bs_flush( bs, 5 );
+
+    if( tr->q_scale_type )
+        return non_linear_quantizer_scale[quantizer_scale_code];
+    else
+        return quantizer_scale_code << 1;
+}
+
+static inline int get_motion_delta( bs_transrate_t *bs, const int f_code )
+{
+    int delta;
+    int sign;
+    const MVtab * tab;
+
+    if (bs->i_bit_in_cache & 0x80000000)
+    {
+        bs_copy( bs, 1 );
+        return 0;
+    }
+    else if (bs->i_bit_in_cache >= 0x0c000000)
+    {
+
+        tab = MV_4 + UBITS (bs->i_bit_in_cache, 4);
+        delta = (tab->delta << f_code) + 1;
+        bs_copy( bs, tab->len);
+
+        sign = SBITS (bs->i_bit_in_cache, 1);
+        bs_copy( bs, 1 );
+
+        if (f_code)
+        {
+            delta += UBITS (bs->i_bit_in_cache, f_code);
+            bs_copy( bs, f_code);
+        }
+
+        return (delta ^ sign) - sign;
+    }
+    else
+    {
+
+        tab = MV_10 + UBITS (bs->i_bit_in_cache, 10);
+        delta = (tab->delta << f_code) + 1;
+        bs_copy( bs, tab->len);
+
+        sign = SBITS (bs->i_bit_in_cache, 1);
+        bs_copy( bs, 1);
+
+        if (f_code)
+        {
+            delta += UBITS (bs->i_bit_in_cache, f_code);
+            bs_copy( bs, f_code);
+        }
+
+        return (delta ^ sign) - sign;
+    }
+}
+
+
+static inline int get_dmv( bs_transrate_t *bs )
+{
+    const DMVtab * tab;
+
+    tab = DMV_2 + UBITS (bs->i_bit_in_cache, 2);
+    bs_copy( bs, tab->len);
+    return tab->dmv;
+}
+
+static inline int get_coded_block_pattern( bs_transrate_t *bs )
+{
+    const CBPtab * tab;
+
+    if (bs->i_bit_in_cache >= 0x20000000)
+    {
+        tab = CBP_7 + (UBITS (bs->i_bit_in_cache, 7) - 16);
+        bs_flush( bs, tab->len );
+        return tab->cbp;
+    }
+    else
+    {
+        tab = CBP_9 + UBITS (bs->i_bit_in_cache, 9);
+        bs_flush( bs, tab->len );
+        return tab->cbp;
+    }
+}
+
+static inline int get_luma_dc_dct_diff( bs_transrate_t *bs, uint32_t *bits, uint8_t *len )
+{
+    const DCtab * tab;
+    int size;
+    int dc_diff;
+
+    if (bs->i_bit_in_cache < 0xf8000000)
+    {
+        tab = DC_lum_5 + UBITS (bs->i_bit_in_cache, 5);
+        size = tab->size;
+        if (size)
+        {
+            *bits = bs_read( bs, tab->len );
+            *len = tab->len;
+            //dc_diff = UBITS (bs->i_bit_in_cache, size) - UBITS (SBITS (~bs->i_bit_in_cache, 1), size);
+            dc_diff = UBITS (bs->i_bit_in_cache, size);
+            if (!(dc_diff >> (size - 1))) dc_diff = (dc_diff + 1) - (1 << size);
+            *bits <<= size;
+            *bits |= bs_read( bs, size );
+            *len += size;
+            return dc_diff;
+        }
+        else
+        {
+            *bits = bs_read( bs, 3 );
+            *len = 3;
+            return 0;
+        }
+    }
+    else
+    {
+        tab = DC_long + (UBITS (bs->i_bit_in_cache, 9) - 0x1e0);
+        size = tab->size;
+        *bits = bs_read( bs, tab->len );
+        *len = tab->len;
+        //dc_diff = UBITS (bs->i_bit_in_cache, size) - UBITS (SBITS (~bs->i_bit_in_cache, 1), size);
+        dc_diff = UBITS (bs->i_bit_in_cache, size);
+        if (!(dc_diff >> (size - 1))) dc_diff = (dc_diff + 1) - (1 << size);
+        *bits <<= size;
+        *bits |= bs_read( bs, size );
+        *len += size;
+        return dc_diff;
+    }
+}
+
+static inline int get_chroma_dc_dct_diff( bs_transrate_t *bs, uint32_t *bits, uint8_t *len )
+{
+    const DCtab * tab;
+    int size;
+    int dc_diff;
+
+    if (bs->i_bit_in_cache < 0xf8000000)
+    {
+        tab = DC_chrom_5 + UBITS (bs->i_bit_in_cache, 5);
+        size = tab->size;
+        if (size)
+        {
+            *bits = bs_read( bs, tab->len );
+            *len = tab->len;
+            //dc_diff = UBITS (bs->i_bit_in_cache, size) - UBITS (SBITS (~bs->i_bit_in_cache, 1), size);
+            dc_diff = UBITS (bs->i_bit_in_cache, size);
+            if (!(dc_diff >> (size - 1))) dc_diff = (dc_diff + 1) - (1 << size);
+            *bits <<= size;
+            *bits |= bs_read( bs, size );
+            *len += size;
+            return dc_diff;
+        }
+        else
+        {
+            *bits = bs_read( bs, 2 );
+            *len = 2;
+            return 0;
+        }
+    }
+    else
+    {
+        tab = DC_long + (UBITS (bs->i_bit_in_cache, 10) - 0x3e0);
+        size = tab->size;
+        *bits = bs_read( bs, tab->len + 1 );
+        *len = tab->len + 1;
+        //dc_diff = UBITS (bs->i_bit_in_cache, size) - UBITS (SBITS (~bs->i_bit_in_cache, 1), size);
+        dc_diff = UBITS (bs->i_bit_in_cache, size);
+        if (!(dc_diff >> (size - 1))) dc_diff = (dc_diff + 1) - (1 << size);
+        *bits <<= size;
+        *bits |= bs_read( bs, size );
+        *len += size;
+        return dc_diff;
+    }
+}
+
+static void motion_fr_frame( bs_transrate_t *bs, unsigned int f_code[2] )
+{
+    get_motion_delta( bs, f_code[0] );
+    get_motion_delta( bs, f_code[1] );
+}
+
+static void motion_fr_field( bs_transrate_t *bs, unsigned int f_code[2] )
+{
+    bs_copy( bs, 1);
+
+    get_motion_delta( bs, f_code[0]);
+    get_motion_delta( bs, f_code[1]);
+
+    bs_copy( bs, 1);
+
+    get_motion_delta( bs, f_code[0]);
+    get_motion_delta( bs, f_code[1]);
+}
+
+static void motion_fr_dmv( bs_transrate_t *bs, unsigned int f_code[2] )
+{
+    get_motion_delta( bs, f_code[0]);
+    get_dmv( bs );
+
+    get_motion_delta( bs, f_code[1]);
+    get_dmv( bs );
+}
+
+static void motion_fi_field( bs_transrate_t *bs, unsigned int f_code[2] )
+{
+    bs_copy( bs, 1);
+
+    get_motion_delta( bs, f_code[0]);
+    get_motion_delta( bs, f_code[1]);
+}
+
+static void motion_fi_16x8( bs_transrate_t *bs, unsigned int f_code[2] )
+{
+    bs_copy( bs, 1);
+
+    get_motion_delta( bs, f_code[0]);
+    get_motion_delta( bs, f_code[1]);
+
+    bs_copy( bs, 1);
+
+    get_motion_delta( bs, f_code[0]);
+    get_motion_delta( bs, f_code[1]);
+}
+
+static void motion_fi_dmv( bs_transrate_t *bs, unsigned int f_code[2] )
+{
+    get_motion_delta( bs, f_code[0]);
+    get_dmv( bs );
+
+    get_motion_delta( bs, f_code[1]);
+    get_dmv( bs );
+}
+
+
+#define MOTION_CALL(routine,direction)                      \
+do {                                                        \
+    if ((direction) & MACROBLOCK_MOTION_FORWARD)            \
+        routine( bs, tr->f_code[0]);                        \
+    if ((direction) & MACROBLOCK_MOTION_BACKWARD)           \
+        routine( bs, tr->f_code[1]);                        \
+} while (0)
+
+#define NEXT_MACROBLOCK                                         \
+do {                                                            \
+    tr->h_offset += 16;                                         \
+    if( tr->h_offset == tr->horizontal_size_value)              \
+    {                                                           \
+        tr->v_offset += 16;                                         \
+        if (tr->v_offset > (tr->vertical_size_value - 16)) return;      \
+        tr->h_offset = 0;                                       \
+    }                                                           \
+} while (0)
+
+static void putmbdata( transrate_t *tr, int macroblock_modes )
+{
+    bs_transrate_t *bs = &tr->bs;
+
+    bs_write( bs,
+              mbtypetab[tr->picture_coding_type-1][macroblock_modes&0x1F].code,
+              mbtypetab[tr->picture_coding_type-1][macroblock_modes&0x1F].len);
+
+    switch ( tr->picture_coding_type )
+    {
+        case I_TYPE:
+            if ((! (tr->frame_pred_frame_dct)) && (tr->picture_structure == FRAME_PICTURE))
+                bs_write( bs, macroblock_modes & DCT_TYPE_INTERLACED ? 1 : 0, 1);
+            break;
+
+        case P_TYPE:
+            if (tr->picture_structure != FRAME_PICTURE)
+            {
+                if (macroblock_modes & MACROBLOCK_MOTION_FORWARD)
+                    bs_write( bs, (macroblock_modes & MOTION_TYPE_MASK) / MOTION_TYPE_BASE, 2);
+                break;
+            }
+            else if (tr->frame_pred_frame_dct) break;
+            else
+            {
+                if (macroblock_modes & MACROBLOCK_MOTION_FORWARD)
+                    bs_write( bs, (macroblock_modes & MOTION_TYPE_MASK) / MOTION_TYPE_BASE, 2);
+                if (macroblock_modes & (MACROBLOCK_INTRA | MACROBLOCK_PATTERN))
+                    bs_write( bs, macroblock_modes & DCT_TYPE_INTERLACED ? 1 : 0, 1);
+                break;
+            }
+
+        case B_TYPE:
+            if (tr->picture_structure != FRAME_PICTURE)
+            {
+                if (! (macroblock_modes & MACROBLOCK_INTRA))
+                    bs_write( bs, (macroblock_modes & MOTION_TYPE_MASK) / MOTION_TYPE_BASE, 2);
+                break;
+            }
+            else if (tr->frame_pred_frame_dct) break;
+            else
+            {
+                if (macroblock_modes & MACROBLOCK_INTRA) goto intra;
+                bs_write( bs, (macroblock_modes & MOTION_TYPE_MASK) / MOTION_TYPE_BASE, 2);
+                if (macroblock_modes & (MACROBLOCK_INTRA | MACROBLOCK_PATTERN))
+                {
+                    intra:
+                    bs_write( bs, macroblock_modes & DCT_TYPE_INTERLACED ? 1 : 0, 1);
+                }
+                break;
+            }
+    }
+}
+
+static const uint8_t map_non_linear_mquant[113] =
+{
+    0,1,2,3,4,5,6,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,
+    16,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,
+    22,22,23,23,23,23,24,24,24,24,24,24,24,25,25,25,25,25,25,25,26,26,
+    26,26,26,26,26,26,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,29,
+    29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,31,31,31,31,31
+};
+static inline void put_quantiser( transrate_t *tr )
+{
+    bs_transrate_t *bs = &tr->bs;
+
+    bs_write( bs, tr->q_scale_type ? map_non_linear_mquant[tr->new_quantizer_scale] : tr->new_quantizer_scale >> 1, 5 );
+    tr->last_coded_scale = tr->new_quantizer_scale;
+}
+
+/* generate variable length code for macroblock_address_increment (6.3.16) */
+static inline void putaddrinc( transrate_t *tr, int addrinc )
+{
+    bs_transrate_t *bs = &tr->bs;
+
+    while ( addrinc >= 33 )
+    {
+        bs_write( bs, 0x08, 11 ); /* macroblock_escape */
+        addrinc -= 33;
+    }
+
+    bs_write( bs, addrinctab[addrinc].code, addrinctab[addrinc].len );
+}
+
+static int slice_init( transrate_t *tr,  int code )
+{
+    bs_transrate_t *bs = &tr->bs;
+    int offset;
+    const MBAtab * mba;
+
+    tr->v_offset = (code - 1) * 16;
+
+    tr->quantizer_scale = get_quantizer_scale( tr );
+    if ( tr->new_quantizer_scale < tr->quantizer_scale )
+        tr->new_quantizer_scale = scale_quant( tr, tr->qrate );
+
+    /*LOGF("************************\nstart of slice %i in %s picture. ori quant: %i new quant: %i\n", code,
+        (picture_coding_type == I_TYPE ? "I_TYPE" : (picture_coding_type == P_TYPE ? "P_TYPE" : "B_TYPE")),
+        quantizer_scale, new_quantizer_scale);*/
+
+    /* ignore intra_slice and all the extra data */
+    while (bs->i_bit_in_cache & 0x80000000)
+    {
+        bs_flush( bs, 9 );
+    }
+
+    /* decode initial macroblock address increment */
+    offset = 0;
+    for( ;; )
+    {
+        if (bs->i_bit_in_cache >= 0x08000000)
+        {
+            mba = MBA_5 + (UBITS (bs->i_bit_in_cache, 6) - 2);
+            break;
+        }
+        else if (bs->i_bit_in_cache >= 0x01800000)
+        {
+            mba = MBA_11 + (UBITS (bs->i_bit_in_cache, 12) - 24);
+            break;
+        }
+        else if( UBITS (bs->i_bit_in_cache, 12 ) == 8 )
+        {
+            /* macroblock_escape */
+            offset += 33;
+            bs_flush(bs, 11);
+        }
+        else
+        {
+            return -1;
+        }
+    }
+
+    bs_flush(bs, mba->len + 1);
+    tr->h_offset = (offset + mba->mba) << 4;
+
+    while( tr->h_offset - (int)tr->horizontal_size_value >= 0)
+    {
+        tr->h_offset -= tr->horizontal_size_value;
+        tr->v_offset += 16;
+    }
+
+    if( tr->v_offset > tr->vertical_size_value - 16 )
+    {
+        return -1;
+    }
+    return (offset + mba->mba);
+}
+
+static void mpeg2_slice( transrate_t *tr, const int code )
+{
+    bs_transrate_t *bs = &tr->bs;
+    int mba_inc;
+    int first_in_slice = 1;
+
+    if( (mba_inc = slice_init( tr, code )) < 0 )
+    {
+        return;
+    }
+
+    for( ;; )
+    {
+        const MBAtab * mba;
+        int macroblock_modes;
+        int mba_local;
+        int i;
+
+        while (unlikely(bs->i_bit_in < 24)) bs_refill( bs );
+
+        macroblock_modes = get_macroblock_modes( tr );
+        if (macroblock_modes & MACROBLOCK_QUANT)
+            tr->quantizer_scale = get_quantizer_scale( tr );
+        if (tr->new_quantizer_scale < tr->quantizer_scale)
+            tr->new_quantizer_scale = scale_quant( tr, tr->qrate );
+
+        //LOGF("blk %i : ", h_offset >> 4);
+
+        if (macroblock_modes & MACROBLOCK_INTRA)
+        {
+            RunLevel block[6][65]; // terminated by level = 0, so we need 64+1
+            RunLevel new_block[6][65]; // terminated by level = 0, so we need 64+1
+            uint32_t dc[6];
+            uint8_t  dc_len[6];
+
+            // begin saving data
+            int batb;
+            uint8_t   p_n_ow[32], *p_n_w,
+                    *p_o_ow = bs->p_ow, *p_o_w = bs->p_w;
+            uint32_t  i_n_bit_out, i_n_bit_out_cache,
+                    i_o_bit_out  = bs->i_bit_out, i_o_bit_out_cache = bs->i_bit_out_cache;
+
+            bs->i_bit_out_cache = 0; bs->i_bit_out = BITS_IN_BUF;
+            bs->p_ow = bs->p_w = p_n_ow;
+
+            //LOG("intra "); if (macroblock_modes & MACROBLOCK_QUANT) LOGF("got new quant: %i ", quantizer_scale);
+
+            if (tr->concealment_motion_vectors)
+            {
+                if (tr->picture_structure != FRAME_PICTURE)
+                {
+                    bs_copy(bs, 1); /* remove field_select */
+                }
+                /* like motion_frame, but parsing without actual motion compensation */
+                get_motion_delta(bs, tr->f_code[0][0]);
+                get_motion_delta(bs, tr->f_code[0][1]);
+
+                bs_copy(bs, 1); /* remove marker_bit */
+            }
+
+            assert(bs->p_w - bs->p_ow < 32);
+
+            p_n_w = bs->p_w;
+            i_n_bit_out = bs->i_bit_out;
+            i_n_bit_out_cache = bs->i_bit_out_cache;
+            assert(bs->p_ow == p_n_ow);
+
+            bs->i_bit_out = i_o_bit_out ;
+            bs->i_bit_out_cache = i_o_bit_out_cache;
+            bs->p_ow = p_o_ow;
+            bs->p_w = p_o_w;
+            // end saving data
+
+            if( tr->intra_vlc_format )
+            {
+                /* Luma */
+                for ( i = 0; i < 4; i++ )
+                {
+                    get_luma_dc_dct_diff( bs, dc + i, dc_len + i );
+                    get_intra_block_B15( tr, block[i] );
+                    if (tr->b_error) return;
+                }
+                /* Chroma */
+                for ( ; i < 6; i++ )
+                {
+                    get_chroma_dc_dct_diff( bs, dc + i, dc_len + i );
+                    get_intra_block_B15( tr, block[i] );
+                    if (tr->b_error) return;
+                }
+            }
+            else
+            {
+                /* Luma */
+                for ( i = 0; i < 4; i++ )
+                {
+                    get_luma_dc_dct_diff( bs, dc + i, dc_len + i );
+                    get_intra_block_B14( tr, block[i] );
+                    if (tr->b_error) return;
+                }
+                /* Chroma */
+                for ( ; i < 6; i++ )
+                {
+                    get_chroma_dc_dct_diff( bs, dc + i, dc_len + i );
+                    get_intra_block_B14( tr, block[i] );
+                    if (tr->b_error) return;
+                }
+            }
+
+            transrate_mb( tr, block, new_block, 0x3f, 1 );
+
+            if (tr->last_coded_scale == tr->new_quantizer_scale)
+                macroblock_modes &= ~MACROBLOCK_QUANT;
+
+            if ( first_in_slice )
+            {
+                put_quantiser( tr );
+                bs_write( bs, 0, 1 );
+                macroblock_modes &= ~MACROBLOCK_QUANT;
+            }
+            putaddrinc( tr, mba_inc );
+            mba_inc = 0;
+            putmbdata( tr, macroblock_modes );
+            if( macroblock_modes & MACROBLOCK_QUANT )
+            {
+                put_quantiser( tr );
+            }
+
+            // put saved motion data...
+            for (batb = 0; batb < (p_n_w - p_n_ow); batb++)
+            {
+                bs_write( bs, p_n_ow[batb], 8 );
+            }
+            bs_write( bs, i_n_bit_out_cache, BITS_IN_BUF - i_n_bit_out );
+            // end saved motion data...
+
+            for ( i = 0; i < 6; i++ )
+            {
+                bs_write( bs, *(dc + i), *(dc_len + i) );
+                putintrablk( bs, new_block[i], tr->intra_vlc_format );
+            }
+ 
+        }
+        else
+        {
+            RunLevel block[6][65]; // terminated by level = 0, so we need 64+1
+            RunLevel new_block[6][65]; // terminated by level = 0, so we need 64+1
+            int new_coded_block_pattern = 0;
+            int cbp = 0;
+
+            // begin saving data
+            int batb;
+            uint8_t   p_n_ow[32], *p_n_w,
+                    *p_o_ow = bs->p_ow, *p_o_w = bs->p_w;
+            uint32_t  i_n_bit_out, i_n_bit_out_cache,
+                    i_o_bit_out  = bs->i_bit_out, i_o_bit_out_cache = bs->i_bit_out_cache;
+
+            bs->i_bit_out_cache = 0; bs->i_bit_out = BITS_IN_BUF;
+            bs->p_ow = bs->p_w = p_n_ow;
+
+            if (tr->picture_structure == FRAME_PICTURE)
+                switch (macroblock_modes & MOTION_TYPE_MASK)
+                {
+                    case MC_FRAME: MOTION_CALL (motion_fr_frame, macroblock_modes); break;
+                    case MC_FIELD: MOTION_CALL (motion_fr_field, macroblock_modes); break;
+                    case MC_DMV: MOTION_CALL (motion_fr_dmv, MACROBLOCK_MOTION_FORWARD); break;
+                }
+            else
+                switch (macroblock_modes & MOTION_TYPE_MASK)
+                {
+                    case MC_FIELD: MOTION_CALL (motion_fi_field, macroblock_modes); break;
+                    case MC_16X8: MOTION_CALL (motion_fi_16x8, macroblock_modes); break;
+                    case MC_DMV: MOTION_CALL (motion_fi_dmv, MACROBLOCK_MOTION_FORWARD); break;
+                }
+
+            //LOG("non intra "); if (macroblock_modes & MACROBLOCK_QUANT) LOGF("got new quant: %i ", quantizer_scale);
+
+            if (macroblock_modes & MACROBLOCK_PATTERN)
+            {
+                int last_in_slice;
+
+                cbp = get_coded_block_pattern( bs );
+
+                for ( i = 0; i < 6; i++ )
+                {
+                    if ( cbp & (1 << (5 - i)) )
+                    {
+                        get_non_intra_block( tr, block[i] );
+                        if (tr->b_error) return;
+                    }
+                }
+                last_in_slice = !UBITS( bs->i_bit_in_cache, 11 );
+
+                new_coded_block_pattern = transrate_mb( tr, block, new_block,
+                                                        cbp, 0 );
+
+                if ( !new_coded_block_pattern &&
+                        !(macroblock_modes
+                            & (MACROBLOCK_MOTION_FORWARD
+                                | MACROBLOCK_MOTION_BACKWARD))
+                        && (first_in_slice || last_in_slice) )
+                {
+                    /* First mb in slice, just code a 0-mv mb.
+                     * This is wrong for last in slice, but it only shows
+                     * a few artefacts. */
+                    macroblock_modes |= MACROBLOCK_MOTION_FORWARD;
+                    if (tr->picture_structure == FRAME_PICTURE)
+                    {
+                        macroblock_modes |= MC_FRAME;
+                        bs_write( bs, 0x3, 2 ); /* motion vectors */
+                    }
+                    else
+                    {
+                        macroblock_modes |= MC_FIELD;
+                        bs_write( bs,
+                             (tr->picture_structure == BOTTOM_FIELD ? 1 : 0),
+                             1); /* motion field select */
+                        bs_write( bs, 0x3, 2 ); /* motion vectors */
+                    }
+                }
+
+                if ( !new_coded_block_pattern )
+                {
+                    macroblock_modes &= ~MACROBLOCK_PATTERN;
+                    macroblock_modes &= ~MACROBLOCK_QUANT;
+                }
+                else
+                {
+                    if ( tr->last_coded_scale == tr->new_quantizer_scale )
+                    {
+                        macroblock_modes &= ~MACROBLOCK_QUANT;
+                    }
+                    else
+                    {
+                        macroblock_modes |= MACROBLOCK_QUANT;
+                    }
+                }
+            }
+
+            assert(bs->p_w - bs->p_ow < 32);
+
+            p_n_w = bs->p_w;
+            i_n_bit_out = bs->i_bit_out;
+            i_n_bit_out_cache = bs->i_bit_out_cache;
+            assert(bs->p_ow == p_n_ow);
+
+            bs->i_bit_out = i_o_bit_out ;
+            bs->i_bit_out_cache = i_o_bit_out_cache;
+            bs->p_ow = p_o_ow;
+            bs->p_w = p_o_w;
+            // end saving data
+
+            if ( macroblock_modes &
+                    (MACROBLOCK_MOTION_FORWARD | MACROBLOCK_MOTION_BACKWARD
+                      | MACROBLOCK_PATTERN) )
+            {
+                if ( first_in_slice )
+                {
+                    put_quantiser( tr );
+                    bs_write( bs, 0, 1 );
+                    macroblock_modes &= ~MACROBLOCK_QUANT;
+                }
+                putaddrinc( tr, mba_inc );
+                mba_inc = 0;
+                putmbdata( tr, macroblock_modes );
+                if ( macroblock_modes & MACROBLOCK_QUANT )
+                {
+                    put_quantiser( tr );
+                }
+
+                // put saved motion data...
+                for (batb = 0; batb < (p_n_w - p_n_ow); batb++)
+                {
+                    bs_write( bs, p_n_ow[batb], 8 );
+                }
+                bs_write( bs, i_n_bit_out_cache, BITS_IN_BUF - i_n_bit_out);
+                // end saved motion data...
+
+                if (macroblock_modes & MACROBLOCK_PATTERN)
+                {
+                    /* Write CBP */
+                    bs_write( bs, cbptable[new_coded_block_pattern].code,
+                              cbptable[new_coded_block_pattern].len );
+
+                    for ( i = 0; i < 6; i++ )
+                    {
+                        if ( new_coded_block_pattern & (1 << (5 - i)) )
+                        {
+                            putnonintrablk( bs, new_block[i] );
+                        }
+                    }
+                }
+            }
+            else
+            {
+                /* skipped macroblock */
+                mba_inc++;
+            }
+        }
+
+        if (bs->p_c > bs->p_r || bs->p_w > bs->p_rw)
+        {
+            tr->b_error = 1;
+            return;
+        }
+        //LOGF("\n\to: %i c: %i n: %i\n", quantizer_scale, last_coded_scale, new_quantizer_scale);
+
+        NEXT_MACROBLOCK;
+
+        first_in_slice = 0;
+        mba_local = 0;
+        for ( ; ; )
+        {
+            if ( bs->i_bit_in_cache >= 0x10000000 )
+            {
+                mba = MBA_5 + (UBITS (bs->i_bit_in_cache, 5) - 2);
+                break;
+            }
+            else if ( bs->i_bit_in_cache >= 0x03000000 )
+            {
+                mba = MBA_11 + (UBITS (bs->i_bit_in_cache, 11) - 24);
+                break;
+            }
+            else if ( UBITS( bs->i_bit_in_cache, 11 ) == 8 )
+            {
+                /* macroblock_escape */
+                mba_inc += 33;
+                mba_local += 33;
+                bs_flush(bs, 11);
+            }
+            else
+            {
+                /* EOS or error */
+                return;
+            }
+        }
+        bs_flush(bs, mba->len);
+        mba_inc += mba->mba;
+        mba_local += mba->mba;
+
+        while( mba_local-- )
+        {
+            NEXT_MACROBLOCK;
+        }
+    }
+}
+
+static const uint8_t mpeg2_scan_norm[64] ATTR_ALIGN(16) = {
+    /* Zig-Zag scan pattern */
+     0,  1,  8, 16,  9,  2,  3, 10, 17, 24, 32, 25, 18, 11,  4,  5,
+    12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13,  6,  7, 14, 21, 28,
+    35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51,
+    58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63
+};
+
+static const uint8_t mpeg2_scan_alt[64] ATTR_ALIGN(16) = {
+    /* Alternate scan pattern */
+     0, 8,  16, 24,  1,  9,  2, 10, 17, 25, 32, 40, 48, 56, 57, 49,
+    41, 33, 26, 18,  3, 11,  4, 12, 19, 27, 34, 42, 50, 58, 35, 43,
+    51, 59, 20, 28,  5, 13,  6, 14, 21, 29, 36, 44, 52, 60, 37, 45,
+    53, 61, 22, 30,  7, 15, 23, 31, 38, 46, 54, 62, 39, 47, 55, 63
+};
+
+static const int16_t default_intra_matrix[64] = {
+        8, 16, 19, 22, 26, 27, 29, 34,
+        16, 16, 22, 24, 27, 29, 34, 37,
+        19, 22, 26, 27, 29, 34, 34, 38,
+        22, 22, 26, 27, 29, 34, 37, 40,
+        22, 26, 27, 29, 32, 35, 40, 48,
+        26, 27, 29, 32, 35, 40, 48, 58,
+        26, 27, 29, 34, 38, 46, 56, 69,
+        27, 29, 35, 38, 46, 56, 69, 83
+};
+
+static int mpeg2_header_sequence( transrate_t * tr )
+{
+    bs_transrate_t *bs = &tr->bs;
+    int has_intra = 0, has_non_intra = 0;
+    int i;
+
+    i = (bs->p_c[0] << 16) | (bs->p_c[1] << 8) | bs->p_c[2];
+    tr->horizontal_size_value = i >> 12;
+    tr->vertical_size_value = i & 0xfff;
+    tr->horizontal_size_value = (tr->horizontal_size_value + 15) & ~15;
+    tr->vertical_size_value = (tr->vertical_size_value + 15) & ~15;
+    if ( !tr->horizontal_size_value || !tr->vertical_size_value )
+    {
+        return -1;
+    }
+
+    if ( tr->mpeg4_matrix )
+    {
+        if (bs->p_c[7] & 2)
+        {
+            has_intra = 1;
+            for (i = 0; i < 64; i++)
+                tr->intra_quantizer_matrix[mpeg2_scan_norm[i]] =
+                (bs->p_c[i+7] << 7) | (bs->p_c[i+8] >> 1);
+        }
+        else
+        {
+            for (i = 0; i < 64; i++)
+                tr->intra_quantizer_matrix[mpeg2_scan_norm[i]] =
+                default_intra_matrix[i];
+        }
+
+        if (bs->p_c[7+64] & 1)
+        {
+            has_non_intra = 1;
+            for (i = 0; i < 64; i++)
+                tr->non_intra_quantizer_matrix[mpeg2_scan_norm[i]] =
+                bs->p_c[i+8+64];
+        }
+        else
+        {
+            for (i = 0; i < 64; i++)
+                tr->non_intra_quantizer_matrix[i] = 16;
+        }
+    }
+
+    /* Write quantization matrices */
+    memcpy( bs->p_w, bs->p_c, 8 );
+    bs->p_c += 8;
+
+    if ( tr->mpeg4_matrix )
+    {
+        memset( &bs->p_w[8], 0, 128 );
+        bs->p_w[7] |= 2;
+        bs->p_w[7] &= ~1;
+        for (i = 0; i < 64; i++)
+        {
+            bs->p_w[i+7] |= mpeg4_default_intra_matrix[mpeg2_scan_norm[i]] >> 7;
+            bs->p_w[i+8] |= mpeg4_default_intra_matrix[mpeg2_scan_norm[i]] << 1;
+        }
+
+        bs->p_w[7+64] |= 1;
+        for (i = 0; i < 64; i++)
+        {
+            bs->p_w[i+8+64] |= mpeg4_default_intra_matrix[mpeg2_scan_norm[i]];
+        }
+        bs->p_w += 8 + 128;
+        bs->p_c += (has_intra + has_non_intra) * 64;
+    }
+    else
+    {
+        bs->p_w += 8;
+    }
+
+    tr->scan = mpeg2_scan_norm;
+
+    return 0;
+}
+
+/////---- end ext mpeg code
+
+static int do_next_start_code( transrate_t *tr )
+{
+    bs_transrate_t *bs = &tr->bs;
+    uint8_t ID;
+
+    // get start code
+    ID = bs->p_c[0];
+
+    /* Copy one byte */
+    *bs->p_w++ = *bs->p_c++;
+
+    if (ID == 0x00) // pic header
+    {
+        tr->picture_coding_type = (bs->p_c[1] >> 3) & 0x7;
+        bs->p_c[1] |= 0x7; bs->p_c[2] = 0xFF; bs->p_c[3] |= 0xF8; // vbv_delay is now 0xFFFF
+
+        memcpy(bs->p_w, bs->p_c, 4);
+        bs->p_c += 4;
+        bs->p_w += 4;
+    }
+    else if (ID == 0xB3) // seq header
+    {
+        mpeg2_header_sequence(tr);
+    }
+    else if (ID == 0xB5) // extension
+    {
+        if ((bs->p_c[0] >> 4) == 0x8) // pic coding ext
+        {
+            tr->f_code[0][0] = (bs->p_c[0] & 0xF) - 1;
+            tr->f_code[0][1] = (bs->p_c[1] >> 4) - 1;
+            tr->f_code[1][0] = (bs->p_c[1] & 0xF) - 1;
+            tr->f_code[1][1] = (bs->p_c[2] >> 4) - 1;
+
+            /* tr->intra_dc_precision = (bs->p_c[2] >> 2) & 0x3; */
+            tr->picture_structure = bs->p_c[2] & 0x3;
+            tr->frame_pred_frame_dct = (bs->p_c[3] >> 6) & 0x1;
+            tr->concealment_motion_vectors = (bs->p_c[3] >> 5) & 0x1;
+            tr->q_scale_type = (bs->p_c[3] >> 4) & 0x1;
+            tr->intra_vlc_format = (bs->p_c[3] >> 3) & 0x1;
+            if ( (bs->p_c[3] >> 2) & 0x1 )
+                tr->scan = mpeg2_scan_alt;
+
+            memcpy(bs->p_w, bs->p_c, 5);
+            bs->p_c += 5;
+            bs->p_w += 5;
+        }
+        else
+        {
+            *bs->p_w++ = *bs->p_c++;
+        }
+    }
+    else if (ID == 0xB8) // gop header
+    {
+        memcpy(bs->p_w, bs->p_c, 4);
+        bs->p_c += 4;
+        bs->p_w += 4;
+    }
+    else if ((ID >= 0x01) && (ID <= 0xAF)) // slice
+    {
+        uint8_t *outTemp = bs->p_w, *inTemp = bs->p_c;
+
+        if( tr->qrate != 1.0 )
+        {
+            if( !tr->horizontal_size_value || !tr->vertical_size_value )
+            {
+                return -1;
+            }
+
+            // init bit buffer
+            bs->i_bit_in_cache = 0; bs->i_bit_in = 0;
+            bs->i_bit_out_cache = 0; bs->i_bit_out = BITS_IN_BUF;
+
+            // get 32 bits
+            bs_refill( bs );
+            bs_refill( bs );
+            bs_refill( bs );
+            bs_refill( bs );
+
+            // begin bit level recoding
+            mpeg2_slice(tr, ID);
+            if (tr->b_error) return -1;
+
+            bs_flush_read( bs );
+            bs_flush_write( bs );
+            // end bit level recoding
+
+            /* Basic sanity checks --Meuuh */
+            if (bs->p_c > bs->p_r || bs->p_w > bs->p_rw)
+            {
+                return -1;
+            }
+
+            /*LOGF("type: %s code: %02i in : %6i out : %6i diff : %6i fact: %2.2f\n",
+            (picture_coding_type == I_TYPE ? "I_TYPE" : (picture_coding_type == P_TYPE ? "P_TYPE" : "B_TYPE")),
+            ID,  bs->p_c - inTemp, bs->p_w - outTemp, (bs->p_w - outTemp) - (bs->p_c - inTemp), (float)(bs->p_c - inTemp) / (float)(bs->p_w - outTemp));*/
+
+            if (bs->p_w - outTemp > bs->p_c - inTemp) // yes that might happen, rarely
+            {
+
+                /*LOGF("*** slice bigger than before !! (type: %s code: %i in : %i out : %i diff : %i)\n",
+                (picture_coding_type == I_TYPE ? "I_TYPE" : (picture_coding_type == P_TYPE ? "P_TYPE" : "B_TYPE")),
+                ID, bs->p_c - inTemp, bs->p_w - outTemp, (bs->p_w - outTemp) - (bs->p_c - inTemp));*/
+
+                if ( !tr->mpeg4_matrix )
+                {
+                    // in this case, we'll just use the original slice !
+                    memcpy(outTemp, inTemp, bs->p_c - inTemp);
+                    bs->p_w = outTemp + (bs->p_c - inTemp);
+
+                    // adjust bs->i_byte_out
+                    bs->i_byte_out -= (bs->p_w - outTemp) - (bs->p_c - inTemp);
+                }
+                else
+                {
+                    fprintf(stderr, "bad choice for mpeg4-matrix...\n");
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+int process_frame( sout_stream_t *p_stream, sout_stream_id_t *id,
+                   block_t *in, block_t **out, int i_handicap )
+{
+    transrate_t *tr = &id->tr;
+    bs_transrate_t *bs = &tr->bs;
+
+    block_t       *p_out;
+
+    double        f_drift, f_fact;
+    int           i_drift;
+
+    p_out = block_New( p_stream, in->i_buffer * 3 );
+
+    p_out->i_length = in->i_length;
+    p_out->i_dts    = in->i_dts;
+    p_out->i_pts    = in->i_pts;
+    p_out->i_flags  = in->i_flags;
+
+    bs->p_rw = bs->p_ow = bs->p_w = p_out->p_buffer;
+    bs->p_c = bs->p_r = in->p_buffer;
+    bs->p_r += in->i_buffer + 4;
+    bs->p_rw += in->i_buffer * 2;
+    *(in->p_buffer + in->i_buffer) = 0;
+    *(in->p_buffer + in->i_buffer + 1) = 0;
+    *(in->p_buffer + in->i_buffer + 2) = 1;
+    *(in->p_buffer + in->i_buffer + 3) = 0;
+
+    /* Calculate how late we are */
+    bs->i_byte_in = in->i_buffer;
+    bs->i_byte_out  = 0;
+
+    i_drift = tr->i_current_output + tr->i_remaining_input
+                - tr->i_wanted_output;
+    f_drift = (double)i_drift / tr->i_wanted_output;
+    f_fact = (double)(tr->i_wanted_output - tr->i_current_output)
+                    / tr->i_remaining_input;
+
+    if ( in->i_flags & BLOCK_FLAG_TYPE_I )
+    {
+        /* This is the last picture of the GOP ; only transrate if we're
+         * very late. */
+        if ( 0 && f_drift > 0.085 )
+        {
+            tr->i_minimum_error = (f_drift - 0.085) * 50.0 * 50.0;
+            tr->i_admissible_error = (f_drift - 0.085) * 50.0 * 75.0;
+            tr->qrate = 1.0 + (f_drift - 0.085) * 50.0;
+            msg_Warn( p_stream, "transrating I %d/%d",
+                      tr->i_minimum_error, tr->i_admissible_error );
+        }
+        else
+        {
+            tr->i_minimum_error = 0;
+            tr->i_admissible_error = 0;
+            tr->qrate = 1.0;
+        }
+    }
+    else if ( in->i_flags & BLOCK_FLAG_TYPE_P )
+    {
+        if ( f_fact < 0.8 )
+        {
+            tr->i_minimum_error = (0.8 - f_fact) * 3000.0 + i_handicap;
+            tr->i_admissible_error = (0.8 - f_fact) * 3500.0 + i_handicap;
+            tr->qrate = 1.0 + (0.8 - f_fact) * 70.0;
+        }
+        else
+        {
+            tr->i_minimum_error = 0;
+            tr->i_admissible_error = 0;
+            tr->qrate = 1.0;
+        }
+    }
+    else
+    {
+        if ( f_fact < 1.2 )
+        {
+            tr->i_minimum_error = (1.2 - f_fact) * 1750.0 + i_handicap;
+            tr->i_admissible_error = (1.2 - f_fact) * 2250.0 + i_handicap;
+            tr->qrate = 1.0 + (1.2 - f_fact) * 45.0;
+        }
+        else
+        {
+            tr->i_minimum_error = 0;
+            tr->i_admissible_error = 0;
+            tr->qrate = 1.0;
+        }
+    }
+
+    tr->new_quantizer_scale = 0;
+    tr->b_error = 0;
+
+    for ( ; ; )
+    {
+        uint8_t *p_end = &in->p_buffer[in->i_buffer];
+
+        /* Search next start code */
+        for( ;; )
+        {
+            if( bs->p_c < p_end - 3 && bs->p_c[0] == 0 && bs->p_c[1] == 0 && bs->p_c[2] == 1 )
+            {
+                /* Next start code */
+                break;
+            }
+            else if( bs->p_c < p_end - 6 &&
+                     bs->p_c[0] == 0 && bs->p_c[1] == 0 && bs->p_c[2] == 0 &&
+                     bs->p_c[3] == 0 && bs->p_c[4] == 0 && bs->p_c[5] == 0 )
+            {
+                /* remove stuffing (looking for 6 0x00 bytes) */
+                bs->p_c++;
+            }
+            else
+            {
+                /* Copy */
+                *bs->p_w++ = *bs->p_c++;
+            }
+
+            if( bs->p_c >= p_end )
+            {
+                break;
+            }
+        }
+
+        if( bs->p_c >= p_end )
+        {
+            break;
+        }
+
+        /* Copy the start code */
+        memcpy( bs->p_w, bs->p_c, 3 );
+        bs->p_c += 3;
+        bs->p_w += 3;
+
+        if ( do_next_start_code( tr ) )
+        {
+            /* Error */
+            msg_Err( p_stream, "error in do_next_start_code()" );
+            block_Release( p_out );
+            tr->i_remaining_input -= in->i_buffer;
+            tr->i_current_output += in->i_buffer;
+            return -1;
+        }
+    }
+
+    bs->i_byte_out += bs->p_w - bs->p_ow;
+    p_out->i_buffer = bs->p_w - bs->p_ow;
+
+#if 0
+    if ( in->i_flags & BLOCK_FLAG_TYPE_P && f_fact < 0.8 )
+    {
+        double f_ratio = (in->i_buffer - p_out->i_buffer) / in->i_buffer;
+        if ( f_ratio < (0.8 - f_fact) * 0.1 && i_handicap < 200 )
+        {
+            block_Release( p_out );
+            return process_frame( p_stream, id, in, out, i_handicap + 50 );
+        }
+    }
+
+    if ( in->i_flags & BLOCK_FLAG_TYPE_B && f_fact < 1.1 )
+    {
+        double f_ratio = (double)(in->i_buffer - p_out->i_buffer)
+                            / in->i_buffer;
+        if ( f_ratio < (1.1 - f_fact) * 0.1 && i_handicap < 400 )
+        {
+#ifdef DEBUG_TRANSRATER
+            msg_Dbg( p_stream, "%d: %d -> %d big (f: %f d: %f)",
+                     tr->picture_coding_type, in->i_buffer, p_out->i_buffer,
+                     f_fact, f_drift);
+#endif
+            block_Release( p_out );
+            return process_frame( p_stream, id, in, out, i_handicap + 100 );
+        }
+    }
+#endif
+
+#if 0
+    {
+        int toto;
+        for ( toto = 0; toto < p_out->i_buffer; toto++ )
+            if (in->p_buffer[toto] != p_out->p_buffer[toto])
+                msg_Dbg(p_stream, "toto %d %x %x", toto, in->p_buffer[toto], p_out->p_buffer[toto]);
+    }
+#endif
+
+    block_ChainAppend( out, p_out );
+    tr->i_remaining_input -= in->i_buffer;
+    tr->i_current_output += p_out->i_buffer;
+
+#ifdef DEBUG_TRANSRATER
+    msg_Dbg( p_stream, "%d: %d -> %d (%d/%d)",
+             tr->picture_coding_type, in->i_buffer, p_out->i_buffer,
+             tr->i_minimum_error, tr->i_admissible_error );
+#endif
+
+    return 0;
+}
+
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/stream_out/transrate/getvlc.h ./modules/stream_out/transrate/getvlc.h
--- /arno/build/vlc-1.0.5/modules/stream_out/transrate/getvlc.h	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/stream_out/transrate/getvlc.h	2010-02-26 14:52:41.000000000 +0100
@@ -0,0 +1,398 @@
+
+/* macroblock modes */
+#define MACROBLOCK_INTRA 1
+#define MACROBLOCK_PATTERN 2
+#define MACROBLOCK_MOTION_BACKWARD 4
+#define MACROBLOCK_MOTION_FORWARD 8
+#define MACROBLOCK_QUANT 16
+#define DCT_TYPE_INTERLACED 32
+
+/* motion_type */
+#define MOTION_TYPE_MASK (3*64)
+#define MOTION_TYPE_BASE 64
+#define MC_FIELD (1*64)
+#define MC_FRAME (2*64)
+#define MC_16X8 (2*64)
+#define MC_DMV (3*64)
+
+/* picture structure */
+#define TOP_FIELD 1
+#define BOTTOM_FIELD 2
+#define FRAME_PICTURE 3
+
+/* take num bits from the high part of bit_buf and zero extend them */
+#define UBITS(bit_buf,num) (((uint32_t)(bs->i_bit_in_cache)) >> (32 - (num)))
+
+/* take num bits from the high part of bit_buf and sign extend them */
+#define SBITS(bit_buf,num) (((int32_t)(bs->i_bit_in_cache)) >> (32 - (num)))
+
+typedef struct {
+    uint8_t modes;
+    uint8_t len;
+} MBtab;
+
+typedef struct {
+    uint8_t delta;
+    uint8_t len;
+} MVtab;
+
+typedef struct {
+    int8_t dmv;
+    uint8_t len;
+} DMVtab;
+
+typedef struct {
+    uint8_t cbp;
+    uint8_t len;
+} CBPtab;
+
+typedef struct {
+    uint8_t size;
+    uint8_t len;
+} DCtab;
+
+typedef struct {
+    uint8_t run;
+    uint8_t level;
+    uint8_t len;
+} DCTtab;
+
+typedef struct {
+    uint8_t mba;
+    uint8_t len;
+} MBAtab;
+
+
+#define INTRA MACROBLOCK_INTRA
+#define QUANT MACROBLOCK_QUANT
+
+static const MBtab MB_I [] = {
+    {INTRA|QUANT, 2}, {INTRA, 1}
+};
+
+#define MC MACROBLOCK_MOTION_FORWARD
+#define CODED MACROBLOCK_PATTERN
+
+static const MBtab MB_P [] = {
+    {INTRA|QUANT, 6}, {CODED|QUANT, 5}, {MC|CODED|QUANT, 5}, {INTRA,    5},
+    {MC,          3}, {MC,          3}, {MC,             3}, {MC,       3},
+    {CODED,       2}, {CODED,       2}, {CODED,          2}, {CODED,    2},
+    {CODED,       2}, {CODED,       2}, {CODED,          2}, {CODED,    2},
+    {MC|CODED,    1}, {MC|CODED,    1}, {MC|CODED,       1}, {MC|CODED, 1},
+    {MC|CODED,    1}, {MC|CODED,    1}, {MC|CODED,       1}, {MC|CODED, 1},
+    {MC|CODED,    1}, {MC|CODED,    1}, {MC|CODED,       1}, {MC|CODED, 1},
+    {MC|CODED,    1}, {MC|CODED,    1}, {MC|CODED,       1}, {MC|CODED, 1}
+};
+
+#define FWD MACROBLOCK_MOTION_FORWARD
+#define BWD MACROBLOCK_MOTION_BACKWARD
+#define INTER MACROBLOCK_MOTION_FORWARD|MACROBLOCK_MOTION_BACKWARD
+
+static const MBtab MB_B [] = {
+    {0,                 0}, {INTRA|QUANT,       6},
+    {BWD|CODED|QUANT,   6}, {FWD|CODED|QUANT,   6},
+    {INTER|CODED|QUANT, 5}, {INTER|CODED|QUANT, 5},
+                                        {INTRA,       5}, {INTRA,       5},
+    {FWD,         4}, {FWD,         4}, {FWD,         4}, {FWD,         4},
+    {FWD|CODED,   4}, {FWD|CODED,   4}, {FWD|CODED,   4}, {FWD|CODED,   4},
+    {BWD,         3}, {BWD,         3}, {BWD,         3}, {BWD,         3},
+    {BWD,         3}, {BWD,         3}, {BWD,         3}, {BWD,         3},
+    {BWD|CODED,   3}, {BWD|CODED,   3}, {BWD|CODED,   3}, {BWD|CODED,   3},
+    {BWD|CODED,   3}, {BWD|CODED,   3}, {BWD|CODED,   3}, {BWD|CODED,   3},
+    {INTER,       2}, {INTER,       2}, {INTER,       2}, {INTER,       2},
+    {INTER,       2}, {INTER,       2}, {INTER,       2}, {INTER,       2},
+    {INTER,       2}, {INTER,       2}, {INTER,       2}, {INTER,       2},
+    {INTER,       2}, {INTER,       2}, {INTER,       2}, {INTER,       2},
+    {INTER|CODED, 2}, {INTER|CODED, 2}, {INTER|CODED, 2}, {INTER|CODED, 2},
+    {INTER|CODED, 2}, {INTER|CODED, 2}, {INTER|CODED, 2}, {INTER|CODED, 2},
+    {INTER|CODED, 2}, {INTER|CODED, 2}, {INTER|CODED, 2}, {INTER|CODED, 2},
+    {INTER|CODED, 2}, {INTER|CODED, 2}, {INTER|CODED, 2}, {INTER|CODED, 2}
+};
+
+#undef INTRA
+#undef QUANT
+#undef MC
+#undef CODED
+#undef FWD
+#undef BWD
+#undef INTER
+
+
+static const MVtab MV_4 [] = {
+    { 3, 6}, { 2, 4}, { 1, 3}, { 1, 3}, { 0, 2}, { 0, 2}, { 0, 2}, { 0, 2}
+};
+
+static const MVtab MV_10 [] = {
+    { 0,10}, { 0,10}, { 0,10}, { 0,10}, { 0,10}, { 0,10}, { 0,10}, { 0,10},
+    { 0,10}, { 0,10}, { 0,10}, { 0,10}, {15,10}, {14,10}, {13,10}, {12,10},
+    {11,10}, {10,10}, { 9, 9}, { 9, 9}, { 8, 9}, { 8, 9}, { 7, 9}, { 7, 9},
+    { 6, 7}, { 6, 7}, { 6, 7}, { 6, 7}, { 6, 7}, { 6, 7}, { 6, 7}, { 6, 7},
+    { 5, 7}, { 5, 7}, { 5, 7}, { 5, 7}, { 5, 7}, { 5, 7}, { 5, 7}, { 5, 7},
+    { 4, 7}, { 4, 7}, { 4, 7}, { 4, 7}, { 4, 7}, { 4, 7}, { 4, 7}, { 4, 7}
+};
+
+
+static const DMVtab DMV_2 [] = {
+    { 0, 1}, { 0, 1}, { 1, 2}, {-1, 2}
+};
+
+
+static const CBPtab CBP_7 [] = {
+    {0x22, 7}, {0x12, 7}, {0x0a, 7}, {0x06, 7},
+    {0x21, 7}, {0x11, 7}, {0x09, 7}, {0x05, 7},
+    {0x3f, 6}, {0x3f, 6}, {0x03, 6}, {0x03, 6},
+    {0x24, 6}, {0x24, 6}, {0x18, 6}, {0x18, 6},
+    {0x3e, 5}, {0x3e, 5}, {0x3e, 5}, {0x3e, 5},
+    {0x02, 5}, {0x02, 5}, {0x02, 5}, {0x02, 5},
+    {0x3d, 5}, {0x3d, 5}, {0x3d, 5}, {0x3d, 5},
+    {0x01, 5}, {0x01, 5}, {0x01, 5}, {0x01, 5},
+    {0x38, 5}, {0x38, 5}, {0x38, 5}, {0x38, 5},
+    {0x34, 5}, {0x34, 5}, {0x34, 5}, {0x34, 5},
+    {0x2c, 5}, {0x2c, 5}, {0x2c, 5}, {0x2c, 5},
+    {0x1c, 5}, {0x1c, 5}, {0x1c, 5}, {0x1c, 5},
+    {0x28, 5}, {0x28, 5}, {0x28, 5}, {0x28, 5},
+    {0x14, 5}, {0x14, 5}, {0x14, 5}, {0x14, 5},
+    {0x30, 5}, {0x30, 5}, {0x30, 5}, {0x30, 5},
+    {0x0c, 5}, {0x0c, 5}, {0x0c, 5}, {0x0c, 5},
+    {0x20, 4}, {0x20, 4}, {0x20, 4}, {0x20, 4},
+    {0x20, 4}, {0x20, 4}, {0x20, 4}, {0x20, 4},
+    {0x10, 4}, {0x10, 4}, {0x10, 4}, {0x10, 4},
+    {0x10, 4}, {0x10, 4}, {0x10, 4}, {0x10, 4},
+    {0x08, 4}, {0x08, 4}, {0x08, 4}, {0x08, 4},
+    {0x08, 4}, {0x08, 4}, {0x08, 4}, {0x08, 4},
+    {0x04, 4}, {0x04, 4}, {0x04, 4}, {0x04, 4},
+    {0x04, 4}, {0x04, 4}, {0x04, 4}, {0x04, 4},
+    {0x3c, 3}, {0x3c, 3}, {0x3c, 3}, {0x3c, 3},
+    {0x3c, 3}, {0x3c, 3}, {0x3c, 3}, {0x3c, 3},
+    {0x3c, 3}, {0x3c, 3}, {0x3c, 3}, {0x3c, 3},
+    {0x3c, 3}, {0x3c, 3}, {0x3c, 3}, {0x3c, 3}
+};
+
+static const CBPtab CBP_9 [] = {
+    {0,    0}, {0x00, 9}, {0x27, 9}, {0x1b, 9},
+    {0x3b, 9}, {0x37, 9}, {0x2f, 9}, {0x1f, 9},
+    {0x3a, 8}, {0x3a, 8}, {0x36, 8}, {0x36, 8},
+    {0x2e, 8}, {0x2e, 8}, {0x1e, 8}, {0x1e, 8},
+    {0x39, 8}, {0x39, 8}, {0x35, 8}, {0x35, 8},
+    {0x2d, 8}, {0x2d, 8}, {0x1d, 8}, {0x1d, 8},
+    {0x26, 8}, {0x26, 8}, {0x1a, 8}, {0x1a, 8},
+    {0x25, 8}, {0x25, 8}, {0x19, 8}, {0x19, 8},
+    {0x2b, 8}, {0x2b, 8}, {0x17, 8}, {0x17, 8},
+    {0x33, 8}, {0x33, 8}, {0x0f, 8}, {0x0f, 8},
+    {0x2a, 8}, {0x2a, 8}, {0x16, 8}, {0x16, 8},
+    {0x32, 8}, {0x32, 8}, {0x0e, 8}, {0x0e, 8},
+    {0x29, 8}, {0x29, 8}, {0x15, 8}, {0x15, 8},
+    {0x31, 8}, {0x31, 8}, {0x0d, 8}, {0x0d, 8},
+    {0x23, 8}, {0x23, 8}, {0x13, 8}, {0x13, 8},
+    {0x0b, 8}, {0x0b, 8}, {0x07, 8}, {0x07, 8}
+};
+
+
+static const DCtab DC_lum_5 [] = {
+    {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2},
+    {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2},
+    {0, 3}, {0, 3}, {0, 3}, {0, 3}, {3, 3}, {3, 3}, {3, 3}, {3, 3},
+    {4, 3}, {4, 3}, {4, 3}, {4, 3}, {5, 4}, {5, 4}, {6, 5}
+};
+
+static const DCtab DC_chrom_5 [] = {
+    {0, 2}, {0, 2}, {0, 2}, {0, 2}, {0, 2}, {0, 2}, {0, 2}, {0, 2},
+    {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2}, {1, 2},
+    {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2}, {2, 2},
+    {3, 3}, {3, 3}, {3, 3}, {3, 3}, {4, 4}, {4, 4}, {5, 5}
+};
+
+static const DCtab DC_long [] = {
+    {6, 5}, {6, 5}, {6, 5}, {6, 5}, {6, 5}, {6, 5}, { 6, 5}, { 6, 5},
+    {6, 5}, {6, 5}, {6, 5}, {6, 5}, {6, 5}, {6, 5}, { 6, 5}, { 6, 5},
+    {7, 6}, {7, 6}, {7, 6}, {7, 6}, {7, 6}, {7, 6}, { 7, 6}, { 7, 6},
+    {8, 7}, {8, 7}, {8, 7}, {8, 7}, {9, 8}, {9, 8}, {10, 9}, {11, 9}
+};
+
+
+static const DCTtab DCT_16 [] = {
+    {129, 0, 0}, {129, 0, 0}, {129, 0, 0}, {129, 0, 0},
+    {129, 0, 0}, {129, 0, 0}, {129, 0, 0}, {129, 0, 0},
+    {129, 0, 0}, {129, 0, 0}, {129, 0, 0}, {129, 0, 0},
+    {129, 0, 0}, {129, 0, 0}, {129, 0, 0}, {129, 0, 0},
+    {  2,18, 0}, {  2,17, 0}, {  2,16, 0}, {  2,15, 0},
+    {  7, 3, 0}, { 17, 2, 0}, { 16, 2, 0}, { 15, 2, 0},
+    { 14, 2, 0}, { 13, 2, 0}, { 12, 2, 0}, { 32, 1, 0},
+    { 31, 1, 0}, { 30, 1, 0}, { 29, 1, 0}, { 28, 1, 0}
+};
+
+static const DCTtab DCT_15 [] = {
+    {  1,40,15}, {  1,39,15}, {  1,38,15}, {  1,37,15},
+    {  1,36,15}, {  1,35,15}, {  1,34,15}, {  1,33,15},
+    {  1,32,15}, {  2,14,15}, {  2,13,15}, {  2,12,15},
+    {  2,11,15}, {  2,10,15}, {  2, 9,15}, {  2, 8,15},
+    {  1,31,14}, {  1,31,14}, {  1,30,14}, {  1,30,14},
+    {  1,29,14}, {  1,29,14}, {  1,28,14}, {  1,28,14},
+    {  1,27,14}, {  1,27,14}, {  1,26,14}, {  1,26,14},
+    {  1,25,14}, {  1,25,14}, {  1,24,14}, {  1,24,14},
+    {  1,23,14}, {  1,23,14}, {  1,22,14}, {  1,22,14},
+    {  1,21,14}, {  1,21,14}, {  1,20,14}, {  1,20,14},
+    {  1,19,14}, {  1,19,14}, {  1,18,14}, {  1,18,14},
+    {  1,17,14}, {  1,17,14}, {  1,16,14}, {  1,16,14}
+};
+
+static const DCTtab DCT_13 [] = {
+    { 11, 2,13}, { 10, 2,13}, {  6, 3,13}, {  4, 4,13},
+    {  3, 5,13}, {  2, 7,13}, {  2, 6,13}, {  1,15,13},
+    {  1,14,13}, {  1,13,13}, {  1,12,13}, { 27, 1,13},
+    { 26, 1,13}, { 25, 1,13}, { 24, 1,13}, { 23, 1,13},
+    {  1,11,12}, {  1,11,12}, {  9, 2,12}, {  9, 2,12},
+    {  5, 3,12}, {  5, 3,12}, {  1,10,12}, {  1,10,12},
+    {  3, 4,12}, {  3, 4,12}, {  8, 2,12}, {  8, 2,12},
+    { 22, 1,12}, { 22, 1,12}, { 21, 1,12}, { 21, 1,12},
+    {  1, 9,12}, {  1, 9,12}, { 20, 1,12}, { 20, 1,12},
+    { 19, 1,12}, { 19, 1,12}, {  2, 5,12}, {  2, 5,12},
+    {  4, 3,12}, {  4, 3,12}, {  1, 8,12}, {  1, 8,12},
+    {  7, 2,12}, {  7, 2,12}, { 18, 1,12}, { 18, 1,12}
+};
+
+static const DCTtab DCT_B14_10 [] = {
+    { 17, 1,10}, {  6, 2,10}, {  1, 7,10}, {  3, 3,10},
+    {  2, 4,10}, { 16, 1,10}, { 15, 1,10}, {  5, 2,10}
+};
+
+static const DCTtab DCT_B14_8 [] = {
+    { 65, 0, 6}, { 65, 0, 6}, { 65, 0, 6}, { 65, 0, 6},
+    {  3, 2, 7}, {  3, 2, 7}, { 10, 1, 7}, { 10, 1, 7},
+    {  1, 4, 7}, {  1, 4, 7}, {  9, 1, 7}, {  9, 1, 7},
+    {  8, 1, 6}, {  8, 1, 6}, {  8, 1, 6}, {  8, 1, 6},
+    {  7, 1, 6}, {  7, 1, 6}, {  7, 1, 6}, {  7, 1, 6},
+    {  2, 2, 6}, {  2, 2, 6}, {  2, 2, 6}, {  2, 2, 6},
+    {  6, 1, 6}, {  6, 1, 6}, {  6, 1, 6}, {  6, 1, 6},
+    { 14, 1, 8}, {  1, 6, 8}, { 13, 1, 8}, { 12, 1, 8},
+    {  4, 2, 8}, {  2, 3, 8}, {  1, 5, 8}, { 11, 1, 8}
+};
+
+static const DCTtab DCT_B14AC_5 [] = {
+                 {  1, 3, 5}, {  5, 1, 5}, {  4, 1, 5},
+    {  1, 2, 4}, {  1, 2, 4}, {  3, 1, 4}, {  3, 1, 4},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {129, 0, 2}, {129, 0, 2}, {129, 0, 2}, {129, 0, 2},
+    {129, 0, 2}, {129, 0, 2}, {129, 0, 2}, {129, 0, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}
+};
+
+static const DCTtab DCT_B14DC_5 [] = {
+                 {  1, 3, 5}, {  5, 1, 5}, {  4, 1, 5},
+    {  1, 2, 4}, {  1, 2, 4}, {  3, 1, 4}, {  3, 1, 4},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {  1, 1, 1}, {  1, 1, 1}, {  1, 1, 1}, {  1, 1, 1},
+    {  1, 1, 1}, {  1, 1, 1}, {  1, 1, 1}, {  1, 1, 1},
+    {  1, 1, 1}, {  1, 1, 1}, {  1, 1, 1}, {  1, 1, 1},
+    {  1, 1, 1}, {  1, 1, 1}, {  1, 1, 1}, {  1, 1, 1}
+};
+
+static const DCTtab DCT_B15_10 [] = {
+    {  6, 2, 9}, {  6, 2, 9}, { 15, 1, 9}, { 15, 1, 9},
+    {  3, 4,10}, { 17, 1,10}, { 16, 1, 9}, { 16, 1, 9}
+};
+
+static const DCTtab DCT_B15_8 [] = {
+    { 65, 0, 6}, { 65, 0, 6}, { 65, 0, 6}, { 65, 0, 6},
+    {  8, 1, 7}, {  8, 1, 7}, {  9, 1, 7}, {  9, 1, 7},
+    {  7, 1, 7}, {  7, 1, 7}, {  3, 2, 7}, {  3, 2, 7},
+    {  1, 7, 6}, {  1, 7, 6}, {  1, 7, 6}, {  1, 7, 6},
+    {  1, 6, 6}, {  1, 6, 6}, {  1, 6, 6}, {  1, 6, 6},
+    {  5, 1, 6}, {  5, 1, 6}, {  5, 1, 6}, {  5, 1, 6},
+    {  6, 1, 6}, {  6, 1, 6}, {  6, 1, 6}, {  6, 1, 6},
+    {  2, 5, 8}, { 12, 1, 8}, {  1,11, 8}, {  1,10, 8},
+    { 14, 1, 8}, { 13, 1, 8}, {  4, 2, 8}, {  2, 4, 8},
+    {  3, 1, 5}, {  3, 1, 5}, {  3, 1, 5}, {  3, 1, 5},
+    {  3, 1, 5}, {  3, 1, 5}, {  3, 1, 5}, {  3, 1, 5},
+    {  2, 2, 5}, {  2, 2, 5}, {  2, 2, 5}, {  2, 2, 5},
+    {  2, 2, 5}, {  2, 2, 5}, {  2, 2, 5}, {  2, 2, 5},
+    {  4, 1, 5}, {  4, 1, 5}, {  4, 1, 5}, {  4, 1, 5},
+    {  4, 1, 5}, {  4, 1, 5}, {  4, 1, 5}, {  4, 1, 5},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3}, {  2, 1, 3},
+    {129, 0, 4}, {129, 0, 4}, {129, 0, 4}, {129, 0, 4},
+    {129, 0, 4}, {129, 0, 4}, {129, 0, 4}, {129, 0, 4},
+    {129, 0, 4}, {129, 0, 4}, {129, 0, 4}, {129, 0, 4},
+    {129, 0, 4}, {129, 0, 4}, {129, 0, 4}, {129, 0, 4},
+    {  1, 3, 4}, {  1, 3, 4}, {  1, 3, 4}, {  1, 3, 4},
+    {  1, 3, 4}, {  1, 3, 4}, {  1, 3, 4}, {  1, 3, 4},
+    {  1, 3, 4}, {  1, 3, 4}, {  1, 3, 4}, {  1, 3, 4},
+    {  1, 3, 4}, {  1, 3, 4}, {  1, 3, 4}, {  1, 3, 4},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2}, {  1, 1, 2},
+    {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3},
+    {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3},
+    {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3},
+    {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3},
+    {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3},
+    {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3},
+    {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3},
+    {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3}, {  1, 2, 3},
+    {  1, 4, 5}, {  1, 4, 5}, {  1, 4, 5}, {  1, 4, 5},
+    {  1, 4, 5}, {  1, 4, 5}, {  1, 4, 5}, {  1, 4, 5},
+    {  1, 5, 5}, {  1, 5, 5}, {  1, 5, 5}, {  1, 5, 5},
+    {  1, 5, 5}, {  1, 5, 5}, {  1, 5, 5}, {  1, 5, 5},
+    { 10, 1, 7}, { 10, 1, 7}, {  2, 3, 7}, {  2, 3, 7},
+    { 11, 1, 7}, { 11, 1, 7}, {  1, 8, 7}, {  1, 8, 7},
+    {  1, 9, 7}, {  1, 9, 7}, {  1,12, 8}, {  1,13, 8},
+    {  3, 3, 8}, {  5, 2, 8}, {  1,14, 8}, {  1,15, 8}
+};
+
+
+static const MBAtab MBA_5 [] = {
+                    {6, 5}, {5, 5}, {4, 4}, {4, 4}, {3, 4}, {3, 4},
+    {2, 3}, {2, 3}, {2, 3}, {2, 3}, {1, 3}, {1, 3}, {1, 3}, {1, 3},
+    {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1},
+    {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}, {0, 1}
+};
+
+static const MBAtab MBA_11 [] = {
+    {32, 11}, {31, 11}, {30, 11}, {29, 11},
+    {28, 11}, {27, 11}, {26, 11}, {25, 11},
+    {24, 11}, {23, 11}, {22, 11}, {21, 11},
+    {20, 10}, {20, 10}, {19, 10}, {19, 10},
+    {18, 10}, {18, 10}, {17, 10}, {17, 10},
+    {16, 10}, {16, 10}, {15, 10}, {15, 10},
+    {14,  8}, {14,  8}, {14,  8}, {14,  8},
+    {14,  8}, {14,  8}, {14,  8}, {14,  8},
+    {13,  8}, {13,  8}, {13,  8}, {13,  8},
+    {13,  8}, {13,  8}, {13,  8}, {13,  8},
+    {12,  8}, {12,  8}, {12,  8}, {12,  8},
+    {12,  8}, {12,  8}, {12,  8}, {12,  8},
+    {11,  8}, {11,  8}, {11,  8}, {11,  8},
+    {11,  8}, {11,  8}, {11,  8}, {11,  8},
+    {10,  8}, {10,  8}, {10,  8}, {10,  8},
+    {10,  8}, {10,  8}, {10,  8}, {10,  8},
+    { 9,  8}, { 9,  8}, { 9,  8}, { 9,  8},
+    { 9,  8}, { 9,  8}, { 9,  8}, { 9,  8},
+    { 8,  7}, { 8,  7}, { 8,  7}, { 8,  7},
+    { 8,  7}, { 8,  7}, { 8,  7}, { 8,  7},
+    { 8,  7}, { 8,  7}, { 8,  7}, { 8,  7},
+    { 8,  7}, { 8,  7}, { 8,  7}, { 8,  7},
+    { 7,  7}, { 7,  7}, { 7,  7}, { 7,  7},
+    { 7,  7}, { 7,  7}, { 7,  7}, { 7,  7},
+    { 7,  7}, { 7,  7}, { 7,  7}, { 7,  7},
+    { 7,  7}, { 7,  7}, { 7,  7}, { 7,  7}
+};
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/stream_out/transrate/Makefile.am ./modules/stream_out/transrate/Makefile.am
--- /arno/build/vlc-1.0.5/modules/stream_out/transrate/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/stream_out/transrate/Makefile.am	2010-02-26 14:52:41.000000000 +0100
@@ -0,0 +1,22 @@
+# modules/stream_out/transrate/Makefile.am automatically generated from modules/stream_out/transrate/Modules.am by modules/genmf
+# DO NOT EDIT THIS FILE DIRECTLY! See Modules.am instead.
+
+basedir = stream_out
+dir = stream_out/transrate
+mods = stream_out_transrate
+libvlc_LTLIBRARIES = 
+EXTRA_LTLIBRARIES = 
+
+include $(top_srcdir)/modules/common.am
+
+# The stream_out_transrate plugin
+libstream_out_transrate_plugin_la_SOURCES = $(SOURCES_stream_out_transrate)
+nodist_libstream_out_transrate_plugin_la_SOURCES = $(nodist_SOURCES_stream_out_transrate)
+# Force per-target objects:
+libstream_out_transrate_plugin_la_CFLAGS = $(AM_CFLAGS)
+libstream_out_transrate_plugin_la_CXXFLAGS = $(AM_CXXFLAGS)
+libstream_out_transrate_plugin_la_OBJCFLAGS = $(AM_OBJCFLAGS)
+# Set LIBADD and DEPENDENCIES manually:
+libstream_out_transrate_plugin_la_LIBADD = $(AM_LIBADD)
+libstream_out_transrate_plugin_la_DEPENDENCIES = $(top_srcdir)/src/libvlccore.sym
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/stream_out/transrate/Makefile.in ./modules/stream_out/transrate/Makefile.in
--- /arno/build/vlc-1.0.5/modules/stream_out/transrate/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/stream_out/transrate/Makefile.in	2010-02-26 14:52:41.000000000 +0100
@@ -0,0 +1,1010 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+# modules/stream_out/transrate/Makefile.am automatically generated from modules/stream_out/transrate/Modules.am by modules/genmf
+# DO NOT EDIT THIS FILE DIRECTLY! See Modules.am instead.
+
+# Common code for VLC modules/.../Makefile.am
+#
+# Copyright (C) 2005-2007 the VideoLAN team
+# Copyright (C) 2005-2008 RÃ©mi Denis-Courmont
+#
+# Authors: Sam Hocevar <sam@zoy.org>
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(srcdir)/Modules.am $(top_srcdir)/modules/common.am
+subdir = modules/stream_out/transrate
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/flags.m4 \
+	$(top_srcdir)/m4/gettext.m4 $(top_srcdir)/m4/iconv.m4 \
+	$(top_srcdir)/m4/intlmacosx.m4 $(top_srcdir)/m4/lib-ld.m4 \
+	$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \
+	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
+	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
+	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/m4/nls.m4 \
+	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/progtest.m4 \
+	$(top_srcdir)/m4/vlc.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libvlcdir)"
+libvlcLTLIBRARIES_INSTALL = $(INSTALL)
+LTLIBRARIES = $(libvlc_LTLIBRARIES)
+am__DEPENDENCIES_1 = `$(VLC_CONFIG) plugin $@` $(LTLIBVLCCORE) \
+	$(top_builddir)/compat/libcompat.la
+am__objects_1 = libstream_out_transrate_plugin_la-transrate.lo \
+	libstream_out_transrate_plugin_la-frame.lo \
+	libstream_out_transrate_plugin_la-block.lo
+am_libstream_out_transrate_plugin_la_OBJECTS = $(am__objects_1)
+nodist_libstream_out_transrate_plugin_la_OBJECTS =
+libstream_out_transrate_plugin_la_OBJECTS =  \
+	$(am_libstream_out_transrate_plugin_la_OBJECTS) \
+	$(nodist_libstream_out_transrate_plugin_la_OBJECTS)
+libstream_out_transrate_plugin_la_LINK = $(LIBTOOL) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libstream_out_transrate_plugin_la_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/autotools/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libstream_out_transrate_plugin_la_SOURCES) \
+	$(nodist_libstream_out_transrate_plugin_la_SOURCES)
+DIST_SOURCES = $(libstream_out_transrate_plugin_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALIASES = @ALIASES@
+ALLOCA = @ALLOCA@
+AMTAR = @AMTAR@
+AM_CPPFLAGS = @AM_CPPFLAGS@
+AR = @AR@
+ARCH = @ARCH@
+AS = @AS@
+ASM = @ASM@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AVCODEC_CFLAGS = @AVCODEC_CFLAGS@
+AVCODEC_LIBS = @AVCODEC_LIBS@
+AVFORMAT_CFLAGS = @AVFORMAT_CFLAGS@
+AVFORMAT_LIBS = @AVFORMAT_LIBS@
+AWK = @AWK@
+BONJOUR_CFLAGS = @BONJOUR_CFLAGS@
+BONJOUR_LIBS = @BONJOUR_LIBS@
+CACA_CONFIG = @CACA_CONFIG@
+CC = @CC@
+CCAS = @CCAS@
+CCASDEPMODE = @CCASDEPMODE@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CONTRIB_DIR = @CONTRIB_DIR@
+COPYRIGHT_MESSAGE = @COPYRIGHT_MESSAGE@
+COPYRIGHT_YEARS = @COPYRIGHT_YEARS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CSRI_CFLAGS = @CSRI_CFLAGS@
+CSRI_LIBS = @CSRI_LIBS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH = @CYGPATH@
+CYGPATH_W = @CYGPATH_W@
+DBUS_CFLAGS = @DBUS_CFLAGS@
+DBUS_LIBS = @DBUS_LIBS@
+DCA_CFLAGS = @DCA_CFLAGS@
+DCA_LIBS = @DCA_LIBS@
+DEFS = @DEFS@
+DEFS_BIGENDIAN = @DEFS_BIGENDIAN@
+DEPDIR = @DEPDIR@
+DIRAC_CFLAGS = @DIRAC_CFLAGS@
+DIRAC_LIBS = @DIRAC_LIBS@
+DIRECTFB_CFLAGS = @DIRECTFB_CFLAGS@
+DIRECTFB_CONFIG = @DIRECTFB_CONFIG@
+DIRECTFB_LIBS = @DIRECTFB_LIBS@
+DLLTOOL = @DLLTOOL@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+DVDNAV_CONFIG = @DVDNAV_CONFIG@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+FILE_LIBVLCCORE_DLL = @FILE_LIBVLCCORE_DLL@
+FILE_LIBVLC_DLL = @FILE_LIBVLC_DLL@
+FLUIDSYNTH_CFLAGS = @FLUIDSYNTH_CFLAGS@
+FLUIDSYNTH_LIBS = @FLUIDSYNTH_LIBS@
+FREETYPE_CFLAGS = @FREETYPE_CFLAGS@
+FREETYPE_LIBS = @FREETYPE_LIBS@
+FRIBIDI_CFLAGS = @FRIBIDI_CFLAGS@
+FRIBIDI_LIBS = @FRIBIDI_LIBS@
+GETTEXT_MACRO_VERSION = @GETTEXT_MACRO_VERSION@
+GLIB2_CFLAGS = @GLIB2_CFLAGS@
+GLIB2_LIBS = @GLIB2_LIBS@
+GMSGFMT = @GMSGFMT@
+GMSGFMT_015 = @GMSGFMT_015@
+GNOMEVFS_CFLAGS = @GNOMEVFS_CFLAGS@
+GNOMEVFS_LIBS = @GNOMEVFS_LIBS@
+GNUTLS_CFLAGS = @GNUTLS_CFLAGS@
+GNUTLS_LIBS = @GNUTLS_LIBS@
+GREP = @GREP@
+GTK2_CFLAGS = @GTK2_CFLAGS@
+GTK2_LIBS = @GTK2_LIBS@
+HAL_CFLAGS = @HAL_CFLAGS@
+HAL_LIBS = @HAL_LIBS@
+HILDON_CFLAGS = @HILDON_CFLAGS@
+HILDON_LIBS = @HILDON_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INTLLIBS = @INTLLIBS@
+INTL_MACOSX_LIBS = @INTL_MACOSX_LIBS@
+KATE_CFLAGS = @KATE_CFLAGS@
+KATE_LIBS = @KATE_LIBS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBASS_CFLAGS = @LIBASS_CFLAGS@
+LIBASS_LIBS = @LIBASS_LIBS@
+LIBCDDB_CFLAGS = @LIBCDDB_CFLAGS@
+LIBCDDB_LIBS = @LIBCDDB_LIBS@
+LIBCDIO_CFLAGS = @LIBCDIO_CFLAGS@
+LIBCDIO_LIBS = @LIBCDIO_LIBS@
+LIBCDIO_PARANOIA_CFLAGS = @LIBCDIO_PARANOIA_CFLAGS@
+LIBCDIO_PARANOIA_LIBS = @LIBCDIO_PARANOIA_LIBS@
+LIBEXT = @LIBEXT@
+LIBGCRYPT_CFLAGS = @LIBGCRYPT_CFLAGS@
+LIBGCRYPT_CONFIG = @LIBGCRYPT_CONFIG@
+LIBGCRYPT_LIBS = @LIBGCRYPT_LIBS@
+LIBICONV = @LIBICONV@
+LIBINTL = @LIBINTL@
+LIBMPEG2_CFLAGS = @LIBMPEG2_CFLAGS@
+LIBMPEG2_LIBS = @LIBMPEG2_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBPROXY_CFLAGS = @LIBPROXY_CFLAGS@
+LIBPROXY_LIBS = @LIBPROXY_LIBS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIBV4L2_CFLAGS = @LIBV4L2_CFLAGS@
+LIBV4L2_LIBS = @LIBV4L2_LIBS@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
+LTLIBOBJS = @LTLIBOBJS@
+LTLIBa52tofloat32 = @LTLIBa52tofloat32@
+LTLIBa52tospdif = @LTLIBa52tospdif@
+LTLIBaa = @LTLIBaa@
+LTLIBaccess_alsa = @LTLIBaccess_alsa@
+LTLIBaccess_dv = @LTLIBaccess_dv@
+LTLIBaccess_eyetv = @LTLIBaccess_eyetv@
+LTLIBaccess_gnomevfs = @LTLIBaccess_gnomevfs@
+LTLIBaccess_jack = @LTLIBaccess_jack@
+LTLIBaccess_mmap = @LTLIBaccess_mmap@
+LTLIBaccess_mtp = @LTLIBaccess_mtp@
+LTLIBaccess_oss = @LTLIBaccess_oss@
+LTLIBaccess_output_shout = @LTLIBaccess_output_shout@
+LTLIBaccess_realrtsp = @LTLIBaccess_realrtsp@
+LTLIBaccess_smb = @LTLIBaccess_smb@
+LTLIBadjust = @LTLIBadjust@
+LTLIBalphamask = @LTLIBalphamask@
+LTLIBalsa = @LTLIBalsa@
+LTLIBaout_directx = @LTLIBaout_directx@
+LTLIBaout_file = @LTLIBaout_file@
+LTLIBaout_sdl = @LTLIBaout_sdl@
+LTLIBasademux = @LTLIBasademux@
+LTLIBatmo = @LTLIBatmo@
+LTLIBaudio_format = @LTLIBaudio_format@
+LTLIBaudioscrobbler = @LTLIBaudioscrobbler@
+LTLIBauhal = @LTLIBauhal@
+LTLIBavcodec = @LTLIBavcodec@
+LTLIBavformat = @LTLIBavformat@
+LTLIBbandlimited_resampler = @LTLIBbandlimited_resampler@
+LTLIBbda = @LTLIBbda@
+LTLIBbeos = @LTLIBbeos@
+LTLIBblend = @LTLIBblend@
+LTLIBblendbench = @LTLIBblendbench@
+LTLIBbluescreen = @LTLIBbluescreen@
+LTLIBbonjour = @LTLIBbonjour@
+LTLIBcaca = @LTLIBcaca@
+LTLIBcanvas = @LTLIBcanvas@
+LTLIBcdda = @LTLIBcdda@
+LTLIBcddax = @LTLIBcddax@
+LTLIBchain = @LTLIBchain@
+LTLIBclone = @LTLIBclone@
+LTLIBcmml = @LTLIBcmml@
+LTLIBcolorthres = @LTLIBcolorthres@
+LTLIBconverter_float = @LTLIBconverter_float@
+LTLIBcrop = @LTLIBcrop@
+LTLIBcroppadd = @LTLIBcroppadd@
+LTLIBcsri = @LTLIBcsri@
+LTLIBdbus = @LTLIBdbus@
+LTLIBdc1394 = @LTLIBdc1394@
+LTLIBdeinterlace = @LTLIBdeinterlace@
+LTLIBdirac = @LTLIBdirac@
+LTLIBdirect3d = @LTLIBdirect3d@
+LTLIBdirectfb = @LTLIBdirectfb@
+LTLIBdmo = @LTLIBdmo@
+LTLIBdolby_surround_decoder = @LTLIBdolby_surround_decoder@
+LTLIBdshow = @LTLIBdshow@
+LTLIBdtstofloat32 = @LTLIBdtstofloat32@
+LTLIBdtstospdif = @LTLIBdtstospdif@
+LTLIBdvb = @LTLIBdvb@
+LTLIBdvdnav = @LTLIBdvdnav@
+LTLIBdvdread = @LTLIBdvdread@
+LTLIBdynamicoverlay = @LTLIBdynamicoverlay@
+LTLIBequalizer = @LTLIBequalizer@
+LTLIBerase = @LTLIBerase@
+LTLIBextract = @LTLIBextract@
+LTLIBfaad = @LTLIBfaad@
+LTLIBfake = @LTLIBfake@
+LTLIBfb = @LTLIBfb@
+LTLIBfbosd = @LTLIBfbosd@
+LTLIBfloat32_mixer = @LTLIBfloat32_mixer@
+LTLIBfluidsynth = @LTLIBfluidsynth@
+LTLIBfolder = @LTLIBfolder@
+LTLIBfreetype = @LTLIBfreetype@
+LTLIBgalaktos = @LTLIBgalaktos@
+LTLIBgaussianblur = @LTLIBgaussianblur@
+LTLIBgestures = @LTLIBgestures@
+LTLIBggi = @LTLIBggi@
+LTLIBglobalhotkeys = @LTLIBglobalhotkeys@
+LTLIBglwin32 = @LTLIBglwin32@
+LTLIBglx = @LTLIBglx@
+LTLIBgme = @LTLIBgme@
+LTLIBgnome2_main = @LTLIBgnome2_main@
+LTLIBgnome_main = @LTLIBgnome_main@
+LTLIBgnutls = @LTLIBgnutls@
+LTLIBgoom = @LTLIBgoom@
+LTLIBgradient = @LTLIBgradient@
+LTLIBgrain = @LTLIBgrain@
+LTLIBgrowl = @LTLIBgrowl@
+LTLIBgrowl_udp = @LTLIBgrowl_udp@
+LTLIBgtk2_main = @LTLIBgtk2_main@
+LTLIBgtk_main = @LTLIBgtk_main@
+LTLIBhal = @LTLIBhal@
+LTLIBhd1000a = @LTLIBhd1000a@
+LTLIBhd1000v = @LTLIBhd1000v@
+LTLIBheadphone_channel_mixer = @LTLIBheadphone_channel_mixer@
+LTLIBhotkeys = @LTLIBhotkeys@
+LTLIBhttp = @LTLIBhttp@
+LTLIBi420_rgb_mmx = @LTLIBi420_rgb_mmx@
+LTLIBi420_rgb_sse2 = @LTLIBi420_rgb_sse2@
+LTLIBi420_ymga = @LTLIBi420_ymga@
+LTLIBi420_ymga_mmx = @LTLIBi420_ymga_mmx@
+LTLIBi420_yuy2 = @LTLIBi420_yuy2@
+LTLIBi420_yuy2_altivec = @LTLIBi420_yuy2_altivec@
+LTLIBi420_yuy2_mmx = @LTLIBi420_yuy2_mmx@
+LTLIBi420_yuy2_sse2 = @LTLIBi420_yuy2_sse2@
+LTLIBi422_i420 = @LTLIBi422_i420@
+LTLIBi422_yuy2 = @LTLIBi422_yuy2@
+LTLIBi422_yuy2_mmx = @LTLIBi422_yuy2_mmx@
+LTLIBi422_yuy2_sse2 = @LTLIBi422_yuy2_sse2@
+LTLIBid3tag = @LTLIBid3tag@
+LTLIBinhibit = @LTLIBinhibit@
+LTLIBinvert = @LTLIBinvert@
+LTLIBjack = @LTLIBjack@
+LTLIBkate = @LTLIBkate@
+LTLIBlibass = @LTLIBlibass@
+LTLIBlibmpeg2 = @LTLIBlibmpeg2@
+LTLIBlinear_resampler = @LTLIBlinear_resampler@
+LTLIBlirc = @LTLIBlirc@
+LTLIBlive555 = @LTLIBlive555@
+LTLIBlogo = @LTLIBlogo@
+LTLIBmacosx = @LTLIBmacosx@
+LTLIBmaemo = @LTLIBmaemo@
+LTLIBmagnify = @LTLIBmagnify@
+LTLIBmarq = @LTLIBmarq@
+LTLIBmemcpy3dn = @LTLIBmemcpy3dn@
+LTLIBmemcpyaltivec = @LTLIBmemcpyaltivec@
+LTLIBmemcpymmx = @LTLIBmemcpymmx@
+LTLIBmemcpymmxext = @LTLIBmemcpymmxext@
+LTLIBmga = @LTLIBmga@
+LTLIBminimal_macosx = @LTLIBminimal_macosx@
+LTLIBmkv = @LTLIBmkv@
+LTLIBmod = @LTLIBmod@
+LTLIBmosaic = @LTLIBmosaic@
+LTLIBmotion = @LTLIBmotion@
+LTLIBmotionblur = @LTLIBmotionblur@
+LTLIBmotiondetect = @LTLIBmotiondetect@
+LTLIBmozilla = @LTLIBmozilla@
+LTLIBmpc = @LTLIBmpc@
+LTLIBmpgatofixed32 = @LTLIBmpgatofixed32@
+LTLIBmsn = @LTLIBmsn@
+LTLIBmtp = @LTLIBmtp@
+LTLIBmux_ogg = @LTLIBmux_ogg@
+LTLIBmux_ts = @LTLIBmux_ts@
+LTLIBncurses = @LTLIBncurses@
+LTLIBnoise = @LTLIBnoise@
+LTLIBnormvol = @LTLIBnormvol@
+LTLIBnotify = @LTLIBnotify@
+LTLIBntservice = @LTLIBntservice@
+LTLIBogg = @LTLIBogg@
+LTLIBomapfb = @LTLIBomapfb@
+LTLIBopencv_example = @LTLIBopencv_example@
+LTLIBopencv_wrapper = @LTLIBopencv_wrapper@
+LTLIBopengl = @LTLIBopengl@
+LTLIBopengllayer = @LTLIBopengllayer@
+LTLIBopie = @LTLIBopie@
+LTLIBosd_parser = @LTLIBosd_parser@
+LTLIBosdmenu = @LTLIBosdmenu@
+LTLIBoss = @LTLIBoss@
+LTLIBpanoramix = @LTLIBpanoramix@
+LTLIBparam_eq = @LTLIBparam_eq@
+LTLIBpda = @LTLIBpda@
+LTLIBpng = @LTLIBpng@
+LTLIBpodcast = @LTLIBpodcast@
+LTLIBportaudio = @LTLIBportaudio@
+LTLIBpostproc = @LTLIBpostproc@
+LTLIBprobe_hal = @LTLIBprobe_hal@
+LTLIBpsychedelic = @LTLIBpsychedelic@
+LTLIBpulse = @LTLIBpulse@
+LTLIBpuzzle = @LTLIBpuzzle@
+LTLIBpvr = @LTLIBpvr@
+LTLIBqnx = @LTLIBqnx@
+LTLIBqt4 = @LTLIBqt4@
+LTLIBqtcapture = @LTLIBqtcapture@
+LTLIBqte = @LTLIBqte@
+LTLIBqte_main = @LTLIBqte_main@
+LTLIBquartztext = @LTLIBquartztext@
+LTLIBquicktime = @LTLIBquicktime@
+LTLIBrc = @LTLIBrc@
+LTLIBrealaudio = @LTLIBrealaudio@
+LTLIBrealvideo = @LTLIBrealvideo@
+LTLIBremoteosd = @LTLIBremoteosd@
+LTLIBripple = @LTLIBripple@
+LTLIBrotate = @LTLIBrotate@
+LTLIBrss = @LTLIBrss@
+LTLIBrv32 = @LTLIBrv32@
+LTLIBsap = @LTLIBsap@
+LTLIBscale = @LTLIBscale@
+LTLIBscaletempo = @LTLIBscaletempo@
+LTLIBscene = @LTLIBscene@
+LTLIBschroedinger = @LTLIBschroedinger@
+LTLIBscreen = @LTLIBscreen@
+LTLIBscreensaver = @LTLIBscreensaver@
+LTLIBsdl_image = @LTLIBsdl_image@
+LTLIBsharpen = @LTLIBsharpen@
+LTLIBshine = @LTLIBshine@
+LTLIBshout = @LTLIBshout@
+LTLIBshowintf = @LTLIBshowintf@
+LTLIBsignals = @LTLIBsignals@
+LTLIBsimple_channel_mixer = @LTLIBsimple_channel_mixer@
+LTLIBskins2 = @LTLIBskins2@
+LTLIBsnapshot = @LTLIBsnapshot@
+LTLIBspatializer = @LTLIBspatializer@
+LTLIBspdif_mixer = @LTLIBspdif_mixer@
+LTLIBspeex = @LTLIBspeex@
+LTLIBstream_out_raop = @LTLIBstream_out_raop@
+LTLIBsvg = @LTLIBsvg@
+LTLIBsvgalib = @LTLIBsvgalib@
+LTLIBswscale = @LTLIBswscale@
+LTLIBswscale_maemo = @LTLIBswscale_maemo@
+LTLIBtaglib = @LTLIBtaglib@
+LTLIBtarkin = @LTLIBtarkin@
+LTLIBtelepathy = @LTLIBtelepathy@
+LTLIBtelnet = @LTLIBtelnet@
+LTLIBtelx = @LTLIBtelx@
+LTLIBtest1 = @LTLIBtest1@
+LTLIBtest2 = @LTLIBtest2@
+LTLIBtest3 = @LTLIBtest3@
+LTLIBtest4 = @LTLIBtest4@
+LTLIBtheora = @LTLIBtheora@
+LTLIBtransform = @LTLIBtransform@
+LTLIBtremor = @LTLIBtremor@
+LTLIBts = @LTLIBts@
+LTLIBtwolame = @LTLIBtwolame@
+LTLIBunzip = @LTLIBunzip@
+LTLIBupnp_cc = @LTLIBupnp_cc@
+LTLIBupnp_intel = @LTLIBupnp_intel@
+LTLIBv4l = @LTLIBv4l@
+LTLIBv4l2 = @LTLIBv4l2@
+LTLIBvcd = @LTLIBvcd@
+LTLIBvcdx = @LTLIBvcdx@
+LTLIBvisual = @LTLIBvisual@
+LTLIBvmem = @LTLIBvmem@
+LTLIBvorbis = @LTLIBvorbis@
+LTLIBvout_directx = @LTLIBvout_directx@
+LTLIBvout_sdl = @LTLIBvout_sdl@
+LTLIBwall = @LTLIBwall@
+LTLIBwave = @LTLIBwave@
+LTLIBwaveout = @LTLIBwaveout@
+LTLIBwin32text = @LTLIBwin32text@
+LTLIBwince = @LTLIBwince@
+LTLIBwingapi = @LTLIBwingapi@
+LTLIBwingdi = @LTLIBwingdi@
+LTLIBwma_fixed = @LTLIBwma_fixed@
+LTLIBx11 = @LTLIBx11@
+LTLIBx11_screen = @LTLIBx11_screen@
+LTLIBx264 = @LTLIBx264@
+LTLIBxcb = @LTLIBxcb@
+LTLIBxcb_window = @LTLIBxcb_window@
+LTLIBxcb_xv = @LTLIBxcb_xv@
+LTLIBxml = @LTLIBxml@
+LTLIBxosd = @LTLIBxosd@
+LTLIBxvideo = @LTLIBxvideo@
+LTLIBxvmc = @LTLIBxvmc@
+LTLIByuv = @LTLIByuv@
+LTLIByuvp = @LTLIByuvp@
+LTLIByuy2_i420 = @LTLIByuy2_i420@
+LTLIByuy2_i422 = @LTLIByuy2_i422@
+LTLIBzip = @LTLIBzip@
+LTLIBzvbi = @LTLIBzvbi@
+LUA_CFLAGS = @LUA_CFLAGS@
+LUA_LIBS = @LUA_LIBS@
+MACOSX_DEPLOYMENT_TARGET = @MACOSX_DEPLOYMENT_TARGET@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MIDL = @MIDL@
+MINIZIP_CFLAGS = @MINIZIP_CFLAGS@
+MINIZIP_LIBS = @MINIZIP_LIBS@
+MKDIR_P = @MKDIR_P@
+MOC = @MOC@
+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@
+MOZILLA_CONFIG = @MOZILLA_CONFIG@
+MOZILLA_LIBS = @MOZILLA_LIBS@
+MOZILLA_SDK_PATH = @MOZILLA_SDK_PATH@
+MSGFMT = @MSGFMT@
+MSGFMT_015 = @MSGFMT_015@
+MSGMERGE = @MSGMERGE@
+MTP_CFLAGS = @MTP_CFLAGS@
+MTP_LIBS = @MTP_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+NOTIFY_CFLAGS = @NOTIFY_CFLAGS@
+NOTIFY_LIBS = @NOTIFY_LIBS@
+OBJC = @OBJC@
+OBJCDEPMODE = @OBJCDEPMODE@
+OBJCFLAGS = @OBJCFLAGS@
+OBJCOPY = @OBJCOPY@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OPENCV_CFLAGS = @OPENCV_CFLAGS@
+OPENCV_LIBS = @OPENCV_LIBS@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PCRE_CFLAGS = @PCRE_CFLAGS@
+PCRE_LIBS = @PCRE_LIBS@
+PKGDIR = @PKGDIR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+POSTPROC_CFLAGS = @POSTPROC_CFLAGS@
+POSTPROC_LIBS = @POSTPROC_LIBS@
+POSUB = @POSUB@
+PULSE_CFLAGS = @PULSE_CFLAGS@
+PULSE_LIBS = @PULSE_LIBS@
+QT4LOCALEDIR = @QT4LOCALEDIR@
+QT4_CFLAGS = @QT4_CFLAGS@
+QT4_LIBS = @QT4_LIBS@
+RANLIB = @RANLIB@
+RCC = @RCC@
+SCHROEDINGER_CFLAGS = @SCHROEDINGER_CFLAGS@
+SCHROEDINGER_LIBS = @SCHROEDINGER_LIBS@
+SDL11_CONFIG = @SDL11_CONFIG@
+SDL12_CONFIG = @SDL12_CONFIG@
+SDL_CONFIG = @SDL_CONFIG@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SHOUT_CFLAGS = @SHOUT_CFLAGS@
+SHOUT_LIBS = @SHOUT_LIBS@
+STRIP = @STRIP@
+SVG_CFLAGS = @SVG_CFLAGS@
+SVG_LIBS = @SVG_LIBS@
+SWSCALE_CFLAGS = @SWSCALE_CFLAGS@
+SWSCALE_LIBS = @SWSCALE_LIBS@
+SYS = @SYS@
+TAGLIB_CFLAGS = @TAGLIB_CFLAGS@
+TAGLIB_LIBS = @TAGLIB_LIBS@
+TIGER_CFLAGS = @TIGER_CFLAGS@
+TIGER_LIBS = @TIGER_LIBS@
+UIC = @UIC@
+USE_NLS = @USE_NLS@
+VCDINFO_CFLAGS = @VCDINFO_CFLAGS@
+VCDINFO_LIBS = @VCDINFO_LIBS@
+VERSION = @VERSION@
+VERSION_EXTRA = @VERSION_EXTRA@
+VERSION_EXTRA_RC = @VERSION_EXTRA_RC@
+VERSION_MAJOR = @VERSION_MAJOR@
+VERSION_MESSAGE = @VERSION_MESSAGE@
+VERSION_MINOR = @VERSION_MINOR@
+VERSION_REVISION = @VERSION_REVISION@
+VLC_CONFIG = @VLC_CONFIG@
+WIDL = @WIDL@
+WINDRES = @WINDRES@
+WINE_SDK_PATH = @WINE_SDK_PATH@
+X264_CFLAGS = @X264_CFLAGS@
+X264_LIBS = @X264_LIBS@
+XCB_CFLAGS = @XCB_CFLAGS@
+XCB_KEYSYMS_CFLAGS = @XCB_KEYSYMS_CFLAGS@
+XCB_KEYSYMS_LIBS = @XCB_KEYSYMS_LIBS@
+XCB_LIBS = @XCB_LIBS@
+XCB_SHM_CFLAGS = @XCB_SHM_CFLAGS@
+XCB_SHM_LIBS = @XCB_SHM_LIBS@
+XCB_XV_CFLAGS = @XCB_XV_CFLAGS@
+XCB_XV_LIBS = @XCB_XV_LIBS@
+XGETTEXT = @XGETTEXT@
+XGETTEXT_015 = @XGETTEXT_015@
+XGETTEXT_EXTRA_OPTIONS = @XGETTEXT_EXTRA_OPTIONS@
+XMKMF = @XMKMF@
+XML2_CFLAGS = @XML2_CFLAGS@
+XML2_LIBS = @XML2_LIBS@
+XPM_CFLAGS = @XPM_CFLAGS@
+XPM_LIBS = @XPM_LIBS@
+XPROTO_CFLAGS = @XPROTO_CFLAGS@
+XPROTO_LIBS = @XPROTO_LIBS@
+X_CFLAGS = @X_CFLAGS@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_LIBS = @X_LIBS@
+X_PRE_LIBS = @X_PRE_LIBS@
+ZVBI_CFLAGS = @ZVBI_CFLAGS@
+ZVBI_LIBS = @ZVBI_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+ac_ct_OBJC = @ac_ct_OBJC@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+vlcdatadir = @vlcdatadir@
+vlclibdir = @vlclibdir@
+basedir = stream_out
+dir = stream_out/transrate
+mods = stream_out_transrate
+libvlc_LTLIBRARIES = libstream_out_transrate_plugin.la
+EXTRA_LTLIBRARIES = 
+NULL = 
+SUFFIXES = 
+libvlcdir = $(vlclibdir)/$(basedir)
+EXTRA_DIST = Modules.am
+BUILT_SOURCES = 
+CLEANFILES = $(BUILT_SOURCES)
+LTLIBVLCCORE = $(top_builddir)/src/libvlccore.la
+AM_CFLAGS = `$(VLC_CONFIG) --cflags plugin $@`
+AM_CXXFLAGS = `$(VLC_CONFIG) --cxxflags plugin $@`
+AM_OBJCFLAGS = `$(VLC_CONFIG) --objcflags plugin $@`
+AM_LDFLAGS = -rpath '$(libvlcdir)' \
+	-avoid-version -module \
+	-export-symbol-regex ^vlc_entry \
+	-shrext $(LIBEXT) \
+	-no-undefined \
+	 `$(VLC_CONFIG) --ldflags plugin $@`
+
+AM_LIBADD = `$(VLC_CONFIG) -libs plugin $@` \
+	$(LTLIBVLCCORE) $(top_builddir)/compat/libcompat.la
+
+SOURCES_stream_out_transrate = transrate.c transrate.h frame.c block.c getvlc.h putvlc.h
+
+# The stream_out_transrate plugin
+libstream_out_transrate_plugin_la_SOURCES = $(SOURCES_stream_out_transrate)
+nodist_libstream_out_transrate_plugin_la_SOURCES = $(nodist_SOURCES_stream_out_transrate)
+# Force per-target objects:
+libstream_out_transrate_plugin_la_CFLAGS = $(AM_CFLAGS)
+libstream_out_transrate_plugin_la_CXXFLAGS = $(AM_CXXFLAGS)
+libstream_out_transrate_plugin_la_OBJCFLAGS = $(AM_OBJCFLAGS)
+# Set LIBADD and DEPENDENCIES manually:
+libstream_out_transrate_plugin_la_LIBADD = $(AM_LIBADD)
+libstream_out_transrate_plugin_la_DEPENDENCIES = $(top_srcdir)/src/libvlccore.sym
+all: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/modules/common.am $(srcdir)/Modules.am $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  modules/stream_out/transrate/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  modules/stream_out/transrate/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-libvlcLTLIBRARIES: $(libvlc_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(libvlcdir)" || $(MKDIR_P) "$(DESTDIR)$(libvlcdir)"
+	@list='$(libvlc_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=$(am__strip_dir) \
+	    echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(libvlcLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(libvlcdir)/$$f'"; \
+	    $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(libvlcLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(libvlcdir)/$$f"; \
+	  else :; fi; \
+	done
+
+uninstall-libvlcLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libvlc_LTLIBRARIES)'; for p in $$list; do \
+	  p=$(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libvlcdir)/$$p'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libvlcdir)/$$p"; \
+	done
+
+clean-libvlcLTLIBRARIES:
+	-test -z "$(libvlc_LTLIBRARIES)" || rm -f $(libvlc_LTLIBRARIES)
+	@list='$(libvlc_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libstream_out_transrate_plugin.la: $(libstream_out_transrate_plugin_la_OBJECTS) $(libstream_out_transrate_plugin_la_DEPENDENCIES) 
+	$(libstream_out_transrate_plugin_la_LINK) -rpath $(libvlcdir) $(libstream_out_transrate_plugin_la_OBJECTS) $(libstream_out_transrate_plugin_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libstream_out_transrate_plugin_la-block.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libstream_out_transrate_plugin_la-frame.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libstream_out_transrate_plugin_la-transrate.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+libstream_out_transrate_plugin_la-transrate.lo: transrate.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libstream_out_transrate_plugin_la_CFLAGS) $(CFLAGS) -MT libstream_out_transrate_plugin_la-transrate.lo -MD -MP -MF $(DEPDIR)/libstream_out_transrate_plugin_la-transrate.Tpo -c -o libstream_out_transrate_plugin_la-transrate.lo `test -f 'transrate.c' || echo '$(srcdir)/'`transrate.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libstream_out_transrate_plugin_la-transrate.Tpo $(DEPDIR)/libstream_out_transrate_plugin_la-transrate.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='transrate.c' object='libstream_out_transrate_plugin_la-transrate.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libstream_out_transrate_plugin_la_CFLAGS) $(CFLAGS) -c -o libstream_out_transrate_plugin_la-transrate.lo `test -f 'transrate.c' || echo '$(srcdir)/'`transrate.c
+
+libstream_out_transrate_plugin_la-frame.lo: frame.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libstream_out_transrate_plugin_la_CFLAGS) $(CFLAGS) -MT libstream_out_transrate_plugin_la-frame.lo -MD -MP -MF $(DEPDIR)/libstream_out_transrate_plugin_la-frame.Tpo -c -o libstream_out_transrate_plugin_la-frame.lo `test -f 'frame.c' || echo '$(srcdir)/'`frame.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libstream_out_transrate_plugin_la-frame.Tpo $(DEPDIR)/libstream_out_transrate_plugin_la-frame.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='frame.c' object='libstream_out_transrate_plugin_la-frame.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libstream_out_transrate_plugin_la_CFLAGS) $(CFLAGS) -c -o libstream_out_transrate_plugin_la-frame.lo `test -f 'frame.c' || echo '$(srcdir)/'`frame.c
+
+libstream_out_transrate_plugin_la-block.lo: block.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libstream_out_transrate_plugin_la_CFLAGS) $(CFLAGS) -MT libstream_out_transrate_plugin_la-block.lo -MD -MP -MF $(DEPDIR)/libstream_out_transrate_plugin_la-block.Tpo -c -o libstream_out_transrate_plugin_la-block.lo `test -f 'block.c' || echo '$(srcdir)/'`block.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libstream_out_transrate_plugin_la-block.Tpo $(DEPDIR)/libstream_out_transrate_plugin_la-block.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='block.c' object='libstream_out_transrate_plugin_la-block.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libstream_out_transrate_plugin_la_CFLAGS) $(CFLAGS) -c -o libstream_out_transrate_plugin_la-block.lo `test -f 'block.c' || echo '$(srcdir)/'`block.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(libvlcdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-libvlcLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libvlcLTLIBRARIES
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libvlcLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-libvlcLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-libvlcLTLIBRARIES install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libvlcLTLIBRARIES
+
+
+@MAINTAINER_MODE_TRUE@$(srcdir)/Makefile.am: $(srcdir)/Modules.am $(top_srcdir)/modules/genmf
+@MAINTAINER_MODE_TRUE@	cd \$(top_srcdir) && \$(SHELL) modules/genmf $(dir)
+
+nice:
+	$(top_builddir)/compile
+
+.PHONY: nice
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/stream_out/transrate/Modules.am ./modules/stream_out/transrate/Modules.am
--- /arno/build/vlc-1.0.5/modules/stream_out/transrate/Modules.am	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/stream_out/transrate/Modules.am	2010-02-26 14:52:41.000000000 +0100
@@ -0,0 +1,3 @@
+SOURCES_stream_out_transrate = transrate.c transrate.h frame.c block.c getvlc.h putvlc.h
+
+libvlc_LTLIBRARIES += libstream_out_transrate_plugin.la
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/stream_out/transrate/putvlc.h ./modules/stream_out/transrate/putvlc.h
--- /arno/build/vlc-1.0.5/modules/stream_out/transrate/putvlc.h	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/stream_out/transrate/putvlc.h	2010-02-26 14:52:41.000000000 +0100
@@ -0,0 +1,300 @@
+/* vlc.h, variable length code tables (used by routines in putvlc.c)        */
+
+/* Copyright (C) 1996, MPEG Software Simulation Group. All Rights Reserved. */
+
+/*
+ * Disclaimer of Warranty
+ *
+ * These software programs are available to the user without any license fee or
+ * royalty on an "as is" basis.  The MPEG Software Simulation Group disclaims
+ * any and all warranties, whether express, implied, or statuary, including any
+ * implied warranties or merchantability or of fitness for a particular
+ * purpose.  In no event shall the copyright-holder be liable for any
+ * incidental, punitive, or consequential damages of any kind whatsoever
+ * arising from the use of these programs.
+ *
+ * This disclaimer of warranty extends to the user of these programs and user's
+ * customers, employees, agents, transferees, successors, and assigns.
+ *
+ * The MPEG Software Simulation Group does not represent or warrant that the
+ * programs furnished hereunder are free of infringement of any third-party
+ * patents.
+ *
+ * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
+ * are subject to royalty fees to patent holders.  Many of these patents are
+ * general enough such that they are unavoidable regardless of implementation
+ * design.
+ *
+ */
+
+/* type definitions for variable length code table entries */
+
+typedef struct
+{
+  unsigned char code; /* right justified */
+  char len;
+} VLCtable;
+
+/* for codes longer than 8 bits (excluding leading zeroes) */
+typedef struct
+{
+  unsigned short code; /* right justified */
+  char len;
+} sVLCtable;
+
+
+/* data from ISO/IEC 13818-2 DIS, Annex B, variable length code tables */
+
+/* Table B-1, variable length codes for macroblock_address_increment
+ *
+ * indexed by [macroblock_address_increment-1]
+ * 'macroblock_escape' is treated elsewhere
+ */
+
+static const VLCtable addrinctab[33]=
+{
+  {0x01,1},  {0x03,3},  {0x02,3},  {0x03,4},
+  {0x02,4},  {0x03,5},  {0x02,5},  {0x07,7},
+  {0x06,7},  {0x0b,8},  {0x0a,8},  {0x09,8},
+  {0x08,8},  {0x07,8},  {0x06,8},  {0x17,10},
+  {0x16,10}, {0x15,10}, {0x14,10}, {0x13,10},
+  {0x12,10}, {0x23,11}, {0x22,11}, {0x21,11},
+  {0x20,11}, {0x1f,11}, {0x1e,11}, {0x1d,11},
+  {0x1c,11}, {0x1b,11}, {0x1a,11}, {0x19,11},
+  {0x18,11}
+};
+
+
+/* Table B-2, B-3, B-4 variable length codes for macroblock_type
+ *
+ * indexed by [macroblock_type]
+ */
+
+static const VLCtable mbtypetab[3][32]=
+{
+ /* I */
+ {
+  {0,0}, {1,1}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
+  {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
+  {0,0}, {1,2}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
+  {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}
+ },
+ /* P */
+ {
+  {0,0}, {3,5}, {1,2}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
+  {1,3}, {0,0}, {1,1}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
+  {0,0}, {1,6}, {1,5}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0},
+  {0,0}, {0,0}, {2,5}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}
+ },
+ /* B */
+ {
+  {0,0}, {3,5}, {0,0}, {0,0}, {2,3}, {0,0}, {3,3}, {0,0},
+  {2,4}, {0,0}, {3,4}, {0,0}, {2,2}, {0,0}, {3,2}, {0,0},
+  {0,0}, {1,6}, {0,0}, {0,0}, {0,0}, {0,0}, {2,6}, {0,0},
+  {0,0}, {0,0}, {3,6}, {0,0}, {0,0}, {0,0}, {2,5}, {0,0}
+ }
+};
+
+
+/* Table B-5 ... B-8 variable length codes for macroblock_type in
+ *  scalable sequences
+ *
+ * not implemented
+ */
+
+/* Table B-9, variable length codes for coded_block_pattern
+ *
+ * indexed by [coded_block_pattern]
+ */
+
+static const VLCtable cbptable[64]=
+{
+  {0x01,9}, {0x0b,5}, {0x09,5}, {0x0d,6},
+  {0x0d,4}, {0x17,7}, {0x13,7}, {0x1f,8},
+  {0x0c,4}, {0x16,7}, {0x12,7}, {0x1e,8},
+  {0x13,5}, {0x1b,8}, {0x17,8}, {0x13,8},
+  {0x0b,4}, {0x15,7}, {0x11,7}, {0x1d,8},
+  {0x11,5}, {0x19,8}, {0x15,8}, {0x11,8},
+  {0x0f,6}, {0x0f,8}, {0x0d,8}, {0x03,9},
+  {0x0f,5}, {0x0b,8}, {0x07,8}, {0x07,9},
+  {0x0a,4}, {0x14,7}, {0x10,7}, {0x1c,8},
+  {0x0e,6}, {0x0e,8}, {0x0c,8}, {0x02,9},
+  {0x10,5}, {0x18,8}, {0x14,8}, {0x10,8},
+  {0x0e,5}, {0x0a,8}, {0x06,8}, {0x06,9},
+  {0x12,5}, {0x1a,8}, {0x16,8}, {0x12,8},
+  {0x0d,5}, {0x09,8}, {0x05,8}, {0x05,9},
+  {0x0c,5}, {0x08,8}, {0x04,8}, {0x04,9},
+  {0x07,3}, {0x0a,5}, {0x08,5}, {0x0c,6}
+};
+
+
+/* Table B-14, DCT coefficients table zero
+ *
+ * indexed by [run][level-1]
+ * split into two tables (dct_code_tab1, dct_code_tab2) to reduce size
+ * 'first DCT coefficient' condition and 'End of Block' are treated elsewhere
+ * codes do not include s (sign bit)
+ */
+
+static const VLCtable dct_code_tab1[2][40]=
+{
+ /* run = 0, level = 1...40 */
+ {
+  {0x03, 2}, {0x04, 4}, {0x05, 5}, {0x06, 7},
+  {0x26, 8}, {0x21, 8}, {0x0a,10}, {0x1d,12},
+  {0x18,12}, {0x13,12}, {0x10,12}, {0x1a,13},
+  {0x19,13}, {0x18,13}, {0x17,13}, {0x1f,14},
+  {0x1e,14}, {0x1d,14}, {0x1c,14}, {0x1b,14},
+  {0x1a,14}, {0x19,14}, {0x18,14}, {0x17,14},
+  {0x16,14}, {0x15,14}, {0x14,14}, {0x13,14},
+  {0x12,14}, {0x11,14}, {0x10,14}, {0x18,15},
+  {0x17,15}, {0x16,15}, {0x15,15}, {0x14,15},
+  {0x13,15}, {0x12,15}, {0x11,15}, {0x10,15}
+ },
+ /* run = 1, level = 1...18 */
+ {
+  {0x03, 3}, {0x06, 6}, {0x25, 8}, {0x0c,10},
+  {0x1b,12}, {0x16,13}, {0x15,13}, {0x1f,15},
+  {0x1e,15}, {0x1d,15}, {0x1c,15}, {0x1b,15},
+  {0x1a,15}, {0x19,15}, {0x13,16}, {0x12,16},
+  {0x11,16}, {0x10,16}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}
+ }
+};
+
+static const VLCtable dct_code_tab2[30][5]=
+{
+  /* run = 2...31, level = 1...5 */
+  {{0x05, 4}, {0x04, 7}, {0x0b,10}, {0x14,12}, {0x14,13}},
+  {{0x07, 5}, {0x24, 8}, {0x1c,12}, {0x13,13}, {0x00, 0}},
+  {{0x06, 5}, {0x0f,10}, {0x12,12}, {0x00, 0}, {0x00, 0}},
+  {{0x07, 6}, {0x09,10}, {0x12,13}, {0x00, 0}, {0x00, 0}},
+  {{0x05, 6}, {0x1e,12}, {0x14,16}, {0x00, 0}, {0x00, 0}},
+  {{0x04, 6}, {0x15,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x07, 7}, {0x11,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x05, 7}, {0x11,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x27, 8}, {0x10,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x23, 8}, {0x1a,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x22, 8}, {0x19,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x20, 8}, {0x18,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x0e,10}, {0x17,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x0d,10}, {0x16,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x08,10}, {0x15,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1f,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1a,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x19,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x17,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x16,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1f,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1e,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1d,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1c,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1b,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1f,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1e,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1d,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1c,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1b,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}}
+};
+
+
+/* Table B-15, DCT coefficients table one
+ *
+ * indexed by [run][level-1]
+ * split into two tables (dct_code_tab1a, dct_code_tab2a) to reduce size
+ * 'End of Block' is treated elsewhere
+ * codes do not include s (sign bit)
+ */
+
+static const VLCtable dct_code_tab1a[2][40]=
+{
+ /* run = 0, level = 1...40 */
+ {
+  {0x02, 2}, {0x06, 3}, {0x07, 4}, {0x1c, 5},
+  {0x1d, 5}, {0x05, 6}, {0x04, 6}, {0x7b, 7},
+  {0x7c, 7}, {0x23, 8}, {0x22, 8}, {0xfa, 8},
+  {0xfb, 8}, {0xfe, 8}, {0xff, 8}, {0x1f,14},
+  {0x1e,14}, {0x1d,14}, {0x1c,14}, {0x1b,14},
+  {0x1a,14}, {0x19,14}, {0x18,14}, {0x17,14},
+  {0x16,14}, {0x15,14}, {0x14,14}, {0x13,14},
+  {0x12,14}, {0x11,14}, {0x10,14}, {0x18,15},
+  {0x17,15}, {0x16,15}, {0x15,15}, {0x14,15},
+  {0x13,15}, {0x12,15}, {0x11,15}, {0x10,15}
+ },
+ /* run = 1, level = 1...18 */
+ {
+  {0x02, 3}, {0x06, 5}, {0x79, 7}, {0x27, 8},
+  {0x20, 8}, {0x16,13}, {0x15,13}, {0x1f,15},
+  {0x1e,15}, {0x1d,15}, {0x1c,15}, {0x1b,15},
+  {0x1a,15}, {0x19,15}, {0x13,16}, {0x12,16},
+  {0x11,16}, {0x10,16}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0},
+  {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}
+ }
+};
+
+static const VLCtable dct_code_tab2a[30][5]=
+{
+  /* run = 2...31, level = 1...5 */
+  {{0x05, 5}, {0x07, 7}, {0xfc, 8}, {0x0c,10}, {0x14,13}},
+  {{0x07, 5}, {0x26, 8}, {0x1c,12}, {0x13,13}, {0x00, 0}},
+  {{0x06, 6}, {0xfd, 8}, {0x12,12}, {0x00, 0}, {0x00, 0}},
+  {{0x07, 6}, {0x04, 9}, {0x12,13}, {0x00, 0}, {0x00, 0}},
+  {{0x06, 7}, {0x1e,12}, {0x14,16}, {0x00, 0}, {0x00, 0}},
+  {{0x04, 7}, {0x15,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x05, 7}, {0x11,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x78, 7}, {0x11,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x7a, 7}, {0x10,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x21, 8}, {0x1a,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x25, 8}, {0x19,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x24, 8}, {0x18,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x05, 9}, {0x17,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x07, 9}, {0x16,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x0d,10}, {0x15,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1f,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1a,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x19,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x17,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x16,12}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1f,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1e,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1d,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1c,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1b,13}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1f,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1e,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1d,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1c,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}},
+  {{0x1b,16}, {0x00, 0}, {0x00, 0}, {0x00, 0}, {0x00, 0}}
+};
+
+/* MPEG-4 matrices */
+static const uint8_t mpeg4_default_intra_matrix[64] = {
+  8, 17, 18, 19, 21, 23, 25, 27,
+ 17, 18, 19, 21, 23, 25, 27, 28,
+ 20, 21, 22, 23, 24, 26, 28, 30,
+ 21, 22, 23, 24, 26, 28, 30, 32,
+ 22, 23, 24, 26, 28, 30, 32, 35,
+ 23, 24, 26, 28, 30, 32, 35, 38,
+ 25, 26, 28, 30, 32, 35, 38, 41,
+ 27, 28, 30, 32, 35, 38, 41, 45,
+};
+
+static const uint8_t mpeg4_default_non_intra_matrix[64] = {
+ 16, 17, 18, 19, 20, 21, 22, 23,
+ 17, 18, 19, 20, 21, 22, 23, 24,
+ 18, 19, 20, 21, 22, 23, 24, 25,
+ 19, 20, 21, 22, 23, 24, 26, 27,
+ 20, 21, 22, 23, 25, 26, 27, 28,
+ 21, 22, 23, 24, 26, 27, 28, 30,
+ 22, 23, 24, 26, 27, 28, 30, 31,
+ 23, 24, 25, 27, 28, 30, 31, 33,
+};
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/stream_out/transrate/transrate.c ./modules/stream_out/transrate/transrate.c
--- /arno/build/vlc-1.0.5/modules/stream_out/transrate/transrate.c	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/stream_out/transrate/transrate.c	2010-02-26 14:52:41.000000000 +0100
@@ -0,0 +1,342 @@
+/*****************************************************************************
+ * transrate.c: MPEG2 video transrating module
+ *****************************************************************************
+ * Copyright (C) 2003 the VideoLAN team
+ * $Id: af73e7c2ef620e53947fb1ee04d43f1093717fbf $
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          Laurent Aimar <fenrir@via.ecp.fr>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Preamble
+ *****************************************************************************/
+#define NDEBUG 1
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <assert.h>
+#include <math.h>
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_sout.h>
+#include <vlc_input.h>
+#include <vlc_block.h>
+
+#include "transrate.h"
+
+/*****************************************************************************
+ * Exported prototypes
+ *****************************************************************************/
+static int      Open    ( vlc_object_t * );
+static void     Close   ( vlc_object_t * );
+
+static sout_stream_id_t *Add ( sout_stream_t *, es_format_t * );
+static int               Del ( sout_stream_t *, sout_stream_id_t * );
+static int               Send( sout_stream_t *, sout_stream_id_t *, block_t * );
+
+static int  transrate_video_process( sout_stream_t *, sout_stream_id_t *, block_t *, block_t ** );
+
+/*****************************************************************************
+ * Module descriptor
+ *****************************************************************************/
+
+#define VB_TEXT N_("Video bitrate")
+/*xgettext:no-c-format*/
+#define VB_LONGTEXT N_( \
+    "New target video bitrate. Quality is ok for -10/15\% of the original" \
+    "bitrate." )
+
+#define SHAPING_TEXT N_("Shaping delay")
+#define SHAPING_LONGTEXT N_( \
+    "Amount of data used for transrating in ms." )
+
+#define MPEG4_MATRIX_TEXT N_("Use MPEG4 matrix")
+#define MPEG4_MATRIX_LONGTEXT N_( \
+    "Use the MPEG4 quantification matrix." )
+
+#define SOUT_CFG_PREFIX "sout-transrate-"
+
+vlc_module_begin ()
+    set_category( CAT_SOUT )
+    set_subcategory( SUBCAT_SOUT_STREAM )
+    set_description( N_("MPEG2 video transrating stream output") )
+    set_capability( "sout stream", 50 )
+    add_shortcut( "transrate" )
+    set_shortname( N_("Transrate") )
+    set_callbacks( Open, Close )
+
+    add_integer( SOUT_CFG_PREFIX "vb", 3 * 100 * 1000, NULL,
+                 VB_TEXT, VB_LONGTEXT, false )
+    add_integer( SOUT_CFG_PREFIX "shaping", 500, NULL,
+                 SHAPING_TEXT, SHAPING_LONGTEXT, false )
+    add_bool( SOUT_CFG_PREFIX "mpeg4-matrix", false, NULL,
+              MPEG4_MATRIX_TEXT, MPEG4_MATRIX_LONGTEXT, false )
+vlc_module_end ()
+
+static const char *const ppsz_sout_options[] = {
+    "vb", "shaping", "mpeg4-matrix", NULL
+};
+
+struct sout_stream_sys_t
+{
+    sout_stream_t   *p_out;
+
+    int             i_vbitrate;
+    mtime_t         i_shaping_delay;
+    int             b_mpeg4_matrix;
+
+    mtime_t         i_dts, i_pts;
+};
+
+/*****************************************************************************
+ * Open:
+ *****************************************************************************/
+static int Open( vlc_object_t *p_this )
+{
+    sout_stream_t     *p_stream = (sout_stream_t*)p_this;
+    sout_stream_sys_t *p_sys;
+
+    p_sys = malloc( sizeof( sout_stream_sys_t ) );
+    p_sys->p_out = sout_StreamNew( p_stream->p_sout, p_stream->psz_next );
+
+    config_ChainParse( p_stream, SOUT_CFG_PREFIX, ppsz_sout_options,
+                       p_stream->p_cfg );
+    p_sys->i_vbitrate = var_CreateGetInteger( p_stream, SOUT_CFG_PREFIX "vb" );
+    if( p_sys->i_vbitrate < 16000 )
+        p_sys->i_vbitrate *= 1000;
+
+    p_sys->i_shaping_delay = var_CreateGetInteger( p_stream,
+                                SOUT_CFG_PREFIX "shaping" ) * 1000;
+    if( p_sys->i_shaping_delay <= 0 )
+    {
+        msg_Err( p_stream,
+                 "invalid shaping (%"PRId64"ms) reseting to 500ms",
+                 p_sys->i_shaping_delay / 1000 );
+        p_sys->i_shaping_delay = 500000;
+    }
+
+    p_sys->b_mpeg4_matrix = var_CreateGetBool( p_stream,
+                                               SOUT_CFG_PREFIX "mpeg4-matrix" );
+
+    msg_Dbg( p_stream, "codec video %dkb/s max gop=%"PRId64"us",
+             p_sys->i_vbitrate / 1024, p_sys->i_shaping_delay );
+
+    if( !p_sys->p_out )
+    {
+        msg_Err( p_stream, "cannot create chain" );
+        free( p_sys );
+        return VLC_EGENERIC;
+    }
+    p_stream->pf_add    = Add;
+    p_stream->pf_del    = Del;
+    p_stream->pf_send   = Send;
+
+    p_stream->p_sys     = p_sys;
+
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * Close:
+ *****************************************************************************/
+static void Close( vlc_object_t * p_this )
+{
+    sout_stream_t       *p_stream = (sout_stream_t *)p_this;
+    sout_stream_sys_t   *p_sys = p_stream->p_sys;
+
+    sout_StreamDelete( p_sys->p_out );
+    free( p_sys );
+}
+
+
+static sout_stream_id_t * Add( sout_stream_t *p_stream, es_format_t *p_fmt )
+{
+    sout_stream_sys_t   *p_sys = p_stream->p_sys;
+    sout_stream_id_t    *id;
+
+    id = malloc( sizeof( sout_stream_id_t ) );
+    id->id = NULL;
+
+    if( p_fmt->i_cat == VIDEO_ES
+            && p_fmt->i_codec == VLC_FOURCC('m', 'p', 'g', 'v') )
+    {
+        msg_Dbg( p_stream,
+                 "creating video transrating for fcc=`%4.4s'",
+                 (char*)&p_fmt->i_codec );
+
+        id->p_current_buffer = NULL;
+        id->p_next_gop = NULL;
+        id->i_next_gop_duration = 0;
+        id->i_next_gop_size = 0;
+        memset( &id->tr, 0, sizeof( transrate_t ) );
+        id->tr.bs.i_byte_in = id->tr.bs.i_byte_out = 0;
+        id->tr.mpeg4_matrix = p_sys->b_mpeg4_matrix;
+
+        /* open output stream */
+        id->id = p_sys->p_out->pf_add( p_sys->p_out, p_fmt );
+        id->b_transrate = true;
+    }
+    else
+    {
+        msg_Dbg( p_stream, "not transrating a stream (fcc=`%4.4s')", (char*)&p_fmt->i_codec );
+        id->id = p_sys->p_out->pf_add( p_sys->p_out, p_fmt );
+        id->b_transrate = false;
+
+        if( id->id == NULL )
+        {
+            free( id );
+            return NULL;
+        }
+    }
+
+    return id;
+}
+
+static int     Del      ( sout_stream_t *p_stream, sout_stream_id_t *id )
+{
+    sout_stream_sys_t   *p_sys = p_stream->p_sys;
+
+    if( id->id )
+    {
+        p_sys->p_out->pf_del( p_sys->p_out, id->id );
+    }
+    free( id );
+
+    return VLC_SUCCESS;
+}
+
+static int Send( sout_stream_t *p_stream, sout_stream_id_t *id,
+                 block_t *p_buffer )
+{
+    sout_stream_sys_t   *p_sys = p_stream->p_sys;
+
+    if( id->b_transrate )
+    {
+        block_t *p_buffer_out;
+        /* be sure to have at least 8 bytes of padding (maybe only 4) */
+        p_buffer = block_Realloc( p_buffer, 0, p_buffer->i_buffer + 8 );
+        p_buffer->i_buffer -= 8;
+        memset( &p_buffer->p_buffer[p_buffer->i_buffer], 0, 8 );
+
+        transrate_video_process( p_stream, id, p_buffer, &p_buffer_out );
+
+        if( p_buffer_out )
+        {
+            return p_sys->p_out->pf_send( p_sys->p_out, id->id, p_buffer_out );
+        }
+        return VLC_SUCCESS;
+    }
+    else if( id->id != NULL )
+    {
+        return p_sys->p_out->pf_send( p_sys->p_out, id->id, p_buffer );
+    }
+    else
+    {
+        block_Release( p_buffer );
+        return VLC_EGENERIC;
+    }
+}
+
+static int transrate_video_process( sout_stream_t *p_stream,
+               sout_stream_id_t *id, block_t *in, block_t **out )
+{
+    transrate_t    *tr = &id->tr;
+    bs_transrate_t *bs = &tr->bs;
+
+    *out = NULL;
+
+    while ( in != NULL )
+    {
+        block_t * p_next = in->p_next;
+        int i_flags = in->i_flags;
+
+        in->p_next = NULL;
+        block_ChainAppend( &id->p_next_gop, in );
+        id->i_next_gop_duration += in->i_length;
+        id->i_next_gop_size += in->i_buffer;
+        in = p_next;
+
+        if( ((i_flags & BLOCK_FLAG_TYPE_I )
+                && id->i_next_gop_duration >= 300000)
+              || (id->i_next_gop_duration > p_stream->p_sys->i_shaping_delay) )
+        {
+            mtime_t i_bitrate = (mtime_t)id->i_next_gop_size * 8000
+                                    / (id->i_next_gop_duration / 1000);
+            mtime_t i_new_bitrate;
+
+            id->tr.i_total_input = id->i_next_gop_size;
+            id->tr.i_remaining_input = id->i_next_gop_size;
+            id->tr.i_wanted_output = (p_stream->p_sys->i_vbitrate)
+                                    * (id->i_next_gop_duration / 1000) / 8000;
+            id->tr.i_current_output = 0;
+
+            id->p_current_buffer = id->p_next_gop;
+
+            while ( id->p_current_buffer != NULL )
+            {
+                block_t * p_next = id->p_current_buffer->p_next;
+                if ( !p_stream->p_sys->b_mpeg4_matrix
+                       && id->tr.i_wanted_output >= id->tr.i_total_input )
+                {
+                    bs->i_byte_out += id->p_current_buffer->i_buffer;
+                    id->p_current_buffer->p_next = NULL;
+                    block_ChainAppend( out, id->p_current_buffer );
+                }
+                else
+                {
+                    if ( process_frame( p_stream, id, id->p_current_buffer,
+                                        out, 0 ) < 0 )
+                    {
+                        id->p_current_buffer->p_next = NULL;
+                        block_ChainAppend( out, id->p_current_buffer );
+                        if ( p_stream->p_sys->b_mpeg4_matrix )
+                            id->tr.i_wanted_output = id->tr.i_total_input;
+                    }
+                    else
+                    {
+                        block_Release( id->p_current_buffer );
+                    }
+                }
+                id->p_current_buffer = p_next;
+            }
+
+            if ( id->tr.i_wanted_output < id->tr.i_total_input )
+            {
+                i_new_bitrate = (mtime_t)tr->i_current_output * 8000
+                                    / (id->i_next_gop_duration / 1000);
+                if (i_new_bitrate > p_stream->p_sys->i_vbitrate + 300000)
+                    msg_Err(p_stream, "%"PRId64" -> %"PRId64" d=%"PRId64,
+                            i_bitrate, i_new_bitrate,
+                            id->i_next_gop_duration);
+                else
+                    msg_Dbg(p_stream, "%"PRId64" -> %"PRId64" d=%"PRId64,
+                            i_bitrate, i_new_bitrate,
+                            id->i_next_gop_duration);
+            }
+
+            id->p_next_gop = NULL;
+            id->i_next_gop_duration = 0;
+            id->i_next_gop_size = 0;
+        }
+    }
+
+    return VLC_SUCCESS;
+}
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/modules/stream_out/transrate/transrate.h ./modules/stream_out/transrate/transrate.h
--- /arno/build/vlc-1.0.5/modules/stream_out/transrate/transrate.h	1970-01-01 01:00:00.000000000 +0100
+++ ./modules/stream_out/transrate/transrate.h	2010-02-26 14:52:41.000000000 +0100
@@ -0,0 +1,215 @@
+/*****************************************************************************
+ * transrate.h: MPEG2 video transrating module
+ *****************************************************************************
+ * Copyright (C) 2003 the VideoLAN team
+ * Copyright (C) 2003 Antoine Missout
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ * $Id$
+ *
+ * Authors: Christophe Massiot <massiot@via.ecp.fr>
+ *          Laurent Aimar <fenrir@via.ecp.fr>
+ *          Antoine Missout
+ *          Michel Lespinasse <walken@zoy.org>
+ *          Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*****************************************************************************
+ * sout_stream_id_t:
+ *****************************************************************************/
+
+typedef struct
+{
+    uint8_t run;
+    short level;
+} RunLevel;
+
+typedef struct
+{
+    uint8_t *p_c;
+    uint8_t *p_r;
+    uint8_t *p_w;
+    uint8_t *p_ow;
+    uint8_t *p_rw;
+
+    int i_bit_in;
+    int i_bit_out;
+    uint32_t i_bit_in_cache;
+    uint32_t i_bit_out_cache;
+
+    uint32_t i_byte_in;
+    uint32_t i_byte_out;
+} bs_transrate_t;
+
+typedef struct
+{
+    bs_transrate_t bs;
+
+    /* MPEG2 state */
+
+    // seq header
+    unsigned int horizontal_size_value;
+    unsigned int vertical_size_value;
+    uint8_t intra_quantizer_matrix [64];
+    uint8_t non_intra_quantizer_matrix [64];
+    int mpeg4_matrix;
+
+    // pic header
+    unsigned int picture_coding_type;
+
+    // pic code ext
+    unsigned int f_code[2][2];
+    /* unsigned int intra_dc_precision; */
+    unsigned int picture_structure;
+    unsigned int frame_pred_frame_dct;
+    unsigned int concealment_motion_vectors;
+    unsigned int q_scale_type;
+    unsigned int intra_vlc_format;
+    const uint8_t * scan;
+
+    // slice or mb
+    // quantizer_scale_code
+    unsigned int quantizer_scale;
+    unsigned int new_quantizer_scale;
+    unsigned int last_coded_scale;
+    int   h_offset, v_offset;
+    bool b_error;
+
+    // mb
+    double qrate;
+    int i_admissible_error, i_minimum_error;
+
+    /* input buffers */
+    ssize_t i_total_input, i_remaining_input;
+    /* output buffers */
+    ssize_t i_current_output, i_wanted_output;
+} transrate_t;
+
+
+struct sout_stream_id_t
+{
+    void            *id;
+    bool      b_transrate;
+
+    block_t         *p_current_buffer;
+    block_t           *p_next_gop;
+    mtime_t         i_next_gop_duration;
+    size_t          i_next_gop_size;
+
+    transrate_t     tr;
+};
+
+
+#ifdef HAVE_BUILTIN_EXPECT
+#define likely(x) __builtin_expect ((x) != 0, 1)
+#define unlikely(x) __builtin_expect ((x) != 0, 0)
+#else
+#define likely(x) (x)
+#define unlikely(x) (x)
+#endif
+
+#define BITS_IN_BUF (8)
+
+#define LOG(msg) fprintf (stderr, msg)
+#define LOGF(format, args...) fprintf (stderr, format, args)
+
+static inline void bs_write( bs_transrate_t *s, unsigned int val, int n )
+{
+    assert(n < 32);
+    assert(!(val & (0xffffffffU << n)));
+
+    while (unlikely(n >= s->i_bit_out))
+    {
+        s->p_w[0] = (s->i_bit_out_cache << s->i_bit_out ) | (val >> (n - s->i_bit_out));
+        s->p_w++;
+        n -= s->i_bit_out;
+        s->i_bit_out_cache = 0;
+        val &= ~(0xffffffffU << n);
+        s->i_bit_out = BITS_IN_BUF;
+    }
+
+    if (likely(n))
+    {
+        s->i_bit_out_cache = (s->i_bit_out_cache << n) | val;
+        s->i_bit_out -= n;
+    }
+
+    assert(s->i_bit_out > 0);
+    assert(s->i_bit_out <= BITS_IN_BUF);
+}
+
+static inline void bs_refill( bs_transrate_t *s )
+{
+    assert((s->p_r - s->p_c) >= 1);
+    s->i_bit_in_cache |= s->p_c[0] << (24 - s->i_bit_in);
+    s->i_bit_in += 8;
+    s->p_c++;
+}
+
+static inline void bs_flush( bs_transrate_t *s, unsigned int n )
+{
+    assert(s->i_bit_in >= n);
+
+    s->i_bit_in_cache <<= n;
+    s->i_bit_in -= n;
+
+    assert( (!n) || ((n>0) && !(s->i_bit_in_cache & 0x1)) );
+
+    while (unlikely(s->i_bit_in < 24)) bs_refill( s );
+}
+
+static inline unsigned int bs_read( bs_transrate_t *s, unsigned int n )
+{
+    unsigned int Val = ((unsigned int)s->i_bit_in_cache) >> (32 - n);
+    bs_flush( s, n );
+    return Val;
+}
+
+static inline unsigned int bs_copy( bs_transrate_t *s, unsigned int n )
+{
+    unsigned int Val = bs_read( s, n);
+    bs_write(s, Val, n);
+    return Val;
+}
+
+static inline void bs_flush_read( bs_transrate_t *s )
+{
+    int i = s->i_bit_in & 0x7;
+    if( i )
+    {
+        assert(((unsigned int)s->i_bit_in_cache) >> (32 - i) == 0);
+        s->i_bit_in_cache <<= i;
+        s->i_bit_in -= i;
+    }
+    s->p_c += -1 * (s->i_bit_in >> 3);
+    s->i_bit_in = 0;
+}
+static inline void bs_flush_write( bs_transrate_t *s )
+{
+    if( s->i_bit_out != 8 ) bs_write(s, 0, s->i_bit_out);
+}
+
+int scale_quant( transrate_t *tr, double qrate );
+int transrate_mb( transrate_t *tr, RunLevel blk[6][65], RunLevel new_blk[6][65], int i_cbp, int intra );
+void get_intra_block_B14( transrate_t *tr, RunLevel *blk );
+void get_intra_block_B15( transrate_t *tr, RunLevel *blk );
+int get_non_intra_block( transrate_t *tr, RunLevel *blk );
+void putnonintrablk( bs_transrate_t *bs, RunLevel *blk);
+void putintrablk( bs_transrate_t *bs, RunLevel *blk, int vlcformat);
+
+int process_frame( sout_stream_t *p_stream, sout_stream_id_t *id,
+                   block_t *in, block_t **out, int i_handicap );
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/p2pnext-changeversion.sh ./p2pnext-changeversion.sh
--- /arno/build/vlc-1.0.5/p2pnext-changeversion.sh	1970-01-01 01:00:00.000000000 +0100
+++ ./p2pnext-changeversion.sh	2010-02-26 14:53:04.000000000 +0100
@@ -0,0 +1,10 @@
+#!/bin/sh
+# Changes 1.0.2 and 1,0,2 encoded version # to new.
+
+for name in projects/activex/axvlc.dll.manifest projects/activex/axvlc.inf.in projects/activex/axvlc_rc.rc.in projects/mozilla/npvlc.dll.manifest projects/mozilla/npvlc_rc.rc.in ; do
+	sed -e 's/1\.0\.2/1.0.3/g' -e 's/1,0,2/1,0,3/g' $name > /tmp/rename.$$
+	/bin/mv /tmp/rename.$$ $name
+done
+
+
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/p2pnext-win32-setup-from-co.sh ./p2pnext-win32-setup-from-co.sh
--- /arno/build/vlc-1.0.5/p2pnext-win32-setup-from-co.sh	1970-01-01 01:00:00.000000000 +0100
+++ ./p2pnext-win32-setup-from-co.sh	2010-02-26 14:53:04.000000000 +0100
@@ -0,0 +1,193 @@
+#!/bin/bash
+
+# Written by Diego Andres Rabaioli, Arno Bakker
+
+# Important:
+# Check that you have installed the following tools:
+# -subversion
+# -mingw32
+# -automake
+# -libtool
+# -gettext
+# -cvs
+# -libgcrypt-dev
+#
+
+CONTRIB_NAME="contribs-0.9.9"
+CONTRIB_EXT=".tar.bz2"
+CONTRIB_URI="http://download.videolan.org/pub/videolan/testing/win32/"
+
+VLC_URI="https://svn.tribler.org/vlc/branches/plugin-1.0"
+VLC_REV="HEAD"  # HEAD = latest, set to specific revision for stability
+VLC_DIR="vlc-plugin-1.0-r$VLC_REV"
+VLC_LNK="_vlc"
+VLC_CONFIG_FLAGS="--host=i586-mingw32msvc --build=i386-linux \
+     --disable-gtk --disable-zvbi \
+     --enable-nls --enable-sdl --with-sdl-config-path=/usr/win32/bin \
+     --enable-faad --enable-flac --enable-theora \
+     --with-wx-config-path=/usr/win32/bin \
+     --with-freetype-config-path=/usr/win32/bin \
+     --with-fribidi-config-path=/usr/win32/bin \
+     --with-libgcrypt-prefix=/usr/win32 \
+     --disable-live555 --disable-caca \
+     --with-xml2-config-path=/usr/win32/bin \
+     --with-dvdnav-config-path=/usr/win32/bin \
+     --disable-cddax --disable-vcdx --enable-goom \
+     --enable-twolame --disable-dvdread \
+     --enable-debug --disable-swscale --disable-mad --disable-a52 --disable-dca \
+     --disable-qt4 --disable-skins2 --disable-atmo --enable-mozilla --with-mozilla-sdk-path=/usr/win32/gecko-sdk"
+
+
+# Build the environment
+build_env ()
+{
+  # VLC Contrib
+  p_head "Checking VLC CONTRIB is installed in /usr/win32"
+  if [ ! -d /usr/win32 ] ;
+  then
+      wget "$CONTRIB_URI$CONTRIB_NAME$CONTRIB_EXT"
+      echo "Please unpack $CONTRIB_NAME$CONTRIB_EXT as root from / to create /usr/win32"
+      exit 0
+  fi
+
+  # VLC
+  p_head "Installing VLC"
+  # Downloading
+  svn checkout $VLC_URI -r $VLC_REV $VLC_DIR
+  ln -s $VLC_DIR $VLC_LNK
+
+  echo
+  echo "The environment is ready. It's possible to compile Vlc now"
+  echo -n "Do you want to compile Vlc now? [y/n] "
+  read choise
+  if [ "$choise" = "y" ]; then
+    build_vlc
+  fi
+}
+
+# Clean the environment
+clean_env ()
+{
+  echo "This operation will delete the following files and directories:"
+  echo
+  echo "$CONTRIB_NAME"
+  echo "$CONTRIB_NAME$CONTRIB_EXT"
+  echo "$VLC_DIR"
+  echo "$VLC_LNK"
+  echo
+
+  echo -n "Are you sure you want to continue? [y/n] "
+  read choise
+  if [ "$choise" = "y" ]; then
+    p_head "Cleaning Environment"
+    rm -rf "$CONTRIB_NAME" "$CONTRIB_NAME$CONTRIB_EXT" "$VLC_DIR" "$VLC_LNK"
+  fi
+}
+
+# Build Vlc
+build_vlc ()
+{
+  # Bootstrap
+  p_head "Bootstrapping Vlc "
+  export PKG_CONFIG_PATH=/usr/win32/lib/pkgconfig
+  export CPPFLAGS="-I/usr/win32/include -I/usr/win32/include/ebml"
+  export LDFLAGS="-L/usr/win32/lib"
+  export CC=i586-mingw32msvc-gcc
+  export CXX=i586-mingw32msvc-g++
+  export CXXCPP=i586-mingw32msvc-cpp
+  cd $VLC_LNK
+  ./bootstrap
+  if [ $? -ne 0 ]; then
+    p_error "Error in bootstrapping Vlc."
+    exit 1
+  fi
+
+  # Configure
+  p_head "Configuring Vlc"
+  ./configure $VLC_CONFIG_FLAGS
+  if [ $? -ne 0 ]; then
+    p_error "Error in configuring Vlc."
+    exit 1
+  fi
+
+  # Make
+  p_head "Making Vlc"
+  make
+  if [ $? -ne 0 ]; then
+    p_error "Error in making Vlc."
+    exit 1
+  fi
+  cd ..
+
+}
+
+# Clean Vlc
+clean_vlc ()
+{
+  echo
+  echo "This operation will clean your Vlc source tree"
+  echo -n "Are you sure you want to continue? [y/n] "
+  read choise
+  if [ "$choise" = "y" ]; then
+    p_head "Cleaning Vlc"
+    cd _vlc
+    make clean
+    make distclean
+    cd ..
+  fi
+
+}
+
+# Print Header Utlity
+p_head ()
+{
+  echo
+  echo -en '\E[37;44m' "$1"; tput sgr0
+  echo
+  echo
+}
+
+# Print Header Utlity
+p_error ()
+{
+  echo
+  echo -en '\E[37;41m' "$1"; tput sgr0
+  echo
+  echo
+}
+
+
+# MAIN
+echo
+select selection in "build environment" "clean environment" "build vlc" "clean vlc"
+do
+  echo
+  case "$selection" in
+    "build environment" )
+    build_env
+    ;;
+
+    "clean environment" )
+    clean_env
+    ;;
+
+    "build vlc" )
+    build_vlc
+    ;;
+
+    "clean vlc" )
+    clean_vlc
+    ;;
+
+    * )
+      echo "inconsistent selection"
+    ;;
+  esac
+  break
+done
+
+p_head "Done."
+
+exit 0
+
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/axvlc.dll.manifest ./projects/activex/axvlc.dll.manifest
--- /arno/build/vlc-1.0.5/projects/activex/axvlc.dll.manifest	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/axvlc.dll.manifest	2010-02-26 14:53:02.000000000 +0100
@@ -1,10 +1,10 @@
 <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
 <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
 	<assemblyIdentity
-		version="1.0.0.0"
+		version="1.0.5.0"
 		processorArchitecture="x86"
 		name="axvlc.dll"
 		type="win32"
 	/>
-	<description>VLC ActiveX plugin</description>
+	<description>SwarmPlugin P2P Multimedia ActiveX plugin</description>
 </assembly>
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/axvlc.idl ./projects/activex/axvlc.idl
--- /arno/build/vlc-1.0.5/projects/activex/axvlc.idl	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/axvlc.idl	2010-02-26 14:53:02.000000000 +0100
@@ -216,8 +216,8 @@
 
     [
       odl,
-      uuid(49E0DBD1-9440-466C-9C97-95C67190C603),
-      helpstring("VLC Input APIs"),
+	  uuid(8C8EF0C0-1A2E-11DF-A9E1-0002A5D5C51B), // P2P-Next, another new UUID, 2010-02-15 
+      helpstring("P2P-Next extended VLC Input APIs"),
       dual,
       oleautomation
     ]
@@ -249,6 +249,14 @@
 
         [propget, helpstring("Returns whether current playback displays video.")]
         HRESULT hasVout([out, retval] VARIANT_BOOL* hasVout);
+
+		// P2P-Next
+        [propget, helpstring("Returns last NSSA INFO message")]
+        HRESULT p2pstatus([out, retval] BSTR* p2pstatus);
+
+		// P2P-Next, 2010-02-15
+        [helpstring("Add a playlist item.")]
+        HRESULT set_p2ptarget([in] BSTR uri, [out, retval] long* itemId);
     };
 
     [
@@ -530,7 +538,7 @@
     };
 
     [
-      uuid(E23FE9C6-778E-49D4-B537-38FCDE4887D8),
+      uuid(045E7BEE-6F8F-44cf-AFF1-52710C6209FE),
       helpstring("VLC control (deprecated)"),
       control
     ]
@@ -542,8 +550,9 @@
     };
 
     [
-      uuid(9BE31822-FDAD-461B-AD51-BE1D1C159921),
-      helpstring("VLC control"),
+      uuid(1800B8AF-4E33-43C0-AFC7-894433C13538),
+
+      helpstring("SwarmPlugin control"),
       control
     ]
     coclass VLCPlugin2
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/axvlc_idl.c ./projects/activex/axvlc_idl.c
--- /arno/build/vlc-1.0.5/projects/activex/axvlc_idl.c	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/axvlc_idl.c	2010-02-26 14:53:02.000000000 +0100
@@ -6,7 +6,7 @@
 
 
  /* File created by MIDL compiler version 7.00.0500 */
-/* at Fri Apr 25 11:37:37 2008
+/* at Mon Feb 15 13:55:55 2010
  */
 /* Compiler settings for axvlc.idl:
     Oicf, W1, Zp8, env=Win32 (32b run)
@@ -76,7 +76,7 @@
 MIDL_DEFINE_GUID(IID, IID_IVLCAudio,0x9E0BD17B,0x2D3C,0x4656,0xB9,0x4D,0x03,0x08,0x4F,0x3F,0xD9,0xD4);
 
 
-MIDL_DEFINE_GUID(IID, IID_IVLCInput,0x49E0DBD1,0x9440,0x466C,0x9C,0x97,0x95,0xC6,0x71,0x90,0xC6,0x03);
+MIDL_DEFINE_GUID(IID, IID_IVLCInput,0x8C8EF0C0,0x1A2E,0x11DF,0xA9,0xE1,0x00,0x02,0xA5,0xD5,0xC5,0x1B);
 
 
 MIDL_DEFINE_GUID(IID, IID_IVLCLog,0x8E3BC3D9,0x62E9,0x48FB,0x8A,0x6D,0x99,0x3F,0x9A,0xBC,0x4A,0x0A);
@@ -106,10 +106,10 @@
 MIDL_DEFINE_GUID(IID, IID_IVLCPlaylistItems,0xFD37FE32,0x82BC,0x4A25,0xB0,0x56,0x31,0x5F,0x4D,0xBB,0x19,0x4D);
 
 
-MIDL_DEFINE_GUID(CLSID, CLSID_VLCPlugin,0xE23FE9C6,0x778E,0x49D4,0xB5,0x37,0x38,0xFC,0xDE,0x48,0x87,0xD8);
+MIDL_DEFINE_GUID(CLSID, CLSID_VLCPlugin,0x045E7BEE,0x6F8F,0x44cf,0xAF,0xF1,0x52,0x71,0x0C,0x62,0x09,0xFE);
 
 
-MIDL_DEFINE_GUID(CLSID, CLSID_VLCPlugin2,0x9BE31822,0xFDAD,0x461B,0xAD,0x51,0xBE,0x1D,0x1C,0x15,0x99,0x21);
+MIDL_DEFINE_GUID(CLSID, CLSID_VLCPlugin2,0x1800B8AF,0x4E33,0x43C0,0xAF,0xC7,0x89,0x44,0x33,0xC1,0x35,0x38);
 
 #undef MIDL_DEFINE_GUID
 
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/axvlc_idl.h ./projects/activex/axvlc_idl.h
--- /arno/build/vlc-1.0.5/projects/activex/axvlc_idl.h	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/axvlc_idl.h	2010-02-26 14:53:03.000000000 +0100
@@ -4,7 +4,7 @@
 
 
  /* File created by MIDL compiler version 7.00.0500 */
-/* at Fri Apr 25 11:37:37 2008
+/* at Mon Feb 15 13:55:55 2010
  */
 /* Compiler settings for axvlc.idl:
     Oicf, W1, Zp8, env=Win32 (32b run)
@@ -852,7 +852,7 @@
 
 #if defined(__cplusplus) && !defined(CINTERFACE)
     
-    MIDL_INTERFACE("49E0DBD1-9440-466C-9C97-95C67190C603")
+    MIDL_INTERFACE("8C8EF0C0-1A2E-11DF-A9E1-0002A5D5C51B")
     IVLCInput : public IDispatch
     {
     public:
@@ -886,6 +886,13 @@
         virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasVout( 
             /* [retval][out] */ VARIANT_BOOL *hasVout) = 0;
         
+        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_p2pstatus( 
+            /* [retval][out] */ BSTR *p2pstatus) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE set_p2ptarget( 
+            /* [in] */ BSTR uri,
+            /* [retval][out] */ long *itemId) = 0;
+        
     };
     
 #else 	/* C style interface */
@@ -975,6 +982,15 @@
             IVLCInput * This,
             /* [retval][out] */ VARIANT_BOOL *hasVout);
         
+        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_p2pstatus )( 
+            IVLCInput * This,
+            /* [retval][out] */ BSTR *p2pstatus);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *set_p2ptarget )( 
+            IVLCInput * This,
+            /* [in] */ BSTR uri,
+            /* [retval][out] */ long *itemId);
+        
         END_INTERFACE
     } IVLCInputVtbl;
 
@@ -1041,6 +1057,12 @@
 #define IVLCInput_get_hasVout(This,hasVout)	\
     ( (This)->lpVtbl -> get_hasVout(This,hasVout) ) 
 
+#define IVLCInput_get_p2pstatus(This,p2pstatus)	\
+    ( (This)->lpVtbl -> get_p2pstatus(This,p2pstatus) ) 
+
+#define IVLCInput_set_p2ptarget(This,uri,itemId)	\
+    ( (This)->lpVtbl -> set_p2ptarget(This,uri,itemId) ) 
+
 #endif /* COBJMACROS */
 
 
@@ -2171,12 +2193,6 @@
         virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MRL( 
             /* [in] */ BSTR mrl) = 0;
         
-        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Toolbar( 
-            /* [retval][out] */ VARIANT_BOOL *visible) = 0;
-        
-        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Toolbar( 
-            /* [in] */ VARIANT_BOOL visible) = 0;
-        
         virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_VersionInfo( 
             /* [retval][out] */ BSTR *version) = 0;
         
@@ -2198,6 +2214,12 @@
         virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
             /* [in] */ OLE_COLOR backcolor) = 0;
         
+        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Toolbar( 
+            /* [retval][out] */ VARIANT_BOOL *visible) = 0;
+        
+        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Toolbar( 
+            /* [in] */ VARIANT_BOOL visible) = 0;
+        
         virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_audio( 
             /* [retval][out] */ IVLCAudio **obj) = 0;
         
@@ -2302,14 +2324,6 @@
             IVLCControl2 * This,
             /* [in] */ BSTR mrl);
         
-        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Toolbar )( 
-            IVLCControl2 * This,
-            /* [retval][out] */ VARIANT_BOOL *visible);
-        
-        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Toolbar )( 
-            IVLCControl2 * This,
-            /* [in] */ VARIANT_BOOL visible);
-        
         /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VersionInfo )( 
             IVLCControl2 * This,
             /* [retval][out] */ BSTR *version);
@@ -2338,6 +2352,14 @@
             IVLCControl2 * This,
             /* [in] */ OLE_COLOR backcolor);
         
+        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Toolbar )( 
+            IVLCControl2 * This,
+            /* [retval][out] */ VARIANT_BOOL *visible);
+        
+        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Toolbar )( 
+            IVLCControl2 * This,
+            /* [in] */ VARIANT_BOOL visible);
+        
         /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_audio )( 
             IVLCControl2 * This,
             /* [retval][out] */ IVLCAudio **obj);
@@ -2424,12 +2446,6 @@
 #define IVLCControl2_put_MRL(This,mrl)	\
     ( (This)->lpVtbl -> put_MRL(This,mrl) ) 
 
-#define IVLCControl2_get_Toolbar(This,visible)	\
-    ( (This)->lpVtbl -> get_Toolbar(This,visible) ) 
-
-#define IVLCControl2_put_Toolbar(This,visible)	\
-    ( (This)->lpVtbl -> put_Toolbar(This,visible) ) 
-
 #define IVLCControl2_get_VersionInfo(This,version)	\
     ( (This)->lpVtbl -> get_VersionInfo(This,version) ) 
 
@@ -2451,6 +2467,12 @@
 #define IVLCControl2_put_BackColor(This,backcolor)	\
     ( (This)->lpVtbl -> put_BackColor(This,backcolor) ) 
 
+#define IVLCControl2_get_Toolbar(This,visible)	\
+    ( (This)->lpVtbl -> get_Toolbar(This,visible) ) 
+
+#define IVLCControl2_put_Toolbar(This,visible)	\
+    ( (This)->lpVtbl -> put_Toolbar(This,visible) ) 
+
 #define IVLCControl2_get_audio(This,obj)	\
     ( (This)->lpVtbl -> get_audio(This,obj) ) 
 
@@ -2727,7 +2749,7 @@
 
 #ifdef __cplusplus
 
-class DECLSPEC_UUID("E23FE9C6-778E-49D4-B537-38FCDE4887D8")
+class DECLSPEC_UUID("045E7BEE-6F8F-44cf-AFF1-52710C6209FE")
 VLCPlugin;
 #endif
 
@@ -2735,7 +2757,7 @@
 
 #ifdef __cplusplus
 
-class DECLSPEC_UUID("9BE31822-FDAD-461B-AD51-BE1D1C159921")
+class DECLSPEC_UUID("1800B8AF-4E33-43C0-AFC7-894433C13538")
 VLCPlugin2;
 #endif
 #endif /* __AXVLC_LIBRARY_DEFINED__ */
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/axvlc.inf.in ./projects/activex/axvlc.inf.in
--- /arno/build/vlc-1.0.5/projects/activex/axvlc.inf.in	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/axvlc.inf.in	2010-02-26 14:53:02.000000000 +0100
@@ -1,4 +1,6 @@
 ; Version number and signature of INF file.
+; Written by Diego Andres Rabaioli
+; see LICENSE.txt for license information
 ;
 [version]
   signature="$CHICAGO$"
@@ -6,18 +8,17 @@
 
 [Add.Code]
   axvlc.dll=axvlc.dll
-  vlc-@VERSION@-win32.exe=vlc-@VERSION@-win32.exe
+  SwarmPlugin_1.0.5.exe=SwarmPlugin_1.0.5.exe
 
 [axvlc.dll]
-  FileVersion=@VERSION_MAJOR@,@VERSION_MINOR@,@VERSION_REVISION@,0
-  clsid={9BE31822-FDAD-461B-AD51-BE1D1C159921}
+  FileVersion=1,0,5,0
+  clsid={1800B8AF-4E33-43C0-AFC7-894433C13538}
   RegisterServer=no
   Hook=runinstaller
 
-[vlc-@VERSION@-win32.exe]
-  FileVersion=@VERSION_MAJOR@,@VERSION_MINOR@,@VERSION_REVISION@,0
-  file-win32-x86=http://downloads.videolan.org/pub/videolan/vlc/@VERSION@/win32/vlc-@VERSION@-win32.exe
+[SwarmPlugin_1.0.5.exe]
+  FileVersion=1,0,5,0
+  file-win32-x86=http://trial.p2p-next.org/Beta/SwarmPlugin_1.0.5.exe
 
 [runinstaller]
-  run=%EXTRACT_DIR%\vlc-@VERSION@-win32.exe
-
+  run=%EXTRACT_DIR%\SwarmPlugin_1.0.5.exe
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/axvlc_rc.rc.in ./projects/activex/axvlc_rc.rc.in
--- /arno/build/vlc-1.0.5/projects/activex/axvlc_rc.rc.in	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/axvlc_rc.rc.in	2010-02-26 14:53:02.000000000 +0100
@@ -1,4 +1,4 @@
-#define VERSION_NUMBER @VERSION_MAJOR@,@VERSION_MINOR@,@VERSION_REVISION@,@VERSION_EXTRA_RC@
+#define VERSION_NUMBER 1,0,5,0
 
 1 BITMAP "vlc16x16.bmp"
 1 VERSIONINFO
@@ -11,10 +11,10 @@
   BEGIN
     BLOCK "040904E4"
     BEGIN
-      VALUE "CompanyName", "the VideoLAN Team"
-      VALUE "FileVersion", "@VERSION@"
-      VALUE "FileDescription", "VLC media player (Activex Plugin)"
-      VALUE "LegalCopyright", "(c) @COPYRIGHT_YEARS@ the VideoLAN Team"
+      VALUE "CompanyName", "the VideoLAN Team and P2P-Next project"
+      VALUE "FileVersion", "1.0.5"
+      VALUE "FileDescription", "SwarmPlugin Version 1.0.5, Copyright (c) 2009-2010, the VideoLAN Team and Delft University of Technology<br><a href=""http://www.pds.ewi.tudelft.nl/code.html"">http://www.pds.ewi.tudelft.nl/code.html</a>"
+      VALUE "LegalCopyright", "Copyright \251 2009-2010 the VideoLAN Team and Delft University of Technology"
       VALUE "OLESelfRegister", "\0"
     END
   END
Binary files /arno/build/vlc-1.0.5/projects/activex/axvlc.tlb and ./projects/activex/axvlc.tlb differ
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/main.cpp ./projects/activex/main.cpp
--- /arno/build/vlc-1.0.5/projects/activex/main.cpp	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/main.cpp	2010-02-26 14:53:02.000000000 +0100
@@ -34,9 +34,9 @@
 
 using namespace std;
 
-#define COMPANY_STR "VideoLAN"
-#define PROGRAM_STR "VLCPlugin"
-#define DESCRIPTION "VideoLAN VLC ActiveX Plugin"
+#define COMPANY_STR "P2PNext"
+#define PROGRAM_STR "SwarmPlugin"
+#define DESCRIPTION "SwarmPlayer ActiveX Plugin"
 
 #define THREADING_MODEL "Apartment"
 #define MISC_STATUS     "131473"
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/Makefile.am ./projects/activex/Makefile.am
--- /arno/build/vlc-1.0.5/projects/activex/Makefile.am	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/Makefile.am	2010-02-26 14:53:03.000000000 +0100
@@ -42,6 +42,8 @@
     vlccontrol2.h \
     plugin.cpp \
     plugin.h \
+    p2pcontrol.cpp \
+    p2pcontrol.h \
     axvlc_idl.c \
     axvlc_idl.h \
     guiddef.h \
@@ -75,7 +77,7 @@
 axvlc_la_CXXFLAGS = `$(VLC_CONFIG) --cxxflags activex`
 axvlc_la_DEPENDENCIES = axvlc.def $(DATA_axvlc_rc) $(LIBRARIES_libvlc)
 axvlc_la_LDFLAGS = -Wl,$(srcdir)/axvlc.def -Wl,$(DATA_axvlc_rc) \
-    -no-undefined -avoid-version -module \
+    -no-undefined -avoid-version -module -lws2_32 \
     `$(VLC_CONFIG) --ldflags activex libvlc`
 axvlc_la_LIBADD = $(LIBRARIES_libvlc) \
 	`$(VLC_CONFIG) -libs activex`
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/Makefile.in ./projects/activex/Makefile.in
--- /arno/build/vlc-1.0.5/projects/activex/Makefile.in	2010-01-24 22:28:52.000000000 +0100
+++ ./projects/activex/Makefile.in	2010-02-26 14:53:02.000000000 +0100
@@ -94,7 +94,7 @@
 	objectsafety.h dataobject.cpp dataobject.h viewobject.cpp \
 	viewobject.h supporterrorinfo.cpp supporterrorinfo.h \
 	vlccontrol.cpp vlccontrol.h vlccontrol2.cpp vlccontrol2.h \
-	plugin.cpp plugin.h axvlc_idl.c axvlc_idl.h guiddef.h
+	plugin.cpp plugin.h p2pcontrol.cpp p2pcontrol.h axvlc_idl.c axvlc_idl.h guiddef.h
 am__objects_1 = axvlc_la-main.lo axvlc_la-utils.lo \
 	axvlc_la-olecontrol.lo axvlc_la-oleinplaceactiveobject.lo \
 	axvlc_la-oleinplaceobject.lo axvlc_la-oleobject.lo \
@@ -103,7 +103,7 @@
 	axvlc_la-connectioncontainer.lo axvlc_la-objectsafety.lo \
 	axvlc_la-dataobject.lo axvlc_la-viewobject.lo \
 	axvlc_la-supporterrorinfo.lo axvlc_la-vlccontrol.lo \
-	axvlc_la-vlccontrol2.lo axvlc_la-plugin.lo \
+	axvlc_la-vlccontrol2.lo axvlc_la-plugin.lo axvlc_la-p2pcontrol.lo \
 	axvlc_la-axvlc_idl.lo
 @BUILD_ACTIVEX_TRUE@am_axvlc_la_OBJECTS = $(am__objects_1)
 axvlc_la_OBJECTS = $(am_axvlc_la_OBJECTS)
@@ -738,6 +738,8 @@
     vlccontrol2.h \
     plugin.cpp \
     plugin.h \
+    plugin.cpp \
+    plugin.h \
     axvlc_idl.c \
     axvlc_idl.h \
     guiddef.h \
@@ -872,6 +874,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-persiststorage.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-persiststreaminit.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-plugin.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-p2pcontrol.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-provideclassinfo.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-supporterrorinfo.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/axvlc_la-utils.Plo@am__quote@
@@ -1054,6 +1057,15 @@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(axvlc_la_CXXFLAGS) $(CXXFLAGS) -c -o axvlc_la-plugin.lo `test -f 'plugin.cpp' || echo '$(srcdir)/'`plugin.cpp
 
+
+axvlc_la-p2pcontrol.lo: p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(axvlc_la_CXXFLAGS) $(CXXFLAGS) -MT axvlc_la-p2pcontrol.lo -MD -MP -MF $(DEPDIR)/axvlc_la-p2pcontrol.Tpo -c -o axvlc_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/axvlc_la-p2pcontrol.Tpo $(DEPDIR)/axvlc_la-p2pcontrol.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='p2pcontrol.cpp' object='axvlc_la-p2pcontrol.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(axvlc_la_CXXFLAGS) $(CXXFLAGS) -c -o axvlc_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+
+
 mostlyclean-libtool:
 	-rm -f *.lo
 
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/p2pcontrol.cpp ./projects/activex/p2pcontrol.cpp
--- /arno/build/vlc-1.0.5/projects/activex/p2pcontrol.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ./projects/activex/p2pcontrol.cpp	2010-02-26 14:53:02.000000000 +0100
@@ -0,0 +1,505 @@
+/* 
+ * Written by Diego Andres Rabaioli
+ * see P2P-Next-LICENSE.txt for license information
+ */
+
+#include "p2pcontrol.h"
+#include <string>
+
+#define P_DEBUG
+
+#ifdef P_DEBUG
+#include <stdio.h>
+#include <stdarg.h>
+#endif
+
+////////
+// TODO : Diego : Just for debug... remove it or move to vlc log system
+////////
+void writeOnLog( const char * msg, ... )
+{
+#ifdef P_DEBUG
+  static std::string logPath = "";
+
+  if( logPath.empty() )
+  {
+    char   tmp[256];
+    LONG   result;
+    HKEY   hKey;
+    WCHAR  Logpath[256]; // TODO : Fix this
+    DWORD  bufLen = sizeof( Logpath );
+
+    // Look in the Windows registry for installation path
+    result = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PLUGIN_REG_KEY, 0, KEY_QUERY_VALUE, &hKey );
+    if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return; }
+    result = RegQueryValueEx( hKey, LOG_PATH_ELEMENT, NULL, NULL, (LPBYTE)Logpath, &bufLen);
+    if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return; }
+    RegCloseKey( hKey );
+    wcstombs( tmp, Logpath, 256 );
+    logPath.assign( tmp );
+    logPath.append( "\\" );
+    logPath.append( LOG_FILE_NAME );
+  }
+
+  if( ! logPath.empty() )
+  {
+    FILE * file;
+    file = fopen( logPath.c_str(), "a" );
+    if( file == NULL ) return;
+
+    va_list args;
+    va_start( args, msg );
+    vfprintf( file, msg, args );
+    va_end( args );
+    fputs( "\r\n", file );
+    fclose( file );
+  }
+#endif
+};
+
+// Thread parameters
+typedef struct {
+  BGPConnection  * connection;
+  event_cb_map_t * eventMap;
+  HANDLE *         syncEvent;
+  HANDLE *         syncMutex;
+} ThreadParams;
+
+
+///////////////////////////
+// BGPConnection
+///////////////////////////
+BGPConnection::BGPConnection( const int port, const std::string bgAddress )
+{
+  mBGAddress   = bgAddress;
+  mPort        = port;
+  mSocketState = S_DOWN;
+}
+
+///////////////////////////
+BGPConnection::~BGPConnection()
+{
+  disconnect();
+}
+
+///////////////////////////
+bool BGPConnection::connect()
+{
+  WSADATA            wsaData;
+  struct sockaddr_in serverAddress;
+  int                iResult;
+
+  // Just to be in a consistent state
+  if( mSocketState == S_UP )
+    return true;
+  else if( mSocketState != S_DOWN )
+    disconnect();
+
+  // Init Winsock
+  iResult = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
+  if( iResult != 0 )
+    return disconnect();
+
+  mSocketState = S_STARTED;
+
+  // Create socket
+  if( ( mServerSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) == INVALID_SOCKET )
+    return disconnect();
+
+  mSocketState = S_CREATED;
+
+  memset( &serverAddress, 0, sizeof( serverAddress ) );
+  serverAddress.sin_family      = AF_INET;
+  serverAddress.sin_port        = htons( mPort );
+  serverAddress.sin_addr.s_addr = inet_addr( mBGAddress.c_str() );
+
+  // Connect to the BG process server
+  if( ( ::connect( mServerSocket, (struct sockaddr *)&serverAddress,
+                 sizeof( serverAddress ) ) ) == SOCKET_ERROR )
+  {
+    writeOnLog( "BGPConnection: Could not connect to server" );
+    writeOnLog( "%i Socket Server : %i Server Addres : %i", WSAGetLastError(), mServerSocket, serverAddress.sin_addr.s_addr );
+    return disconnect();
+  }
+
+  writeOnLog( "BGPConnection: CONNECTED" );
+
+  mSocketState = S_UP;
+  return true;
+
+}
+
+///////////////////////////
+bool BGPConnection::disconnect()
+{
+// Shut down the connection depending on the state of the socket
+// It basically returns always false (stupid code optimization reason)
+  #ifdef P_DEBUG_2
+  writeOnLog( "BGPConnection: Shutting down connection from status %d", mSocketState );
+  #endif
+
+  if( mSocketState == S_DOWN )
+    return false;
+
+  if( mSocketState >= S_CREATED )
+  {
+    closesocket( mServerSocket );
+    mServerSocket = INVALID_SOCKET;
+  }
+
+  WSACleanup();
+  mSocketState = S_DOWN;
+  return false;
+}
+
+///////////////////////////
+bool BGPConnection::sendMsg( const std::string & message ) const
+{
+  int res;
+
+  // Check socket status
+  if( mSocketState != S_UP )
+    return false;
+
+  // Complete message
+  std::string msg = message + "\r\n";
+  // Send Request
+  res = send( mServerSocket, msg.c_str(), msg.length(), 0 );
+  writeOnLog( "BGPConnection: Sending: %s", message.c_str() );
+
+  if( res == SOCKET_ERROR )
+  {
+    writeOnLog( "BGPConnection: Error in sending message" );
+    return false;
+  }
+
+  return true;
+}
+
+///////////////////////////
+bool BGPConnection::recvMsg( std::string & message ) const
+{
+  char inBuffer[ IN_BUF_LEN ];
+  int  res;
+
+  if( mSocketState != S_UP )
+    return false;
+
+  message = "";
+  while( true )
+  {
+    res = recv( mServerSocket, inBuffer, IN_BUF_LEN, 0 );
+
+    if( res <= 0 )
+    {
+      writeOnLog( "BGPConnection: Error in receiving" );
+      message = "SHUTDOWN";
+      return false;
+    }
+
+    message.append( inBuffer, res );
+    if( ! message.compare( message.size() - 2, 2, "\r\n" ) )
+      break;
+  }
+  // Trim "\r\n"
+  message.erase( message.size() - 2 );
+
+  writeOnLog( "BGPConnection: RECEIVED : %s", message.c_str() );
+
+  return true;
+}
+
+///////////////////////////
+// P2PControl
+///////////////////////////
+P2PControl::P2PControl( const int port, const std::string bgAddress ) :
+  mEventCBMap(), mProtoState( P_DOWN ) 
+{
+  mConnection  = new BGPConnection( port, bgAddress );
+  mEventThread = NULL;
+}
+
+///////////////////////////
+P2PControl::~P2PControl()
+{
+  shutdown();
+}
+
+///////////////////////////
+bool P2PControl::startup()
+{
+  writeOnLog( "P2PControl::starting up..." );
+
+  // Check if communication protocol is already up.
+  if( mProtoState == P_UP )
+    return true;
+
+  // Try to connect to the BG Process. If it doesn't succeed then
+  // try to start the BG Process and try to connect againg.
+  if( ! mConnection->connect() )
+    if( ! startBGProcess() || ! mConnection->connect() )
+      return mConnection->disconnect();
+
+  // Check if the thread is already running.
+  if( mEventThread != NULL )
+    return true;
+
+  // Init syncronization event
+  mSyncEvent = CreateEvent( NULL, false, false, NULL );
+  if( mSyncEvent == NULL )
+  { writeOnLog( "P2PControl: Error in creating syncronization event" ); return false; }
+
+  // Init syncronization mutex
+  mSyncMutex = CreateMutex( NULL, false, NULL );
+  if( mSyncMutex == NULL )
+  { writeOnLog( "P2PControl: Error in creating syncronization mutex" ); return false; }
+
+  // Init the thread arguments
+  ThreadParams * threadParams = new ThreadParams;
+  threadParams->connection    = mConnection;
+  threadParams->eventMap      = &mEventCBMap;
+  threadParams->syncEvent     = &mSyncEvent;
+  threadParams->syncMutex     = &mSyncMutex;
+
+  // Start the Event Loop
+  mEventThread = CreateThread( NULL,
+                               0,
+                               &eventLoop,
+                               threadParams,
+                               0,
+                               NULL );
+
+  if( mEventThread == NULL )
+  {
+    writeOnLog( "P2PControl: Could not start event loop thread" );
+    delete threadParams;
+    return false;
+  }
+
+  // After the BG Process starts up, a notification event is sent to
+  // the plug-in, it means we are now able to connect to the BG.
+  // Just wait for it.
+  if( WaitForSingleObject( mSyncEvent, INFINITE ) != WAIT_OBJECT_0 )
+    writeOnLog( "Sync Error while Starting up the event thread" );
+
+  delete threadParams;
+
+  mProtoState = P_UP;
+
+  return true;
+}
+
+///////////////////////////
+bool P2PControl::shutdown()
+{
+  // Send a shutdown request to the BG and wait
+  // to receive the syncronization event back.
+  DWORD res;
+  mConnection->sendMsg( "SHUTDOWN" );
+  res = WaitForSingleObject( mSyncEvent, 2000 );
+  if( res == WAIT_TIMEOUT ) writeOnLog( "Sync Error while closing thread" );
+  else writeOnLog( "P2PControl: Thread cleanly exited" );
+
+  // Close all handlers and prepare to exit.
+  CloseHandle( mEventThread );
+  CloseHandle( mSyncEvent );
+  CloseHandle( mSyncMutex );
+  delete mConnection;
+  mProtoState = P_DOWN;
+
+  return true;
+}
+
+///////////////////////////
+bool P2PControl::startBGProcess()
+{
+  LONG         result;
+  HKEY         hKey;
+  WCHAR        BGpath[256]; // TODO : Fix this
+  DWORD        bufLen = sizeof( BGpath );
+
+  // Look in the Windows registry to get the path of the BG
+  result = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PLUGIN_REG_KEY, 0, KEY_QUERY_VALUE, &hKey );
+  if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return false; }
+  result = RegQueryValueEx( hKey, BG_PATH_ELEMENT, NULL, NULL, (LPBYTE)BGpath, &bufLen);
+  if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return false; }
+  RegCloseKey( hKey );
+
+  // Set up variables
+  STARTUPINFOW        startupInfo;
+  PROCESS_INFORMATION processInfo;
+  memset( &startupInfo, 0, sizeof( startupInfo ) );
+  memset( &processInfo, 0, sizeof( processInfo ) );
+  startupInfo.cb = sizeof( startupInfo );
+
+  writeOnLog( "Starting BG Process..." );
+  // Finally start the BG Process
+  bool started = CreateProcess( BGpath,
+                                NULL,
+                                NULL,
+                                NULL,
+                                false,
+                                CREATE_NO_WINDOW,
+                                NULL,
+                                NULL,
+                                &startupInfo,
+                                &processInfo );
+
+  // Wait the process to startup and send a 'startup' event
+  HANDLE startupEvent = CreateEvent( NULL, false, false, L"startupEvent" );
+  if( startupEvent == NULL )
+  {
+    writeOnLog( "P2PControl: Error in creating syncronization event: Could not create BG Process" );
+    started = false;
+  }
+  else
+  {
+    if( started )
+    {
+      writeOnLog( "Waiting Startup event from BG" );
+      ::WaitForSingleObject( startupEvent, INFINITE );
+      writeOnLog( "BGProcess Created" );
+    }
+    else
+    {
+      writeOnLog( "Could not start BG Process" );
+      writeOnLog(  "Last Error code : %i", GetLastError() );
+    }
+
+    CloseHandle( startupEvent );
+  }
+
+  CloseHandle( processInfo.hProcess );
+  CloseHandle( processInfo.hThread );
+
+  return started;
+}
+
+///////////////////////////
+bool P2PControl::sendTorrent( const std::string torrent )
+{
+  #ifdef P_DEBUG_2
+  writeOnLog( "P2PControl: Sending Torrent..." );
+  #endif
+
+  // Send START command with the torrent
+  std::string command = "START " + torrent;
+  return mConnection->sendMsg( command );
+}
+
+///////////////////////////
+DWORD WINAPI P2PControl::eventLoop( LPVOID params )
+{
+  BGPConnection *          connection;
+  event_cb_map_t *         eventMap;
+  std::string              serverCmd, command;
+  bg_event_t               event;
+  event_cb_map_t::iterator eventIt;
+  HANDLE *                 syncEvent;
+  HANDLE *                 syncMutex;
+  // Just for iterating through the events
+  std::pair< event_cb_map_t::iterator, event_cb_map_t::iterator > equalEventsIt;
+
+  // Parse parameters
+  connection = ( (ThreadParams *)params )->connection;
+  eventMap   = ( (ThreadParams *)params )->eventMap;
+  syncEvent  = ( (ThreadParams *)params )->syncEvent;
+  syncMutex  = ( (ThreadParams *)params )->syncMutex;
+
+  // TODO : Check here
+  SetEvent( *syncEvent ); // Main thread can delete ThreadParams now
+
+  writeOnLog( "P2P Thread: STARTING LOOP" );
+  // Main Thread Loop
+  while( true )
+  {
+    if( ! connection->recvMsg( serverCmd ) )
+    {
+      writeOnLog( "P2P Thread: Unable to receive the command from BG" );
+
+      // TODO : Check here
+      if( serverCmd != "SHUTDOWN" )
+        continue;
+    }
+
+    command = "";
+    event   = EV_NONE;
+    if( ! serverCmd.compare( 0, 4, "PLAY" ) )
+    {
+      command = serverCmd.substr( 5 );
+      event = EV_PLAY;
+    }
+    else if ( ! serverCmd.compare( 0, 5, "PAUSE" ) )
+    {
+      event = EV_PAUSE;
+    }
+    else if ( ! serverCmd.compare( 0, 6, "RESUME" ) )
+    {
+      event = EV_RESUME;
+    }
+    else if ( ! serverCmd.compare( 0, 8, "SHUTDOWN" ) )
+    {
+      writeOnLog( "P2P Thread: Received SHUTDOWN" );
+      event = EV_CLOSE;
+    }
+    else if ( ! serverCmd.compare( 0, 4, "INFO" ) )
+    {
+      command = serverCmd.substr( 5 );
+      event = EV_INFO;
+      writeOnLog( "INFO command received: %s", command.c_str() );
+    }
+    else
+    {
+      writeOnLog( "P2P Thread: Received wrong command: %s", serverCmd.c_str() );
+      continue;
+    }
+
+    writeOnLog( "P2P Thread: Command: %s", command.c_str() );
+
+    if( WaitForSingleObject( *syncMutex, INFINITE ) == WAIT_FAILED )
+    { writeOnLog( "Failed to Lock the Mutex" ); continue; }
+
+    // Call all event handlers related to the event
+    equalEventsIt = eventMap->equal_range( event );
+    for( eventIt = equalEventsIt.first; eventIt != equalEventsIt.second; ++eventIt )
+      ( (*eventIt).second )->process( command.c_str() );
+
+    if( ! ReleaseMutex( *syncMutex ) )
+    { writeOnLog( "Failed to Release the Mutex" ); continue; }
+
+    if( event == EV_CLOSE )
+      break;
+  }
+  writeOnLog( "P2P Thread: EXITING Loop" );
+  SetEvent( *syncEvent ); // Main thread can shut down now
+  return 0;
+}
+
+///////////////////////////
+/*void P2PControl::unregEventCB( bg_event_t event, EventHandlerWrap * eventCallback )
+{
+  std::pair< event_cb_map_t::iterator, event_cb_map_t::iterator > equalEventsIt;
+  // TODO
+  if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+  { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+  equalEventsIt = mEventCBMap->equal_range( event );
+  for( eventIt = equalEventsIt.first; eventIt != equalEventsIt.second; ++eventIt )
+    ( (*eventIt).second )->process( command.c_str() );
+
+  if( ! ReleaseMutex( mSyncMutex ) )
+  { writeOnLog( "Failed to Release the Mutex" ); return; }
+}*/
+
+///////////////////////////
+void P2PControl::unregEventCB( bg_event_t event )
+{
+  if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+  { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+  mEventCBMap.erase( event );
+
+  if( ! ReleaseMutex( mSyncMutex ) )
+  { writeOnLog( "Failed to Release the Mutex" ); return; }
+}
+
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/p2pcontrol.h ./projects/activex/p2pcontrol.h
--- /arno/build/vlc-1.0.5/projects/activex/p2pcontrol.h	1970-01-01 01:00:00.000000000 +0100
+++ ./projects/activex/p2pcontrol.h	2010-02-26 14:53:03.000000000 +0100
@@ -0,0 +1,202 @@
+/* 
+ * Written by Diego Andres Rabaioli
+ * see P2P-Next-LICENSE.txt for license information
+ */
+
+
+#ifndef _P2PCONTROL_H
+#define _P2PCONTROL_H
+
+#include <winsock2.h>
+#include <string>
+#include <map>
+
+
+////////////////////////
+//
+// The P2PControl class handles the communicaion with the BG Process.
+// Through P2PControl it's possible to send requests to the BG like
+// 'START myvideo.torrent' and accept commands like 'PLAY', 'PAUSE',...
+// It's possible to associate an action to each BG command, registering
+// a callback related to the specific event:
+// regEventCB( EV_PLAY, myCallbackFunction );
+//
+// General use case:
+//
+// P2PControl * p2pControl = new P2PControl();
+// if( ! p2pControl->startup() )
+//   return -1;
+//
+// p2pControl->regEventCB( EV_PLAY,   &myPlayHandler );
+// p2pControl->regEventCB( EV_PAUSE,  &myPauseHandler );
+// p2pControl->regEventCB( EV_RESUME, &myResumeHandler );
+// ...
+//
+// if( ! p2pControl->sendTorrent( 'http://www.foo.com/videocontent_1.torrent' ) )
+//  return -1;
+//
+////////////////////////
+
+void writeOnLog( const char * msg, ... );
+
+///////////////////////////
+// BGPConnection
+///////////////////////////
+
+// States enumerations
+enum sock_state_t { S_DOWN, S_STARTED, S_CREATED, S_UP };
+
+const int         IN_BUF_LEN = 512;
+const int         BG_PORT    = 62062;
+const std::string BG_ADDRESS = "127.0.0.1";
+
+class BGPConnection
+{
+ public:
+  BGPConnection( const int port, const std::string bgAddress );
+  ~BGPConnection();
+
+  bool connect();
+  bool disconnect();
+
+  bool sendMsg( const std::string & ) const;
+  bool recvMsg( std::string & ) const;
+
+  std::string  getAddress() { return mBGAddress; }
+  int          getPort()    { return mPort; }
+
+ private:
+  SOCKET       mServerSocket;
+  std::string  mBGAddress;
+  int          mPort;
+  sock_state_t mSocketState;
+};
+
+///////////////////////////
+// EventHandlerWrap
+///////////////////////////
+class EventHandlerWrap
+{
+ public:
+  virtual void process( const char * ) const = 0;
+  virtual ~EventHandlerWrap() {}
+};
+
+///////////////////////////
+class EventHandlerWrap_Static : public EventHandlerWrap
+{
+ public:
+  EventHandlerWrap_Static( void ( *handler )( const char * ) ):
+    mSHandler( handler ) {}
+
+  virtual ~EventHandlerWrap_Static() {}
+
+  virtual void process( const char * c ) const
+  {
+    mSHandler( c );
+  }
+
+ private:
+  void ( *mSHandler )( const char * );
+
+};
+
+///////////////////////////
+template < class T >
+class EventHandlerWrap_NonStatic : public EventHandlerWrap
+{
+ public:
+  EventHandlerWrap_NonStatic( T * obj, void ( T::* handler )( const char * ) ):
+    mObject( obj ), mNHandler( handler ) {}
+
+  virtual ~EventHandlerWrap_NonStatic() {}
+
+  virtual void process( const char * c ) const
+  {
+    (mObject->*mNHandler)( c );
+  }
+
+ private:
+  T * mObject;
+  void ( T::* mNHandler )( const char * );
+};
+
+///////////////////////////
+// P2PControl
+///////////////////////////
+
+// Constants
+const WCHAR PLUGIN_REG_KEY[]   = L"Software\\SwarmPlugin";
+const WCHAR BG_PATH_ELEMENT[]  = L"BGProcessPath";
+const WCHAR LOG_PATH_ELEMENT[] = L"InstallDir";
+const char  LOG_FILE_NAME[]    = "swarmplugin.log";
+
+// Event Callback types
+enum bg_event_t { EV_NONE, EV_PLAY, EV_PAUSE, EV_RESUME, EV_STOP, EV_INFO, EV_CLOSE };
+typedef std::multimap< bg_event_t, EventHandlerWrap * > event_cb_map_t;
+typedef std::pair< bg_event_t, EventHandlerWrap * >     event_cb_item_t;
+
+// States enumerations
+enum protocol_status_t { P_DOWN, P_UP, P_CLOSING };
+
+class P2PControl
+{
+ public:
+  P2PControl( const int port = BG_PORT, const std::string bgAddress = BG_ADDRESS );
+  ~P2PControl();
+
+  bool  startup();
+  bool  shutdown();
+
+  bool  launchBGProcess( const char * cmd = NULL );
+  bool  sendTorrent( const std::string torrent );
+
+  void  regEventCB( bg_event_t event, void (*callback)( const char * ) )
+  {
+    if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+      { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+    EventHandlerWrap * wrap = new EventHandlerWrap_Static( callback );
+    mEventCBMap.insert( event_cb_item_t( event, wrap ) );
+
+    if( ! ReleaseMutex( mSyncMutex ) )
+      { writeOnLog( "Failed to Release the Mutex" ); return; }
+  }
+
+  template < class T >
+  void  regEventCB( bg_event_t event, T * obj, void ( T::* callback)( const char * ) )
+  {
+    if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+      { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+    EventHandlerWrap * wrap = new EventHandlerWrap_NonStatic< T >( obj, callback );
+    mEventCBMap.insert( event_cb_item_t( event, wrap ) ); 
+
+    if( ! ReleaseMutex( mSyncMutex ) )
+      { writeOnLog( "Failed to Release the Mutex" ); return; }
+  }
+
+  //void  unregEventCB( bg_event_t, EventHandlerWrap * );
+  void  unregEventCB( bg_event_t );
+
+ private:
+  // Thread utilities
+  const BGPConnection *  getConnection() const { return mConnection; }
+  const event_cb_map_t * getEventMap()   const { return &mEventCBMap; }
+  // Event Loop: receives events from BG and call the registered handlers
+  static DWORD WINAPI    eventLoop( LPVOID );
+  // Back Ground Process
+  static bool            startBGProcess();
+
+  // Variable Members
+  BGPConnection *   mConnection;
+  protocol_status_t mProtoState;
+
+  // Thread and Sync
+  event_cb_map_t    mEventCBMap;  // Association event/callback
+  HANDLE            mEventThread; // Thread handler
+  HANDLE            mSyncEvent;   // Syncronize the thread at startup and shutdown time
+  HANDLE            mSyncMutex;   // Syncronize access to the Event Map
+};
+
+#endif  // _P2PCONTROL_H
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/plugin.cpp ./projects/activex/plugin.cpp
--- /arno/build/vlc-1.0.5/projects/activex/plugin.cpp	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/plugin.cpp	2010-02-26 14:53:02.000000000 +0100
@@ -40,6 +40,11 @@
 
 #include "utils.h"
 
+// P2P-Next
+#include "p2pcontrol.h"
+#include <vlc_osd.h>
+
+
 #include <stdio.h>
 #include <string.h>
 #include <winreg.h>
@@ -230,6 +235,12 @@
     vlcOleObject = new VLCOleObject(this);
     vlcSupportErrorInfo = new VLCSupportErrorInfo(this);
 
+    // P2P-Next
+    p2pControl = new P2PControl();
+    p2pStatus = NULL;
+#if _MEDIACONTROL_
+    mediaControl    = NULL;
+#endif
     // configure controlling IUnknown interface for implemented interfaces
     this->pUnkOuter = (NULL != pUnkOuter) ? pUnkOuter : dynamic_cast<LPUNKNOWN>(this);
 
@@ -248,6 +259,9 @@
     */
     AddRef();
 
+    // P2P-Next
+    delete p2pControl;
+
     delete vlcSupportErrorInfo;
     delete vlcOleObject;
     delete vlcDataObject;
@@ -374,6 +388,10 @@
         HimetricFromDP(hDC, (LPPOINT)&_extent, 1);
         DeleteDC(hDC);
 
+        // P2P-Next
+        if( ! p2pControl->startup() ) // TODO : check what happen if !startup
+          return E_FAIL;
+
         return S_OK;
     }
     return CO_E_ALREADYINITIALIZED;
@@ -449,7 +467,7 @@
 
     HKEY h_key;
     char p_pluginpath[MAX_PATH];
-    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("Software\\VideoLAN\\VLC"),
+    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("Software\\SwarmPlugin"),
                       0, KEY_READ, &h_key ) == ERROR_SUCCESS )
     {
         DWORD i_type, i_data = MAX_PATH;
@@ -465,6 +483,7 @@
                     strcat( p_pluginpath, "\\plugins" );
                     ppsz_argv[ppsz_argc++] = "--plugin-path";
                     ppsz_argv[ppsz_argc++] = p_pluginpath;
+                    writeOnLog( "VlcPlugin: Found plugins directory: %s", p_pluginpath );
                 }
             }
         }
@@ -479,6 +498,11 @@
     ppsz_argv[ppsz_argc++] = "--no-media-library";
     ppsz_argv[ppsz_argc++] = "--ignore-config";
     ppsz_argv[ppsz_argc++] = "--intf=dummy";
+    ppsz_argv[ppsz_argc++] = "--no-osd";
+    ppsz_argv[ppsz_argc++] = "--no-video-title-show";
+    // Arno: to log to file, uncomment extraintf and logfile lines:
+    // ppsz_argv[ppsz_argc++] = "--extraintf=logger";
+    //ppsz_argv[ppsz_argc++] = "--logfile=C:\\VLC-logfile.txt";
 
     // loop mode is a configuration option only
     if( _b_autoloop )
@@ -505,6 +529,7 @@
         libvlc_audio_set_mute(_p_libvlc, TRUE, NULL);
     }
 
+
     // initial playlist item
     if( SysStringLen(_bstr_mrl) > 0 )
     {
@@ -535,6 +560,7 @@
         }
         if( NULL != psz_mrl )
         {
+#ifdef ORIG
             const char *options[1];
             int i_options = 0;
 
@@ -544,8 +570,23 @@
                 snprintf(timeBuffer, sizeof(timeBuffer), ":start-time=%d", _i_time);
                 options[i_options++] = timeBuffer;
             }
+
             // add default target to playlist
             playlist_add_extended_untrusted(psz_mrl, i_options, options, NULL);
+#else
+            // P2P-Next
+	    // The URL is that of a torrent file that we want to watch, forward to BG process
+            p2pControl->regEventCB< VLCPlugin >( EV_PLAY,   this, &VLCPlugin::onPlay );
+            p2pControl->regEventCB< VLCPlugin >( EV_PAUSE,  this, &VLCPlugin::onPause );
+            p2pControl->regEventCB< VLCPlugin >( EV_RESUME, this, &VLCPlugin::onResume );
+            p2pControl->regEventCB< VLCPlugin >( EV_STOP,   this, &VLCPlugin::onStop );
+            p2pControl->regEventCB< VLCPlugin >( EV_INFO,   this, &VLCPlugin::onInfo );
+
+            if( ! p2pControl->sendTorrent( string( psz_mrl ) ) )
+            {
+	        writeOnLog( "Plugin: initVLC: Could NOT send torrent to BG process" );
+	    }
+#endif
             CoTaskMemFree(psz_mrl);
         }
     }
@@ -554,7 +595,7 @@
 void VLCPlugin::setErrorInfo(REFIID riid, const char *description)
 {
     vlcSupportErrorInfo->setErrorInfo( getClassID() == CLSID_VLCPlugin2 ?
-        OLESTR("VideoLAN.VLCPlugin.2") : OLESTR("VideoLAN.VLCPlugin.1"),
+        OLESTR("P2PNext.SwarmPlugin.2") : OLESTR("P2PNext.SwarmPlugin.1"),
         riid, description );
 };
 
@@ -1104,4 +1145,121 @@
     return item;
 }
 
+// P2P-Next
+void VLCPlugin::onPlay( const char * stream )
+{
+    const char *options[1];
+    int i_options = 0;
+
+    char timeBuffer[32];
+    if( _i_time )
+    {
+        snprintf( timeBuffer, sizeof(timeBuffer), ":start-time=%d", _i_time );
+        options[i_options++] = timeBuffer;
+    }
+    // add default target to playlist
+    int item = playlist_add_extended_untrusted(stream, i_options, options, NULL);
+
+    if( _b_autoplay )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        // Arno, 2010-02-11: explicitly select item, otherwise VLC may play old one
+        // for some reason, even if the playlist appears to be empty (JS level)
+        playlist_play_item(item, &ex);
+        if( libvlc_exception_raised(&ex) )
+        {
+	        writeOnLog( "VLCPlugin::onPlay: Exception" );
+	        writeOnLog( libvlc_exception_get_message(&ex) );
+	        libvlc_exception_clear(&ex);
+	        return;
+        }
+
+        // Arno, 2009-08-19: Not sure whether we need these still. vlccontrol.cpp uses them,
+        // vlccontrol2.cpp doesn't.
+        fireOnPlayEvent();
+    }
+}
+
+void VLCPlugin::onPause( const char * nothing )
+{
+    libvlc_exception_t ex;
+    libvlc_exception_init(&ex);
+
+    playlist_pause(&ex);
+    if( libvlc_exception_raised(&ex) )
+    {
+        writeOnLog( "VLCPlugin::onPause: Exception" );
+        writeOnLog( libvlc_exception_get_message(&ex) );
+        libvlc_exception_clear(&ex);
+        return;
+    }
+
+    fireOnPauseEvent();
+}
+
+void VLCPlugin::onResume( const char * nothing )
+{
+    libvlc_exception_t ex;
+    libvlc_exception_init(&ex);
+
+    playlist_play(&ex);
+    if( libvlc_exception_raised(&ex) )
+    {
+        writeOnLog( "VLCPlugin::onResume: Exception" );
+        writeOnLog( libvlc_exception_get_message(&ex) );
+        libvlc_exception_clear(&ex);
+        return;
+    }
+
+    fireOnPlayEvent();
+}
+
+void VLCPlugin::onStop( const char * nothing )
+{
+    libvlc_exception_t ex;
+    libvlc_exception_init(&ex);
+
+    playlist_stop(&ex);
+    if( libvlc_exception_raised(&ex) )
+    {
+        writeOnLog( "VLCPlugin::onResume: Exception" );
+        writeOnLog( libvlc_exception_get_message(&ex) );
+        libvlc_exception_clear(&ex);
+        return;
+    }
+
+    fireOnStopEvent();
+}
+
+void VLCPlugin::onInfo( const char * infostr )
+{
+    // Save copy of status message
+	if (this->p2pStatus != NULL)
+	{
+		free(this->p2pStatus);
+	}
+	this->p2pStatus = (char *)malloc((strlen(infostr)+1)*sizeof(char));
+	strcpy(this->p2pStatus,infostr);
+}
 
+// For JavaScript API
+const char *VLCPlugin::getP2PStatus()
+{
+    if (this->p2pStatus == NULL)
+		return "";
+	else
+		return this->p2pStatus;
+}
+
+int  VLCPlugin::set_p2ptarget(const char *mrl, libvlc_exception_t *ex)
+{
+    int item = -1;
+
+    if( ! p2pControl->sendTorrent( string( mrl ) ) )
+    {
+    	writeOnLog( "Plugin: initVLC: Could NOT send torrent to BG process, set_p2ptarget" );
+    }
+    return item;
+}
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/plugin.h ./projects/activex/plugin.h
--- /arno/build/vlc-1.0.5/projects/activex/plugin.h	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/plugin.h	2010-02-26 14:53:02.000000000 +0100
@@ -28,6 +28,13 @@
 
 #include <vlc/vlc.h>
 
+// P2P-Next
+#define _MEDIACONTROL_ 0
+#if _MEDIACONTROL_
+// TODO : just for test
+#include <vlc/mediacontrol.h>
+#endif
+
 extern "C" const GUID CLSID_VLCPlugin;
 extern "C" const GUID CLSID_VLCPlugin2;
 extern "C" const GUID LIBID_AXVLC;
@@ -237,6 +244,14 @@
     void fireOnPauseEvent(void);
     void fireOnStopEvent(void);
 
+    // P2P-Next
+    /* P2P Event Handlers */
+    void onPlay  ( const char * stream );
+    void onPause ( const char * nothing );
+    void onResume( const char * nothing );
+    void onStop  ( const char * nothing );
+    void onInfo  ( const char * string );
+
     // controlling IUnknown interface
     LPUNKNOWN pUnkOuter;
 
@@ -307,6 +322,10 @@
             libvlc_media_player_play(_p_mplayer,ex);
     }
 
+    // P2P-Next: For JavaScript API
+    const char *       getP2PStatus();
+    int  			   set_p2ptarget(const char *mrl, libvlc_exception_t *ex);
+
 protected:
 
     virtual ~VLCPlugin();
@@ -333,6 +352,13 @@
     class VLCDataObject *vlcDataObject;
     class VLCSupportErrorInfo *vlcSupportErrorInfo;
 
+    // P2P-Next
+    class P2PControl  * p2pControl;
+    char * p2pStatus;
+#if _MEDIACONTROL_
+    mediacontrol_Instance * mediaControl;
+#endif
+
     // in place activated window (Plugin window)
     HWND _inplacewnd;
 
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/README.TXT ./projects/activex/README.TXT
--- /arno/build/vlc-1.0.5/projects/activex/README.TXT	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/README.TXT	2010-02-26 14:53:02.000000000 +0100
@@ -20,6 +20,12 @@
 axvlc_idl.h
 axvlc.tlb
 
+Arno: Open Visual Studio 2008 Command Prompt via Start Menu. Then run:
+
+C:> midl /h axvlc_idl.h /iid axvlc_idl.c axvlc.idl
+
+ArnoEnd.
+
 To use the MIDL compiler on cygwin, you will need to set some environment variables
 before configuring vlc. If you have a copy of 'Microsoft Visual C++ 6.0' installed,
 the following settings are correct:
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/vlccontrol2.cpp ./projects/activex/vlccontrol2.cpp
--- /arno/build/vlc-1.0.5/projects/activex/vlccontrol2.cpp	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/vlccontrol2.cpp	2010-02-26 14:53:02.000000000 +0100
@@ -646,6 +646,89 @@
     return hr;
 };
 
+
+// P2P-Next
+STDMETHODIMP VLCInput::get_p2pstatus(BSTR *p2pstatus)
+{
+    if( NULL == p2pstatus )
+        return E_POINTER;
+
+    const char *p2pstatusStr = _p_instance->getP2PStatus();
+    if( NULL != p2pstatusStr )
+    {
+        *p2pstatus = BSTRFromCStr(CP_UTF8, p2pstatusStr);
+
+        return (NULL == *p2pstatus) ? E_OUTOFMEMORY : NOERROR;
+    }
+    *p2pstatus = NULL;
+    return E_FAIL;
+};
+
+// P2P-Next, 2010-02-15
+STDMETHODIMP VLCInput::set_p2ptarget(BSTR uri, long* item)
+{
+    if( NULL == item )
+        return E_POINTER;
+
+    if( 0 == SysStringLen(uri) )
+        return E_INVALIDARG;
+
+    libvlc_instance_t* p_libvlc;
+    HRESULT hr = _p_instance->getVLC(&p_libvlc);
+    if( SUCCEEDED(hr) )
+    {
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
+        char *psz_uri = NULL;
+        if( SysStringLen(_p_instance->getBaseURL()) > 0 )
+        {
+            /*
+            ** if the MRL a relative URL, we should end up with an absolute URL
+            */
+            LPWSTR abs_url = CombineURL(_p_instance->getBaseURL(), uri);
+            if( NULL != abs_url )
+            {
+                psz_uri = CStrFromWSTR(CP_UTF8, abs_url, wcslen(abs_url));
+                CoTaskMemFree(abs_url);
+            }
+            else
+            {
+                psz_uri = CStrFromBSTR(CP_UTF8, uri);
+            }
+        }
+        else
+        {
+            /*
+            ** baseURL is empty, assume MRL is absolute
+            */
+            psz_uri = CStrFromBSTR(CP_UTF8, uri);
+        }
+
+        if( NULL == psz_uri )
+        {
+            return E_OUTOFMEMORY;
+        }
+
+        *item = _p_instance->set_p2ptarget(psz_uri, &ex);
+
+        CoTaskMemFree(psz_uri);
+        if( libvlc_exception_raised(&ex) )
+        {
+            _p_instance->setErrorInfo(IID_IVLCInput,
+                libvlc_exception_get_message(&ex));
+            libvlc_exception_clear(&ex);
+            return E_FAIL;
+        }
+        return NOERROR;
+    }
+    return hr;
+};
+
+
+
+
+
 /*******************************************************************************/
 
 VLCLog::~VLCLog()
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/activex/vlccontrol2.h ./projects/activex/vlccontrol2.h
--- /arno/build/vlc-1.0.5/projects/activex/vlccontrol2.h	2009-12-20 18:43:40.000000000 +0100
+++ ./projects/activex/vlccontrol2.h	2010-02-26 14:53:03.000000000 +0100
@@ -126,6 +126,8 @@
     STDMETHODIMP put_rate(double);
     STDMETHODIMP get_fps(double*);
     STDMETHODIMP get_hasVout(VARIANT_BOOL*);
+    STDMETHODIMP get_p2pstatus(BSTR *version); //P2P-Next
+    STDMETHODIMP set_p2ptarget(BSTR, long*); //P2P-Next, 2010-02-15
 
 protected:
     HRESULT loadTypeInfo();
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/control/npolibvlc.cpp ./projects/mozilla/control/npolibvlc.cpp
--- /arno/build/vlc-1.0.5/projects/mozilla/control/npolibvlc.cpp	2009-12-20 18:43:41.000000000 +0100
+++ ./projects/mozilla/control/npolibvlc.cpp	2010-02-26 14:53:03.000000000 +0100
@@ -11,7 +11,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful,
+ * This program is distribputed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
@@ -369,6 +369,7 @@
     "rate",
     "fps",
     "hasVout",
+    "p2pstatus", //P2P-Next
 };
 COUNTNAMES(LibvlcInputNPObject,propertyCount,propertyNames);
 
@@ -381,6 +382,7 @@
     ID_input_rate,
     ID_input_fps,
     ID_input_hasvout,
+    ID_input_p2pstatus, //P2P-Next
 };
 
 RuntimeNPObject::InvokeResult
@@ -396,19 +398,23 @@
         libvlc_media_player_t *p_md = p_plugin->getMD(&ex);
         if( libvlc_exception_raised(&ex) )
         {
-            if( index != ID_input_state )
+        	if( index == ID_input_p2pstatus )
             {
-                NPN_SetException(this, libvlc_exception_get_message(&ex));
-                libvlc_exception_clear(&ex);
-                return INVOKERESULT_GENERIC_ERROR;
+                return this->getP2PStatus(result);
             }
-            else
+            else if( index == ID_input_state )
             {
                 /* for input state, return CLOSED rather than an exception */
                 INT32_TO_NPVARIANT(0, result);
                 libvlc_exception_clear(&ex);
                 return INVOKERESULT_NO_ERROR;
             }
+            else
+            {
+                NPN_SetException(this, libvlc_exception_get_message(&ex));
+                libvlc_exception_clear(&ex);
+                return INVOKERESULT_GENERIC_ERROR;
+            }
         }
 
         switch( index )
@@ -462,6 +468,11 @@
                 BOOLEAN_TO_NPVARIANT(val, result);
                 return INVOKERESULT_NO_ERROR;
             }
+            case ID_input_p2pstatus: //P2P-Next
+            {
+                return this->getP2PStatus(result);
+            }
+
             default:
                 ;
         }
@@ -469,6 +480,28 @@
     return INVOKERESULT_GENERIC_ERROR;
 }
 
+//P2P-Next
+RuntimeNPObject::InvokeResult
+LibvlcInputNPObject::getP2PStatus(NPVariant &result)
+{
+    VlcPlugin* p_plugin = getPrivate<VlcPlugin>();
+#ifdef XP_WIN
+    const char *s = p_plugin->getP2PStatus();
+    int len = strlen(s);
+    NPUTF8 *retval =(NPUTF8*)NPN_MemAlloc(len);
+    if( !retval )
+        return INVOKERESULT_OUT_OF_MEMORY;
+
+    memcpy(retval, s, len);
+    STRINGN_TO_NPVARIANT(retval, len, result);
+    return INVOKERESULT_NO_ERROR;
+#else
+    return INVOKERESULT_GENERIC_ERROR;
+#endif
+}
+
+
+
 RuntimeNPObject::InvokeResult
 LibvlcInputNPObject::setProperty(int index, const NPVariant &value)
 {
@@ -537,14 +570,13 @@
 
 const NPUTF8 * const LibvlcInputNPObject::methodNames[] =
 {
-    /* no methods */
-    "none",
+    "set_p2ptarget", //P2P-Next
 };
 COUNTNAMES(LibvlcInputNPObject,methodCount,methodNames);
 
 enum LibvlcInputNPObjectMethodIds
 {
-    ID_none,
+	ID_input_set_p2ptarget,
 };
 
 RuntimeNPObject::InvokeResult
@@ -554,10 +586,48 @@
     /* is plugin still running */
     if( isPluginRunning() )
     {
+        VlcPlugin* p_plugin = getPrivate<VlcPlugin>();
+        libvlc_exception_t ex;
+        libvlc_exception_init(&ex);
+
         switch( index )
         {
-            case ID_none:
+            case ID_input_set_p2ptarget: //P2P-Next
+            {
+				if(argCount < 1)
                 return INVOKERESULT_NO_SUCH_METHOD;
+
+				char *url = NULL;
+
+				// grab URL
+				if( NPVARIANT_IS_NULL(args[0]) )
+					return INVOKERESULT_NO_SUCH_METHOD;
+
+				if( NPVARIANT_IS_STRING(args[0]) )
+				{
+					char *s = stringValue(NPVARIANT_TO_STRING(args[0]));
+					if( s )
+					{
+						url = p_plugin->getAbsoluteURL(s);
+						if( url )
+							free(s);
+						else
+							// problem with combining url, use argument
+							url = s;
+					}
+					else
+						return INVOKERESULT_OUT_OF_MEMORY;
+				}
+				else
+					return INVOKERESULT_NO_SUCH_METHOD;
+
+				int item = p_plugin->input_set_p2ptarget(url,&ex);
+				free(url);
+
+				RETURN_ON_EXCEPTION(this,ex);
+				INT32_TO_NPVARIANT(item, result);
+				return INVOKERESULT_NO_ERROR;
+            }
             default:
                 ;
         }
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/control/npolibvlc.h ./projects/mozilla/control/npolibvlc.h
--- /arno/build/vlc-1.0.5/projects/mozilla/control/npolibvlc.h	2009-12-20 18:43:41.000000000 +0100
+++ ./projects/mozilla/control/npolibvlc.h	2010-02-26 14:53:03.000000000 +0100
@@ -99,6 +99,9 @@
     static const NPUTF8 * const methodNames[];
 
     InvokeResult invoke(int index, const NPVariant *args, uint32_t argCount, NPVariant &result);
+//P2P-Next
+private:
+    InvokeResult getP2PStatus(NPVariant &result);
 };
 
 class LibvlcPlaylistItemsNPObject: public RuntimeNPObject
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/Makefile.am ./projects/mozilla/Makefile.am
--- /arno/build/vlc-1.0.5/projects/mozilla/Makefile.am	2009-12-20 18:43:41.000000000 +0100
+++ ./projects/mozilla/Makefile.am	2010-02-26 14:53:03.000000000 +0100
@@ -11,6 +11,8 @@
 	vlcshell.h \
 	vlcplugin.cpp \
 	vlcplugin.h \
+	p2pcontrol.cpp \
+	p2pcontrol.h \
 	control/npolibvlc.cpp \
 	control/npolibvlc.h \
 	control/nporuntime.cpp \
@@ -35,11 +37,11 @@
 
 SOURCES_support = support/npwin.cpp
 CPPFLAGS_mozilla_EXTRA = -DXP_WIN -DXP_WIN32
-LDFLAGS_mozilla_EXTRA = -no-undefined -Wl,--kill-at -Wl,$(DATA_npvlc_rc)
+LDFLAGS_mozilla_EXTRA = -lws2_32 -no-undefined -Wl,--kill-at -Wl,$(DATA_npvlc_rc)
 
 npvlc_la_SOURCES = $(SOURCES_mozilla_common) $(SOURCES_support)
-npvlc_la_CFLAGS = `$(VLC_CONFIG) --cflags mozilla` $(CPPFLAGS_mozilla_extra)
-npvlc_la_CXXFLAGS = `$(VLC_CONFIG) --cxxflags mozilla` $(CPPFLAGS_mozilla_extra)
+npvlc_la_CFLAGS = `$(VLC_CONFIG) --cflags mozilla` $(CPPFLAGS_mozilla_EXTRA)
+npvlc_la_CXXFLAGS = `$(VLC_CONFIG) --cxxflags mozilla` $(CPPFLAGS_mozilla_EXTRA)
 npvlc_la_DEPENDENCIES = $(DATA_npvlc_rc) $(LIBRARIES_libvlc)
 npvlc_la_LDFLAGS = `$(VLC_CONFIG) --ldflags mozilla` -module -avoid-version \
 				   $(LDFLAGS_mozilla_EXTRA)
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/Makefile.in ./projects/mozilla/Makefile.in
--- /arno/build/vlc-1.0.5/projects/mozilla/Makefile.in	2010-01-24 22:28:52.000000000 +0100
+++ ./projects/mozilla/Makefile.in	2010-02-26 14:53:03.000000000 +0100
@@ -89,9 +89,10 @@
 	vlcplugin.cpp vlcplugin.h control/npolibvlc.cpp \
 	control/npolibvlc.h control/nporuntime.cpp \
 	control/nporuntime.h support/classinfo.h support/npunix.c \
-	support/npmac.cpp support/npwin.cpp
+	support/npmac.cpp support/npwin.cpp \
+	p2pcontrol.cpp p2pcontrol.h
 am__objects_1 = libvlcplugin_la-vlcshell.lo \
-	libvlcplugin_la-vlcplugin.lo libvlcplugin_la-npolibvlc.lo \
+	libvlcplugin_la-vlcplugin.lo libvlcplugin_la-p2pcontrol.lo libvlcplugin_la-npolibvlc.lo \
 	libvlcplugin_la-nporuntime.lo
 @BUILD_MOZILLA_TRUE@@HAVE_DARWIN_FALSE@@HAVE_WIN32_FALSE@am__objects_2 = libvlcplugin_la-npunix.lo
 @BUILD_MOZILLA_TRUE@@HAVE_DARWIN_TRUE@@HAVE_WIN32_FALSE@am__objects_2 = libvlcplugin_la-npmac.lo
@@ -110,9 +111,10 @@
 	vlcplugin.h control/npolibvlc.cpp control/npolibvlc.h \
 	control/nporuntime.cpp control/nporuntime.h \
 	support/classinfo.h support/npunix.c support/npmac.cpp \
-	support/npwin.cpp
+	support/npwin.cpp \
+	p2pcontrol.cpp p2pcontrol.h
 am__objects_3 = npvlc_la-vlcshell.lo npvlc_la-vlcplugin.lo \
-	npvlc_la-npolibvlc.lo npvlc_la-nporuntime.lo
+	npvlc_la-p2pcontrol.lo npvlc_la-npolibvlc.lo npvlc_la-nporuntime.lo
 @BUILD_MOZILLA_TRUE@@HAVE_DARWIN_FALSE@@HAVE_WIN32_FALSE@am__objects_4 = npvlc_la-npunix.lo
 @BUILD_MOZILLA_TRUE@@HAVE_DARWIN_TRUE@@HAVE_WIN32_FALSE@am__objects_4 = npvlc_la-npmac.lo
 @BUILD_MOZILLA_TRUE@@HAVE_WIN32_TRUE@am__objects_4 =  \
@@ -929,6 +931,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libvlcplugin_la-npwin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libvlcplugin_la-vlcplugin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libvlcplugin_la-vlcshell.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libvlcplugin_la-p2pcontrol.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-npmac.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-npolibvlc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-nporuntime.Plo@am__quote@
@@ -936,6 +939,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-npwin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-vlcplugin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-vlcshell.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/npvlc_la-p2pcontrol.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -1000,6 +1004,15 @@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libvlcplugin_la_CXXFLAGS) $(CXXFLAGS) -c -o libvlcplugin_la-vlcshell.lo `test -f 'vlcshell.cpp' || echo '$(srcdir)/'`vlcshell.cpp
 
+
+libvlcplugin_la-p2pcontrol.lo: p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libvlcplugin_la_CXXFLAGS) $(CXXFLAGS) -MT libvlcplugin_la-p2pcontrol.lo -MD -MP -MF $(DEPDIR)/libvlcplugin_la-p2pcontrol.Tpo -c -o libvlcplugin_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/libvlcplugin_la-p2pcontrol.Tpo $(DEPDIR)/libvlcplugin_la-p2pcontrol.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='p2pcontrol.cpp' object='libvlcplugin_la-p2pcontrol.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libvlcplugin_la_CXXFLAGS) $(CXXFLAGS) -c -o libvlcplugin_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+
+
 libvlcplugin_la-vlcplugin.lo: vlcplugin.cpp
 @am__fastdepCXX_TRUE@	$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libvlcplugin_la_CXXFLAGS) $(CXXFLAGS) -MT libvlcplugin_la-vlcplugin.lo -MD -MP -MF $(DEPDIR)/libvlcplugin_la-vlcplugin.Tpo -c -o libvlcplugin_la-vlcplugin.lo `test -f 'vlcplugin.cpp' || echo '$(srcdir)/'`vlcplugin.cpp
 @am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/libvlcplugin_la-vlcplugin.Tpo $(DEPDIR)/libvlcplugin_la-vlcplugin.Plo
@@ -1042,6 +1055,15 @@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(npvlc_la_CXXFLAGS) $(CXXFLAGS) -c -o npvlc_la-vlcshell.lo `test -f 'vlcshell.cpp' || echo '$(srcdir)/'`vlcshell.cpp
 
+
+npvlc_la-p2pcontrol.lo: p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(npvlc_la_CXXFLAGS) $(CXXFLAGS) -MT npvlc_la-p2pcontrol.lo -MD -MP -MF $(DEPDIR)/npvlc_la-p2pcontrol.Tpo -c -o npvlc_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/npvlc_la-p2pcontrol.Tpo $(DEPDIR)/npvlc_la-p2pcontrol.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='p2pcontrol.cpp' object='npvlc_la-p2pcontrol.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(npvlc_la_CXXFLAGS) $(CXXFLAGS) -c -o npvlc_la-p2pcontrol.lo `test -f 'p2pcontrol.cpp' || echo '$(srcdir)/'`p2pcontrol.cpp
+
+
 npvlc_la-vlcplugin.lo: vlcplugin.cpp
 @am__fastdepCXX_TRUE@	$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(npvlc_la_CXXFLAGS) $(CXXFLAGS) -MT npvlc_la-vlcplugin.lo -MD -MP -MF $(DEPDIR)/npvlc_la-vlcplugin.Tpo -c -o npvlc_la-vlcplugin.lo `test -f 'vlcplugin.cpp' || echo '$(srcdir)/'`vlcplugin.cpp
 @am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/npvlc_la-vlcplugin.Tpo $(DEPDIR)/npvlc_la-vlcplugin.Plo
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/npvlc.dll.manifest ./projects/mozilla/npvlc.dll.manifest
--- /arno/build/vlc-1.0.5/projects/mozilla/npvlc.dll.manifest	2009-12-20 18:43:41.000000000 +0100
+++ ./projects/mozilla/npvlc.dll.manifest	2010-02-26 14:53:03.000000000 +0100
@@ -1,10 +1,10 @@
 <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
 <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
 	<assemblyIdentity
-		version="1.0.0.0"
+		version="1.0.5.0"
 		processorArchitecture="x86"
 		name="npvlc.dll"
 		type="win32"
 	/>
-	<description>VLC Mozilla plugin</description>
+	<description>SwarmPlugin P2P Multimedia Mozilla plugin</description>
 </assembly>
\ No newline at end of file
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/npvlc_rc.rc.in ./projects/mozilla/npvlc_rc.rc.in
--- /arno/build/vlc-1.0.5/projects/mozilla/npvlc_rc.rc.in	2009-12-20 18:43:41.000000000 +0100
+++ ./projects/mozilla/npvlc_rc.rc.in	2010-02-26 14:53:03.000000000 +0100
@@ -1,8 +1,8 @@
 /////////////////////////////////////////////////////////////////////////////
 //
-//  VLC Plugin description.
+//  SwarmPlugin description.
 //
-#define VERSION_NUMBER @VERSION_MAJOR@,@VERSION_MINOR@,@VERSION_REVISION@,@VERSION_EXTRA_RC@ 
+#define VERSION_NUMBER 1,0,5,0
 
 //VS_VERSION_INFO VERSIONINFO
 1 VERSIONINFO
@@ -23,17 +23,17 @@
     BEGIN
         BLOCK "040904e4"
         BEGIN
-            VALUE "ProductName", "VLC Multimedia Plug-in\0"
-            VALUE "ProductVersion", "@VERSION@"
+            VALUE "ProductName", "SwarmPlugin P2P Multimedia Plug-in\0"
+            VALUE "ProductVersion", "1.0.5"
             VALUE "OriginalFilename", "npvlc.dll\0"
-            VALUE "FileVersion", "@VERSION@"
-            VALUE "FileDescription", "Version @VERSION@, copyright @COPYRIGHT_YEARS@ The VideoLAN Team<br><a href=""http://www.videolan.org/"">http://www.videolan.org/</a>\0"
+            VALUE "FileVersion", "1.0.5"
+            VALUE "FileDescription", "SwarmPlugin Version 1.0.5, Copyright (c) 2009-2010, the VideoLAN Team and Delft University of Technology<br><a href=""http://www.pds.ewi.tudelft.nl/code.html"">http://www.pds.ewi.tudelft.nl/code.html</a>\0"
             VALUE "InternalName", "npvlc\0"
-            VALUE "CompanyName", "the VideoLAN Team\0"
-            VALUE "LegalCopyright", "Copyright \251 @COPYRIGHT_YEARS@ The VideoLAN Team\0"
-            VALUE "MIMEType", "audio/mpeg|audio/x-mpeg|video/mpeg|video/x-mpeg|video/mpeg-system|video/x-mpeg-system|video/mp4|audio/mp4|application/mpeg4-iod|application/mpeg4-muxcodetable|video/x-msvideo|video/quicktime|application/x-ogg|application/ogg|application/x-vlc-plugin|video/x-ms-asf-plugin|video/x-ms-asf|application/x-mplayer2|video/x-ms-wmv|application/x-google-vlc-plugin|audio/wav|audio/x-wav|audio/3gpp|video/3gpp|audio/3gpp2|video/3gpp2|video/divx|video/flv|video/x-flv|video/x-matroska|audio/x-matroska|application/xspf+xml|audio/x-m4a|audio/x-mpegurl|audio/x-ms-wma\0"
-            VALUE "FileExtents", "mp2,mp3,mpga,mpega|mp2,mp3,mpga,mpega|mpg,mpeg,mpe|mpg,mpeg,mpe|mpg,mpeg,vob|mpg,mpeg,vob|mp4,mpg4|mp4,mpg4|mp4,mpg4|mp4,mpg4|avi|mov,qt|ogg|ogg|vlc|asf,asx|asf,asx||wmv||wav|wav|3gp,3gpp|3gp,3gpp|3g2,3gpp2|3g2,3gpp2|divx|flv|flv|mkv|mka|xspf|m4a|m3u|wma\0"
-            VALUE "FileOpenName", "MPEG audio|MPEG audio|MPEG video|MPEG video|MPEG video|MPEG video|MPEG-4 video|MPEG-4 audio|MPEG-4 video|MPEG-4 video|AVI video|QuickTime video|Ogg stream|Ogg stream|VLC plug-in|Windows Media video|Windows Media video|Windows Media plug-in|Windows Media video|Google VLC plug-in|WAV audio|WAV audio|3GPP audio|3GPP video|3GPP2 audio|3GPP2 video|DivX video|FLV video|FLV video|Matroska video|Matroska audio|Playlist xspf|MPEG-4 audio|Playlist M3U|Windows Media Audio\0"
+            VALUE "CompanyName", "the VideoLAN Team and Delft University of Technology\0"
+            VALUE "LegalCopyright", "Copyright \251 2009-2010 the VideoLAN Team and Delft University of Technology\0"
+            VALUE "MIMEType", "application/x-ns-stream\0"
+            VALUE "FileExtents", "torrent\0"
+            VALUE "FileOpenName", "Torrent Video\0"
         END
     END
     BLOCK "VarFileInfo"
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/p2pcontrol.cpp ./projects/mozilla/p2pcontrol.cpp
--- /arno/build/vlc-1.0.5/projects/mozilla/p2pcontrol.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ./projects/mozilla/p2pcontrol.cpp	2010-02-26 14:53:03.000000000 +0100
@@ -0,0 +1,518 @@
+/*
+ * Written by Diego Andres Rabaioli
+ * see P2P-Next-LICENSE.txt for license information
+ */
+#ifdef XP_WIN
+
+#include "p2pcontrol.h"
+#include <string>
+
+#define P_DEBUG
+
+#ifdef P_DEBUG
+#include <stdio.h>
+#include <stdarg.h>
+#endif
+
+void writeOnLog( const char * msg, ... )
+{
+#ifdef P_DEBUG
+  static std::string logPath = "";
+
+  if( logPath.empty() )
+  {
+    LONG   result;
+    HKEY   hKey;
+    CHAR   Logpath[256];
+    DWORD  bufLen = sizeof( Logpath );
+
+    // Look in the Windows registry for installation path
+    result = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PLUGIN_REG_KEY, 0, KEY_QUERY_VALUE, &hKey );
+    if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return; }
+    result = RegQueryValueEx( hKey, LOG_PATH_ELEMENT, NULL, NULL, (LPBYTE)Logpath, &bufLen);
+    if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return; }
+    RegCloseKey( hKey );
+    logPath.assign( Logpath );
+    logPath.append( "\\" );
+    logPath.append( LOG_FILE_NAME );
+  }
+
+  if( ! logPath.empty() )
+  {
+    FILE * file;
+    file = fopen( logPath.c_str(), "a" );
+    if( file == NULL ) return;
+
+    va_list args;
+    va_start( args, msg );
+    vfprintf( file, msg, args );
+    va_end( args );
+    fputs( "\r\n", file );
+    fclose( file );
+  }
+
+/*  FILE * file;
+  file = fopen( "C:\\vlc_plugin_fx.log", "a" );
+  if( file == NULL ) return;
+
+  va_list args;
+  va_start( args, msg );
+  vfprintf( file, msg, args );
+  va_end( args );
+  fputs( "\r\n", file );
+  fclose( file );*/
+#endif
+};
+
+///////////////////////////
+// BGPConnection
+///////////////////////////
+BGPConnection::BGPConnection( const int port, const std::string bgAddress )
+{
+  mBGAddress   = bgAddress;
+  mPort        = port;
+  mSocketState = S_DOWN;
+}
+
+///////////////////////////
+BGPConnection::~BGPConnection()
+{
+  disconnect();
+}
+
+///////////////////////////
+bool BGPConnection::connect()
+{
+  WSADATA            wsaData;
+  struct sockaddr_in serverAddress;
+  int                iResult;
+
+  // Just to be in a consistent state
+  if( mSocketState == S_UP )
+    return true;
+  else if( mSocketState != S_DOWN )
+    disconnect();
+
+  // Init Winsock
+  iResult = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
+  if( iResult != 0 )
+    return disconnect();
+
+  mSocketState = S_STARTED;
+
+  // Create socket
+  if( ( mServerSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) == INVALID_SOCKET )
+    return disconnect();
+
+  mSocketState = S_CREATED;
+
+  memset( &serverAddress, 0, sizeof( serverAddress ) );
+  serverAddress.sin_family      = AF_INET;
+  serverAddress.sin_port        = htons( mPort );
+  serverAddress.sin_addr.s_addr = inet_addr( mBGAddress.c_str() );
+
+  // Connect to the BG process server
+  if( ( ::connect( mServerSocket, (struct sockaddr *)&serverAddress,
+                 sizeof( serverAddress ) ) ) == SOCKET_ERROR )
+  {
+    #ifdef P_DEBUG
+    writeOnLog( "BGPConnection: Could not connect to server" );
+    writeOnLog( "%i Socket Server : %i Server Addres : %i", WSAGetLastError(), mServerSocket, serverAddress.sin_addr.s_addr );
+    #endif
+    return disconnect();
+  }
+
+  #ifdef P_DEBUG
+  writeOnLog( "BGPConnection: CONNECTED" );
+  #endif
+
+  mSocketState = S_UP;
+  return true;
+
+}
+
+///////////////////////////
+bool BGPConnection::disconnect()
+{
+// Shut down the connection depending on the state of the socket
+// It basically returns always false (stupid code optimization reasons)
+  #ifdef P_DEBUG_2
+  char * tmp_str = NULL;
+  sprintf( tmp_str, "BGPConnection: Shutting down connection from status %d", mSocketState );
+  writeOnLog( tmp_str );
+  #endif
+
+  if( mSocketState == S_DOWN )
+    return false;
+
+  if( mSocketState >= S_CREATED )
+  {
+    closesocket( mServerSocket );
+    mServerSocket = INVALID_SOCKET;
+  }
+
+  WSACleanup();
+  mSocketState = S_DOWN;
+  return false;
+}
+
+///////////////////////////
+bool BGPConnection::sendMsg( const std::string & event ) const
+{
+  int res;
+
+  // Check socket status
+  if( mSocketState != S_UP )
+    return false;
+
+  // Complete message
+  std::string msg = event + "\r\n";
+  // Send Event
+  res = send( mServerSocket, msg.c_str(), msg.length(), 0 );
+  #ifdef P_DEBUG
+  writeOnLog( "BGPConnection: Sending: %s", event.c_str() );
+  #endif
+  if( res == SOCKET_ERROR )
+  {
+    #ifdef P_DEBUG
+    writeOnLog( "BGPConnection: Error in sending event" );
+    #endif
+    return false;
+  }
+
+  return true;
+}
+
+///////////////////////////
+bool BGPConnection::recvMsg( std::string & msg ) const
+{
+  char inBuffer[ IN_BUF_LEN ];
+  int  res;
+
+  if( mSocketState != S_UP )
+    return false;
+
+  msg = "";
+  while( true )
+  {
+    res = recv( mServerSocket, inBuffer, IN_BUF_LEN, 0 );
+
+    if( res <= 0 )
+    {
+      #ifdef P_DEBUG
+      writeOnLog( "BGPConnection: Error in receiving stream" );
+      #endif
+      msg = "SHUTDOWN";
+      return false;
+    }
+
+    msg.append( inBuffer, res );
+    if( ! msg.compare( msg.size() - 2, 2, "\r\n" ) )
+      break;
+  }
+  // Trim "\r\n"
+  msg.erase( msg.size() - 2 );
+
+  #ifdef P_DEBUG
+  writeOnLog( "BGPConnection: RECEIVED : %s", msg.c_str() );
+  #endif
+
+  return true;
+}
+
+///////////////////////////
+// P2PControl
+///////////////////////////
+P2PControl::P2PControl( const int port, const std::string bgAddress ) :
+  mEventCBMap(), mProtoState( P_DOWN )
+{
+  mConnection  = new BGPConnection( port, bgAddress );
+  mEventThread = NULL;
+}
+
+///////////////////////////
+P2PControl::~P2PControl()
+{
+  shutdown();
+}
+
+///////////////////////////
+bool P2PControl::startup()
+{
+  writeOnLog( "P2PControl::starting up..." );
+
+  // Try to connect to the BG Process.
+  // If it doesn't succeed then try to
+  // start the BG Process and try to
+  // connect againg
+  if( mProtoState == P_UP )
+    return true;
+
+  if( ! mConnection->connect() )
+    if( ! startBGProcess() || ! mConnection->connect() )
+      return mConnection->disconnect();
+
+
+  if( mEventThread != NULL ) // TODO : confusing... fix startup procedure
+    return true;
+
+  // Init syncronization event
+  mSyncEvent = CreateEvent( NULL, false, false, NULL );
+  if( mSyncEvent == NULL )
+  {
+    writeOnLog( "P2PControl: Error in creating syncronization event" );
+    return false;
+  }
+
+  // Init syncronization mutex
+  mSyncMutex = CreateMutex( NULL, false, NULL );
+  if( mSyncMutex == NULL )
+  {
+    writeOnLog( "P2PControl: Error in creating syncronization mutex" );
+    return false;
+  }
+
+  // Start the Event Loop
+  ThreadParams * threadParams = new ThreadParams;
+  threadParams->connection    = mConnection;
+  threadParams->eventMap      = &mEventCBMap;
+  threadParams->syncEvent     = &mSyncEvent;
+  threadParams->syncMutex     = &mSyncMutex;
+
+  mEventThread = CreateThread( NULL,
+                               0,
+                               &eventLoop,
+                               threadParams,
+                               0,
+                               NULL );
+
+  if( mEventThread == NULL )
+  {
+    writeOnLog( "P2PControl: Could not start event loop thread" );
+    delete threadParams;
+    return false;
+  }
+
+  if( WaitForSingleObject( mSyncEvent, INFINITE ) != WAIT_OBJECT_0 )
+    writeOnLog( "Sync Error while Starting up the event thread" );
+
+  delete threadParams;
+
+  mProtoState = P_UP;
+
+  return true;
+}
+
+///////////////////////////
+bool P2PControl::shutdown()
+{
+  DWORD res;
+  mConnection->sendMsg( "SHUTDOWN" );
+  res = WaitForSingleObject( mSyncEvent, 2000 );
+  if( res == WAIT_TIMEOUT ) writeOnLog( "Sync Error while closing thread" );
+  else writeOnLog( "P2PControl: Thread cleanly exited" );
+
+  CloseHandle( mEventThread );
+  CloseHandle( mSyncEvent );
+  CloseHandle( mSyncMutex );
+  delete mConnection;
+  mProtoState = P_DOWN;
+
+  return true;
+}
+
+///////////////////////////
+bool P2PControl::startBGProcess()
+{
+  LONG         result;
+  HKEY         hKey;
+  CHAR         BGpath[256]; // TODO : Fix this
+  DWORD        bufLen = sizeof( BGpath );
+
+  // Look in the Windows registry to get the path of the BG
+  result = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PLUGIN_REG_KEY, 0, KEY_QUERY_VALUE, &hKey );
+  if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return false; }
+  result = RegQueryValueEx( hKey, BG_PATH_ELEMENT, NULL, NULL, (LPBYTE)BGpath, &bufLen);
+  if( result != ERROR_SUCCESS ) { RegCloseKey( hKey ); return false; }
+  RegCloseKey( hKey );
+
+  // Set up variables
+  STARTUPINFOA        startupInfo;
+  PROCESS_INFORMATION processInfo;
+  memset( &startupInfo, 0, sizeof( startupInfo ) );
+  memset( &processInfo, 0, sizeof( processInfo ) );
+  startupInfo.cb = sizeof( startupInfo );
+
+  writeOnLog( "Starting BG Process..." );
+  // Finally start the BG Process
+  bool started = CreateProcess( BGpath,
+                                NULL,
+                                NULL,
+                                NULL,
+                                false,
+                                CREATE_NO_WINDOW,
+                                NULL,
+                                NULL,
+                                &startupInfo,
+                                &processInfo );
+
+  // Wait the process to startup and send a 'startup' event
+  HANDLE startupEvent = CreateEvent( NULL, false, false, "startupEvent" );
+  if( startupEvent == NULL )
+  {
+    writeOnLog( "P2PControl: Error in creating syncronization event: Could not create BG Process" );
+    started = false;
+  }
+  else
+  {
+    if( started )
+    {
+      writeOnLog( "Waiting Startup event from BG" );
+      ::WaitForSingleObject( startupEvent, INFINITE );
+      writeOnLog( "BGProcess Created" );
+    }
+    else
+    {
+      writeOnLog( "Could not start BG Process" );
+      writeOnLog(  "Last Error code : %i", GetLastError() );
+    }
+
+    CloseHandle( startupEvent );
+  }
+
+  CloseHandle( processInfo.hProcess );
+  CloseHandle( processInfo.hThread );
+
+  return started;
+}
+
+///////////////////////////
+bool P2PControl::sendTorrent( const std::string torrent )
+{
+  #ifdef P_DEBUG_2
+  writeOnLog( "P2PControl: Sending Torrent..." );
+  #endif
+
+  // Send START command with the torrent
+  std::string command = "START " + torrent;
+  return mConnection->sendMsg( command );
+}
+
+///////////////////////////
+DWORD WINAPI P2PControl::eventLoop( LPVOID params )
+{
+  BGPConnection *          connection;
+  event_cb_map_t *         eventMap;
+  std::string              serverCmd, command;
+  bg_event_t               event;
+  event_cb_map_t::iterator eventIt;
+  HANDLE *                 syncEvent;
+  HANDLE *                 syncMutex;
+  // Just for iterating through the events
+  std::pair< event_cb_map_t::iterator, event_cb_map_t::iterator > equalEventsIt;
+
+  // Parse parameters
+  connection = ( (ThreadParams *)params )->connection;
+  eventMap   = ( (ThreadParams *)params )->eventMap;
+  syncEvent  = ( (ThreadParams *)params )->syncEvent;
+  syncMutex  = ( (ThreadParams *)params )->syncMutex;
+
+  SetEvent( *syncEvent ); // Main thread can delete ThreadParams now
+
+  writeOnLog( "P2P Thread: STARTING LOOP" );
+  // Main Thread Loop
+  while( true )
+  {
+    if( ! connection->recvMsg( serverCmd ) )
+    {
+      #ifdef P_DEBUG
+      writeOnLog( "P2P Thread: Unable to receive the command from BG" );
+      #endif
+      if( serverCmd != "SHUTDOWN" )
+        continue;
+    }
+
+    command = "";
+    event   = EV_NONE;
+    if( ! serverCmd.compare( 0, 4, "PLAY" ) )
+    {
+      command = serverCmd.substr( 5 );
+      event = EV_PLAY;
+    }
+    else if ( ! serverCmd.compare( 0, 5, "PAUSE" ) )
+    {
+      event = EV_PAUSE;
+    }
+    else if ( ! serverCmd.compare( 0, 6, "RESUME" ) )
+    {
+      event = EV_RESUME;
+    }
+    else if ( ! serverCmd.compare( 0, 8, "SHUTDOWN" ) )
+    {
+      writeOnLog( "P2P Thread: Received SHUTDOWN" );
+      event = EV_CLOSE;
+    }
+    else if ( ! serverCmd.compare( 0, 4, "INFO" ) )
+    {
+      command = serverCmd.substr( 5 );
+      event = EV_INFO;
+      writeOnLog( "INFO command received: %s", command.c_str() );
+    }
+    else
+    {
+      #ifdef P_DEBUG
+      writeOnLog( "P2P Thread: Received wrong command: %s", serverCmd.c_str() );
+      #endif
+      continue;
+    }
+
+    writeOnLog( "P2P Thread: Command: %s", command.c_str() );
+
+    // Call all event handlers
+    if( WaitForSingleObject( *syncMutex, INFINITE ) == WAIT_FAILED )
+    { writeOnLog( "Failed to Lock the Mutex" ); continue; }
+
+    equalEventsIt = eventMap->equal_range( event );
+    for( eventIt = equalEventsIt.first; eventIt != equalEventsIt.second; ++eventIt )
+      ( (*eventIt).second )->process( command.c_str() );
+
+    if( ! ReleaseMutex( *syncMutex ) )
+    { writeOnLog( "Failed to Release the Mutex" ); continue; }
+
+    if( event == EV_CLOSE )
+      break;
+  }
+  writeOnLog( "P2P Thread: EXITING Loop" );
+  SetEvent( *syncEvent ); // Main thread can shut down now
+  return 0;
+}
+
+///////////////////////////
+/*void P2PControl::unregEventCB( bg_event_t event, EventHandlerWrap * eventCallback )
+{
+  std::pair< event_cb_map_t::iterator, event_cb_map_t::iterator > equalEventsIt;
+  // TODO
+  if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+  { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+  equalEventsIt = mEventCBMap->equal_range( event );
+  for( eventIt = equalEventsIt.first; eventIt != equalEventsIt.second; ++eventIt )
+    ( (*eventIt).second )->process( command.c_str() );
+
+  if( ! ReleaseMutex( mSyncMutex ) )
+  { writeOnLog( "Failed to Release the Mutex" ); return; }
+}*/
+
+///////////////////////////
+void P2PControl::unregEventCB( bg_event_t event )
+{
+  if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+  { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+  mEventCBMap.erase( event );
+
+  if( ! ReleaseMutex( mSyncMutex ) )
+  { writeOnLog( "Failed to Release the Mutex" ); return; }
+}
+
+#endif
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/p2pcontrol.h ./projects/mozilla/p2pcontrol.h
--- /arno/build/vlc-1.0.5/projects/mozilla/p2pcontrol.h	1970-01-01 01:00:00.000000000 +0100
+++ ./projects/mozilla/p2pcontrol.h	2010-02-26 14:53:03.000000000 +0100
@@ -0,0 +1,202 @@
+/*
+ * Written by Diego Andres Rabaioli
+ * see P2P-Next-LICENSE.txt for license information
+ */
+
+#ifndef _PEER2PEERCONTROL_H
+#define _PEER2PEERCONTROL_H
+
+#include <winsock2.h>
+#include <string>
+#include <map>
+
+
+////////////////////////
+//
+// This class represents the communication layer between the Plug-in
+// and the BG Process. It sends and receives events through a TCP
+// socket. It receives commands in an asynchronous way. A thread
+// implements the event loop: it's mainly blocked in a recv call,
+// as soon as it receives an event from the BG process, it calls
+// all the handlers registered for that event. The communication
+// protocol it's basic: after the connection with the remote
+// process, the P2PControl sends the MRL ( media resource
+// locator) of the torrent to the BG, when the stream is available,
+// a 'PLAY' event is sent back and the handler for that event is
+// called. Since it's intended to work as a library, external code
+// can use the P2P control by registering their handler functions.
+//
+////////////////////////
+
+void writeOnLog( const char * msg, ... );
+
+///////////////////////////
+// BGPConnection
+///////////////////////////
+
+// States enumerations
+enum sock_state_t { S_DOWN, S_STARTED, S_CREATED, S_UP };
+
+const int         IN_BUF_LEN = 512;
+const int         BG_PORT    = 62062;
+const std::string BG_ADDRESS = "127.0.0.1";
+
+class BGPConnection
+{
+ public:
+  BGPConnection( const int port, const std::string bgAddress );
+  ~BGPConnection();
+
+  bool connect();
+  bool disconnect();
+
+  bool sendMsg( const std::string & ) const;
+  bool recvMsg( std::string & ) const;
+
+  std::string  getAddress() { return mBGAddress; }
+  int          getPort()    { return mPort; }
+
+ private:
+  SOCKET       mServerSocket;
+  std::string  mBGAddress;
+  int          mPort;
+  sock_state_t mSocketState;
+};
+
+///////////////////////////
+// EventHandlerWrap
+///////////////////////////
+class EventHandlerWrap
+{
+ public:
+  virtual void process( const char * ) const = 0;
+  virtual ~EventHandlerWrap() {}
+};
+
+///////////////////////////
+class EventHandlerWrap_Static : public EventHandlerWrap
+{
+ public:
+  EventHandlerWrap_Static( void ( *handler )( const char * ) ):
+    mSHandler( handler ) {}
+
+  virtual ~EventHandlerWrap_Static() {}
+
+  virtual void process( const char * c ) const
+  {
+    mSHandler( c );
+  }
+
+ private:
+  void ( *mSHandler )( const char * );
+
+};
+
+///////////////////////////
+template < class T >
+class EventHandlerWrap_NonStatic : public EventHandlerWrap
+{
+ public:
+  EventHandlerWrap_NonStatic( T * obj, void ( T::* handler )( const char * ) ):
+    mObject( obj ), mNHandler( handler ) {}
+
+  virtual ~EventHandlerWrap_NonStatic() {}
+
+  virtual void process( const char * c ) const
+  {
+    (mObject->*mNHandler)( c );
+  }
+
+ private:
+  T * mObject;
+  void ( T::* mNHandler )( const char * );
+};
+
+///////////////////////////
+// P2PControl
+///////////////////////////
+
+// Constants
+const char PLUGIN_REG_KEY[]   = "Software\\SwarmPlugin";
+const char BG_PATH_ELEMENT[]  = "BGProcessPath";
+const char LOG_PATH_ELEMENT[] = "InstallDir";
+const char LOG_FILE_NAME[]    = "swarmplugin.log";
+
+// Event Callback types
+enum bg_event_t { EV_NONE, EV_PLAY, EV_PAUSE, EV_RESUME, EV_STOP, EV_INFO, EV_CLOSE };
+typedef std::multimap< bg_event_t, EventHandlerWrap * > event_cb_map_t;
+typedef std::pair< bg_event_t, EventHandlerWrap * >     event_cb_item_t;
+
+// Thread parameters
+typedef struct {  BGPConnection *  connection;
+                  event_cb_map_t * eventMap;
+                  HANDLE *         syncEvent;
+                  HANDLE *         syncMutex;
+               } ThreadParams;
+
+// States enumerations
+enum protocol_status_t { P_DOWN, P_UP, P_CLOSING };
+
+class P2PControl
+{
+ public:
+  P2PControl( const int port = BG_PORT, const std::string bgAddress = BG_ADDRESS );
+  ~P2PControl();
+
+  bool  startup();
+  bool  shutdown();
+
+  bool  launchBGProcess( const char * cmd = NULL );
+  bool  sendTorrent( const std::string torrent );
+
+  void  regEventCB( bg_event_t event, void (*callback)( const char * ) )
+  {
+    if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+      { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+    EventHandlerWrap * wrap = new EventHandlerWrap_Static( callback );
+    mEventCBMap.insert( event_cb_item_t( event, wrap ) );
+
+    if( ! ReleaseMutex( mSyncMutex ) )
+      { writeOnLog( "Failed to Release the Mutex" ); return; }
+  }
+
+  template < class T >
+  void  regEventCB( bg_event_t event, T * obj, void ( T::* callback)( const char * ) )
+  {
+    if( WaitForSingleObject( mSyncMutex, INFINITE ) == WAIT_FAILED )
+      { writeOnLog( "Failed to Lock the Mutex" ); return; }
+
+    EventHandlerWrap * wrap = new EventHandlerWrap_NonStatic< T >( obj, callback );
+    mEventCBMap.insert( event_cb_item_t( event, wrap ) );
+
+    if( ! ReleaseMutex( mSyncMutex ) )
+      { writeOnLog( "Failed to Release the Mutex" ); return; }
+  }
+
+  //void  unregEventCB( bg_event_t, EventHandlerWrap * );
+  void  unregEventCB( bg_event_t );
+
+  // DEBUG
+  void setProtoState( protocol_status_t newState ) { mProtoState = newState; }
+ private:
+  // Thread utilities
+  const BGPConnection *  getConnection() const { return mConnection; }
+  const event_cb_map_t * getEventMap()   const { return &mEventCBMap; }
+  // Event Loop: receives events from BG and call the registered handlers
+  static DWORD WINAPI    eventLoop( LPVOID );
+  // Back Ground Process
+  static bool            startBGProcess();
+
+  // Variable Members
+  BGPConnection *   mConnection;
+  protocol_status_t mProtoState;
+
+  // Thread and Sync
+  event_cb_map_t    mEventCBMap;  // Association event/callback
+  HANDLE            mEventThread; // Thread handler
+  HANDLE            mSyncEvent;   // Syncronize the thread at startup and shutdown time
+  HANDLE            mSyncMutex;   // Syncronize access to the Event Map
+};
+
+#endif
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/vlcplugin.cpp ./projects/mozilla/vlcplugin.cpp
--- /arno/build/vlc-1.0.5/projects/mozilla/vlcplugin.cpp	2009-12-20 18:43:41.000000000 +0100
+++ ./projects/mozilla/vlcplugin.cpp	2010-02-26 14:53:03.000000000 +0100
@@ -73,10 +73,17 @@
 #endif
 {
     memset(&npwindow, 0, sizeof(NPWindow));
+
 #if XP_UNIX
     memset(&npvideo, 0, sizeof(Window));
     memset(&npcontrol, 0, sizeof(Window));
 #endif
+
+#ifdef XP_WIN
+    // P2P-Next
+    p2pControl = new P2PControl();
+    p2pStatus = NULL;
+#endif
 }
 
 static bool boolValue(const char *value) {
@@ -103,7 +110,7 @@
     HKEY h_key;
     DWORD i_type, i_data = MAX_PATH + 1;
     char p_data[MAX_PATH + 1];
-    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\VideoLAN\\VLC",
+    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\SwarmPlugin",
                       0, KEY_READ, &h_key ) == ERROR_SUCCESS )
     {
          if( RegQueryValueEx( h_key, "InstallDir", 0, &i_type,
@@ -120,6 +127,11 @@
     }
     ppsz_argv[ppsz_argc++] = "--no-one-instance";
 
+    // P2P
+    if( ! p2pControl->startup() )
+      return NPERR_GENERIC_ERROR;
+
+
 #endif /* XP_MACOSX */
 
     /* common settings */
@@ -129,6 +141,12 @@
     ppsz_argv[ppsz_argc++] = "--ignore-config";
     ppsz_argv[ppsz_argc++] = "--intf=dummy";
     ppsz_argv[ppsz_argc++] = "--no-video-title-show";
+    ppsz_argv[ppsz_argc++] = "--no-osd";
+    // Arno: uncomment to enable logging
+    //ppsz_argv[ppsz_argc++] = "--extraintf=logger";
+    //ppsz_argv[ppsz_argc++] = "--logfile=C:\\VLC-logfile.txt";
+
+
 
     const char *progid = NULL;
 
@@ -253,6 +271,22 @@
         // get absolute URL from src
         char *psz_absurl = getAbsoluteURL(psz_target);
         psz_target = psz_absurl ? psz_absurl : strdup(psz_target);
+
+#ifdef XP_WIN
+        writeOnLog( "VlcPlugin::init: target: %s", psz_target );
+
+
+        p2pControl->regEventCB< VlcPlugin >( EV_PLAY,   this, &VlcPlugin::onP2PPlay );
+        p2pControl->regEventCB< VlcPlugin >( EV_PAUSE,  this, &VlcPlugin::onP2PPause );
+        p2pControl->regEventCB< VlcPlugin >( EV_RESUME, this, &VlcPlugin::onP2PResume );
+        p2pControl->regEventCB< VlcPlugin >( EV_STOP,   this, &VlcPlugin::onP2PStop );
+        p2pControl->regEventCB< VlcPlugin >( EV_INFO,   this, &VlcPlugin::onP2PInfo );
+
+        if( ! p2pControl->sendTorrent( std::string( psz_target ) ) )
+        {  writeOnLog( "VlcPlugin::init: Could NOT send torrent" ); }
+        free(psz_target);
+        psz_target = NULL;
+#endif
     }
 
     /* assign plugin script root class */
@@ -264,6 +298,9 @@
 
 VlcPlugin::~VlcPlugin()
 {
+#if XP_WIN
+    delete p2pControl; // P2P
+#endif
     free(psz_baseURL);
     free(psz_target);
 
@@ -916,3 +953,124 @@
 }
 #undef BTN_SPACE
 #endif
+#if XP_WIN
+void VlcPlugin::onP2PPlay( const char * stream )
+{
+  writeOnLog( "VlcPlugin::onP2PPlay %s", stream );
+
+  if( libvlc_instance )
+  {
+    libvlc_exception_t ex;
+    libvlc_exception_init( &ex );
+
+    int item = playlist_add(stream, &ex );
+    if( item != -1 )
+    {
+      writeOnLog( "VlcPlugin::onP2PPlay: item %d", item );
+      if( b_autoplay )
+      {
+        libvlc_exception_t ex2;
+        libvlc_exception_init( &ex2 );
+        // Arno, 2010-02-11: explicitly select item, otherwise VLC may play old one
+        // for some reason, even if the playlist appears to be empty (JS level)
+        playlist_play_item(item, &ex2); 
+        if( libvlc_exception_raised(&ex2) )
+        {
+           writeOnLog( libvlc_exception_get_message(&ex2) );
+           libvlc_exception_clear( &ex2 );
+           return;
+        }
+      }
+    }
+    else if( libvlc_exception_raised(&ex) )
+    {
+      writeOnLog( libvlc_exception_get_message(&ex) );
+      libvlc_exception_clear( &ex );
+      return;
+    }
+    b_stream = true;
+  }
+}
+
+void VlcPlugin::onP2PPause( const char * nothing )
+{
+  writeOnLog( "VlcPlugin::onP2PPause" );
+
+  libvlc_exception_t ex;
+  libvlc_exception_init( &ex );
+
+  playlist_pause( &ex );
+  if( libvlc_exception_raised(&ex) )
+  {
+    writeOnLog( libvlc_exception_get_message(&ex) );
+    libvlc_exception_clear( &ex );
+    return;
+  }
+}
+
+void VlcPlugin::onP2PResume( const char * nothing )
+{
+  writeOnLog( "VlcPlugin::onP2PResume" );
+
+  libvlc_exception_t ex;
+  libvlc_exception_init( &ex );
+
+  playlist_play( &ex );
+  if( libvlc_exception_raised(&ex) )
+  {
+    writeOnLog( libvlc_exception_get_message(&ex) );
+    libvlc_exception_clear( &ex );
+    return;
+  }
+}
+
+void VlcPlugin::onP2PStop( const char * nothing )
+{
+  writeOnLog( "VlcPlugin::onP2PStop" );
+
+  libvlc_exception_t ex;
+  libvlc_exception_init( &ex );
+
+  playlist_stop( &ex );
+  if( libvlc_exception_raised(&ex) )
+  {
+    writeOnLog( libvlc_exception_get_message(&ex) );
+    libvlc_exception_clear( &ex );
+    return;
+  }
+}
+
+void VlcPlugin::onP2PInfo( const char * infostr )
+{
+    // Save copy of status message
+	if (this->p2pStatus != NULL)
+	{
+		free(this->p2pStatus);
+	}
+	this->p2pStatus = (char *)malloc((strlen(infostr)+1)*sizeof(char));
+	strcpy(this->p2pStatus,infostr);
+}
+
+// For JavaScript API
+const char *VlcPlugin::getP2PStatus()
+{
+        if (this->p2pStatus == NULL)
+		return "";
+	else
+		return this->p2pStatus;
+}
+
+int VlcPlugin::input_set_p2ptarget( const char *mrl, libvlc_exception_t *ex )
+{
+    int item = -1;
+
+    if( ! p2pControl->sendTorrent( std::string( mrl ) ) )
+    {
+    	writeOnLog( "VlcPlugin::input_set_p2ptarget: Could NOT send torrent" );
+    }
+
+    return item;
+}
+
+
+#endif
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/mozilla/vlcplugin.h ./projects/mozilla/vlcplugin.h
--- /arno/build/vlc-1.0.5/projects/mozilla/vlcplugin.h	2009-12-20 18:43:41.000000000 +0100
+++ ./projects/mozilla/vlcplugin.h	2010-02-26 14:53:03.000000000 +0100
@@ -41,6 +41,8 @@
 
 #ifdef XP_WIN
     /* Windows stuff */
+    // P2P
+    #include "p2pcontrol.h"
 #endif
 
 #ifdef XP_MACOSX
@@ -79,6 +81,7 @@
     clicked_Unmute
 } vlc_toolbar_clicked_t;
 
+
 class VlcPlugin
 {
 public:
@@ -195,6 +198,21 @@
 
     bool  player_has_vout( libvlc_exception_t * );
 
+#if XP_WIN
+    // P2P-Next
+    P2PControl *   getP2PControl() { return p2pControl; }
+    void               onP2PPlay  ( const char * );
+    void               onP2PPause ( const char * );
+    void               onP2PResume( const char * );
+    void               onP2PStop  ( const char * );
+    void               onP2PInfo  ( const char * );
+
+    // For JavaScript API
+    const char *       getP2PStatus();
+    int input_set_p2ptarget( const char *, libvlc_exception_t * );
+#endif
+
+
 private:
     bool playlist_select(int,libvlc_exception_t *);
     void set_player_window( libvlc_exception_t * );
@@ -214,7 +232,11 @@
     NPWindow  npwindow;
 #if XP_WIN
     WNDPROC   pf_wndproc;
-#endif
+    // P2P
+    P2PControl * p2pControl;
+    char *		 p2pStatus;
+
+    #endif
 #if XP_UNIX
     unsigned int     i_width, i_height;
     unsigned int     i_tb_width, i_tb_height;
@@ -236,12 +258,14 @@
 /*******************************************************************************
  * Plugin properties.
  ******************************************************************************/
-#define PLUGIN_NAME         "VLC Multimedia Plug-in"
+#define PLUGIN_NAME         "SwarmPlugin Multimedia Player"
 #define PLUGIN_DESCRIPTION \
     "Version %s, copyright 1996-2007 The VideoLAN Team" \
     "<br><a href=\"http://www.videolan.org/\">http://www.videolan.org/</a>"
 
 #define PLUGIN_MIMETYPES \
+    "application/x-ns-stream;"
+#if 0
     /* MPEG-1 and MPEG-2 */ \
     "audio/mpeg:mp2,mp3,mpga,mpega:MPEG audio;" \
     "audio/x-mpeg:mp2,mp3,mpga,mpega:MPEG audio;" \
@@ -294,5 +318,6 @@
     "audio/x-matroska:mka:Matroska audio;" \
     /* XSPF */ \
     "application/xspf+xml:xspf:Playlist xspf;"
+#endif
 
 #endif
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/projects/P2P-Next-LICENSE.txt ./projects/P2P-Next-LICENSE.txt
--- /arno/build/vlc-1.0.5/projects/P2P-Next-LICENSE.txt	1970-01-01 01:00:00.000000000 +0100
+++ ./projects/P2P-Next-LICENSE.txt	2010-02-26 14:53:03.000000000 +0100
@@ -0,0 +1,180 @@
+-------------------------------------------------------------------------------
+
+    Next-Share content-delivery library.
+
+    The research leading to this library has received funding from the European
+    Community's Seventh Framework Programme in the P2P-Next project under grant
+    agreement no 216217.
+
+    All library modules are free software, unless stated otherwise; you can 
+    redistribute them and/or modify them under the terms of the GNU Lesser 
+    General Public License as published by the Free Software Foundation; in 
+    particular, version 2.1 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    The following library modules are Copyright (c) 2008-2012, VTT Technical Research Centre of Finland; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, Norut AS; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, DACC Systems AB; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, Lancaster University; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, JoÅ¾ef Stefan Institute; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, First Oversi Ltd.; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, TECHNISCHE UNIVERSITEIT DELFT; All rights reserved:
+      vlc/projects/activex/p2pcontrol.*
+      vlc/projects/mozilla/p2pcontrol.*
+
+    The following library modules are Copyright (c) 2008-2012, STMicroelectronics S.r.l.; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, Kungliga Tekniska HÃ¶gskolan (The Royal Institute of Technology); All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, Markenfilm GmbH & Co. KG; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, Radiotelevizija Slovenija Javni Zavvod Ljubljana; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, Kendra Foundation; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, Universitaet Klagenfurt; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, AG Projects; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, The British Broadcasting Corporation; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, Pioneer Digital Design Centre Limited; All rights reserved:
+  
+    The following library modules are Copyright (c) 2008-2012, INSTITUT FUER RUNDFUNKTECHNIK GMBH; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, Fabchannel BV; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, University Politehnica Bucharest; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, EBU-UER; All rights reserved:
+
+    The following library modules are Copyright (c) 2008-2012, UniversitÃ  di Roma Sapienza; All rights reserved:
+
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    VTT Technical Research Centre of Finland, 
+    Tekniikankatu 1, 
+    FIN-33710 Tampere, 
+    Finland
+
+    Norut AS,
+    Postboks 6434 
+    Forskningsparken, 
+    9294 TromsÃ¸,
+    Norway
+
+    DACC Systems AB
+    GlimmervÃ¤gen 4, 
+    SE18734, TÃ¤by,
+    Sweden
+
+    Lancaster University, 
+    University House, 
+    Bailrigg, Lancaster, LA1 4YW
+    United Kingdom
+
+    JoÅ¾ef Stefan Institute, 
+    Jamova cesta 39, 
+    1000 Ljubljana, 
+    Slovenia
+
+    First Oversi Ltd.,
+    Rishon Lezion 1,
+    Petah Tikva 49723, 
+    Israel
+
+    TECHNISCHE UNIVERSITEIT DELFT, 
+    Faculty of Electrical Engineering, Mathematics and Computer Science, 
+    Mekelweg 4, 
+    2628 CD Delft, 
+    The Netherlands
+
+    STMicroelectronics S.r.l., 
+    via C.Olivetti 2, 
+    I-20041 Agrate Brianza,
+    Italy
+
+    Kungliga Tekniska HÃ¶gskolan (The Royal Institute of Technology), 
+    KTH/ICT/ECS/TSLab
+    Electrum 229
+    164 40 Kista
+    Sweden
+
+    Markenfilm GmbH & Co. KG, 
+    Schulauer Moorweg 25, 
+    22880 Wedel, 
+    Germany
+
+    Radiotelevizija Slovenija Javni Zavvod Ljubljana, 
+    Kolodvorska 2, 
+    SI-1000 Ljubljana,
+    Slovenia
+
+
+    Kendra Foundation, 
+    Meadow Barn, Holne, 
+    Newton Abbot, Devon, TQ13 7SP,
+    United Kingdom
+
+
+    Universitaet Klagenfurt, 
+    Universitaetstrasse 65-67, 
+    9020 Klagenfurt, 
+    Austria
+
+    AG Projects, 
+    Dr. Leijdsstraat 92,
+    2021RK Haarlem, 
+    The Netherlands
+
+    The British Broadcasting Corporation,
+    Broadcasting House, Portland Place, 
+    London, W1A 1AA 
+    United Kingdom
+
+    Pioneer Digital Design Centre Limited, 
+    Pioneer House, Hollybush Hill, Stoke Poges, 
+    Slough, SL2 4QP
+    United Kingdom
+
+    INSTITUT FUER RUNDFUNKTECHNIK GMBH
+    Floriansmuehlstrasse 60,
+    80939 MÃ¼nchen, 
+    Germany
+
+    Fabchannel BV, 
+    Kleine-Gartmanplantsoen 21, 
+    1017 RP Amsterdam, 
+    The Netherlands
+
+    University Politehnica Bucharest, 
+    313 Splaiul Independentei, 
+    District 6, cod 060042, Bucharest,
+    Romania
+
+    EBU-UER, 
+    L'Ancienne Route 17A, 1218
+    Grand Saconnex - Geneva, 
+    Switzerland
+
+    UniversitÃ  di Roma Sapienza
+    Dipartimento di Informatica e Sistemistica (DIS),
+    Via Ariosto 25, 
+    00185 Rome, 
+    Italy
+
+
+------------------------------------------------------------------------------
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/src/control/mediacontrol_core.c ./src/control/mediacontrol_core.c
--- /arno/build/vlc-1.0.5/src/control/mediacontrol_core.c	2009-12-20 18:43:41.000000000 +0100
+++ ./src/control/mediacontrol_core.c	2010-02-26 14:52:31.000000000 +0100
@@ -427,3 +427,42 @@
     }
     return retval;
 }
+
+
+/* added by Ivaylo */
+
+void
+mediacontrol_set_raw_callbacks( mediacontrol_Instance *self,
+                                raw_read_fnc_ptr read_callback,
+                                raw_seek_fnc_ptr seek_callback,
+                                int i_fsize, // Arno: TODO: shouldn't this be int64 like seek's offset?
+                                int id,
+                                mediacontrol_Exception *exception )
+{
+    libvlc_media_t * p_media;
+    libvlc_exception_t ex;
+    char *psz_cmd = NULL;
+
+    mediacontrol_exception_init( exception );
+    libvlc_exception_init( &ex );
+
+
+    /* the cmd is something like
+       raw:rptr=0x12345678:sptr=0x98765432:fsize=314567789:id=4213
+      malloc 4   +5   +19        +5   +19        +6    +12       +3 +12   +1 = 86 bytes.
+     */
+    psz_cmd = ( char * )malloc( 128 * sizeof( char ) );
+    if( psz_cmd )
+    {
+        snprintf( psz_cmd, 128, "raw:rptr=0x%p:sptr=0x%p:fsize=%d:id=%d",
+            read_callback, seek_callback, i_fsize, id);
+
+        p_media = libvlc_media_new( self->p_instance, (const char *)psz_cmd, &ex );
+        HANDLE_LIBVLC_EXCEPTION_VOID( &ex );
+
+        libvlc_media_player_set_media( self->p_media_player, p_media, &ex );
+        HANDLE_LIBVLC_EXCEPTION_VOID( &ex );
+
+        free( psz_cmd ); // libvlc_media_new does strdup of psz_cmd
+    }
+}
diff -rbNU 3 -x .svn /arno/build/vlc-1.0.5/src/libvlc.sym ./src/libvlc.sym
--- /arno/build/vlc-1.0.5/src/libvlc.sym	2009-12-20 18:43:41.000000000 +0100
+++ ./src/libvlc.sym	2010-02-26 14:52:33.000000000 +0100
@@ -269,6 +269,7 @@
 mediacontrol_set_media_position
 mediacontrol_set_mrl
 mediacontrol_set_rate
+mediacontrol_set_raw_callbacks
 mediacontrol_set_visual
 mediacontrol_snapshot
 mediacontrol_sound_get_volume
