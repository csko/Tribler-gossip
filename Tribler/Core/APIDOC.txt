# Written by Arno Bakker 
# see LICENSE.txt for license information

triblerAPI v0.0.6rc1
Jan 30, 2008 

Using Python style guide

Simplest download session
=========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent')
    d = s.start_download(tdef)
    
Simpler download session
========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent')
    d = s.start_download(tdef)
    d.set_state_callback(state_callback)
    
def state_callback(ds):
	# Called by new thread
    d = ds.get_download()
    print `d.get_def().get_name()`,ds.get_status(),ds.get_progress()
    print ds.get_error()
    print "up",ds.get_current_speed(UPLOAD),"down",ds.get_current_speed(DOWNLOAD)
    return (5.0,False)


Simpler download session
========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent')
    dcfg = DownloadStartupConfig()
    dcfg.set_dest_dir('/tmp')
    d = s.start_download(tdef,dcfg)


Simple VOD download session
===========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent')
    dcfg = DownloadStartupConfig()
    dcfg.set_video_start_callback(vod_ready_callback)
    dcfg.set_selected_files('part2.avi') # play this video
    d = s.start_download(tdef,dcfg)
    
def vod_ready_callback(download,mimetype,stream,filename):
    # Called by new thread 
    while True:
        data = stream.read()
        if len(data) == 0:
            break
        outstream.write(data)
    stream.close()

CAUTION: We may add more video-on-demand callback functions to be able
to signal to the API user that a video is about to stall. At the moment
this can also be gathered via the DownloadState. If state.get_vod_playable()
becomes False after the first video-start callback, the download engine
switched to prebuffering again.


Simplest seeding session
========================
    s = Session().get_instance()
    tdef = TorrentDef()
    tdef.add_content('/tmp/homevideo.wmv')
    tdef.set_tracker(s.get_internal_tracker_url())
    tdef.finalize()
    dcfg = DownloadStartupConfig()
    dcfg.set_dest_dir('/tmp')
    d = s.start_download(tdef,dcfg)


Simpler seeding session
=======================
    s = Session().get_instance()
    tdef = TorrentDef() 
    tdef.add_content('/tmp/homevideo.wmv')
    tdef.set_thumbnail('/tmp/homevideo.jpg')
    tdef.set_tracker(s.get_internal_tracker_url())
    tdef.finalize()

    dcfg = DownloadStartupConfig()
    dcfg.set_dest_dir('/tmp')
    d = s.start_download(tdef,dcfg)

Simple Live broadcast session
=============================
    s = Session().get_instance()
    tdef = TorrentDef()
    tdef.create_live(bitrate) 
    tdef.set_tracker(s.get_internal_tracker_url())
    tdef.finalize()
    
	dcfg = DownloadStartupConfig()
	dcfg.set_video_source(stream)
	s.start_download(tdef,dcfg)
	
To watch:
---------
    s = Session()
    tdef = TorrentDef.load('/tmp/live.torrent')
    dcfg = DownloadStartupConfig()
    dcfg.set_video_start_callback(vod_ready_callback)
    d = s.start_download(tdef,dcfg)
	

Simplest tracker session
=========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent') # must have us as a tracker
    s.add_to_internal_tracker(tdef)
	

Rationale
=========
The core API is inspired by the libtorrent interface but makes all 
configurations first-class objects such that they can be independently 
manipulated (i.e., loaded, saved, set as default). Making configurations first-
class objects requires special measures because of their dual nature. First, 
when the download engine or individual download has not yet started, 
configurations are more or less (key,value) pairs. Second, when the downloads
have started the configuration represents actual parameters in the download
engine, and when config parameters are changed one expects that
the engine's behaviour also changes directly.

To support configs as first-class objects we therefore distinguish between 
startup and runtime configs. A runtime config is associated with the download 
engine via a Session or Download object. Changing the values of a runtime config
will alter the behaviour of the download in a thread safe way. 

Thread Safety
=============
All calls to Session, Download and DownloadState are thread safe. Startup 
configs are not thread safe. To prevent concurrency issues, startup 
configs passed to a Session/Download object are first copied and the copy then
becomes the runtime config. When passing an startup config as argument it may 
not be modified  concurrently. Runtime configs are thread safe, as just 
mentioned. Note that changes to runtime configs (i.e., changing upload
limit) are asynchronous, i.e., they will be scheduled on the network thread
and thus may or may not be executed when the method returns. In the future,
should the need arise, errors in changing a runtime config may be reported
via a callback. 


Persistence Support
===================
We use the Python pickling mechanism to make objects persistent. We add a
version number to the state before it is saved. To indicate serializability
classes inherit from the Serializable interface.  For a Session there is a 
special checkpointing mechanism. 


Session Object
==============
At the moment, we use a singleton Session, i.e., there is only one instance
of the Session class in a process. Theoretically, Session can be a real class 
with multiple instances. For implementation purposes making it a Singleton is 
easier, as a lot of our internal stuff are currently singletons (e.g. databases
and *MsgHandler, etc.)

Modifiability of parameters
===========================
Many configuration parameters may be modified at runtime. Some parameters may
be theoretically modifiable but implementing this behaviour may be too complex.
For example, changing the destination dir of a download a runtime is possible,
but complex to implement. The class definitions indicate which parameters are 
runtime modifiable, and points of attention. 

Note that some parameters should be modified with great care. For example.
the listen = tracker port of a Session can be easily modified, but if the 
Session had been used to create new torrents that have been distributed to Web
sites, you cannot simply change the listening port as it means that all torrent 
files out in the world become invalid.



-----------------------------------------------------------------------------
TODO:

- queuing of torrents that get activated when others' upload low?
    This relates to unsupervised usage: people turn on tribler,
    add a couple of torrents to download and then go away, expecting
    them all to be finished, perhaps with priority.
    Same for seeding: Tribler now allows seeding up to specific ul/dl ratio,
    for a specified period of time.
    
    We can leave this up to the API user, just providing the mechanism
    or offer a standard model.
    
    Freek says: leave out of core. My addition: OK, but offer standard
    modules that work on core that use this.
    One implication is that we don't have a set_max_upload() on Session level,
    just Download.
    
- local/global ratelimiter
    What is a good policy here? Dividing a global max over the number of 
    torrents may not be ideal, if some torrents don't achieve their allocated
    speed, perhaps others could have used it.
    
    ABC/Scheduler/ratemanager appears to do this. Arno, 2007-10-19: A port of 
    this to the triblerAPI failed, funky algorithmics. Added an extensible rate 
    mgmt mechanism and a simple rate manager.

- Create a rate manager that gives unused capacity to download that is at max
        See UserDefinedMaxAlwaysOtherwiseDividedOnDemandRateManager. 
        Need to TEST

- Is there a state where the file complete but not yet in order on disk?
      Don't think so.

- Reimplement selected_files with existing 'priority' field

- *Config: some values will be runtime modifiable, others may be as well
    but hard to implement, e.g. destdir or VOD.
    SOL: We throw exceptions when it is not runtime modifiable, and 
    document for each method which currently is. TODO: determine which and 
    document.


- Move all sourcecode to a tribler dir? So we can do:
    import Trible.Core.API as tribler
    s = tribler.Session()
    etc.

	Arno, 2008-1-17: Done.
	    

- persistence
 
    pstate: save TorrentDef rather than metafinfo? to be consistent?
    Saving internal state is more flex
    Saving objects is easier, but potentially less efficient as all sort of temp
    junk is written as well
    
    Arno, 2007-11-9: Saving internal state.
    

- Add ability to run a standalone tracker based on API
	Arno, 2008-1-17: Done.

- Test VOD quick startup with multi-file torrent. PiecePicker.am_I_complete is
  about whole file. This causes complete files in multi-file torrents to
  be played via HTTP instead of from file. Thus .movs won't play at all.
  	TODO
  	

- BT1/Connecter: if 'cache' in config and config['cache']: 
- BT1/Rerequester: if 'dialback' in self.config and self.config['dialback']: 
  -> We expect Session config here
	Done, Jelle now copies session config to dlconfig


- VOD: Check why prebuf pieces not obtained and implement rerequest of pieces
  if needed.
      See PiecePickerVOD: self.outstanding, need to tweak further, especially
      for "wild" torrents (i.e., not supported by publisher via seeders)

- Determine what are fatal errors for a tracker and move to 
  DLSTATUS_STOPPED_ON_ERROR if they occur. Currently all tracker errors are
  put in log messages, and the download does not change status.
  	TODO

- Expose the fact that playback is about to freeze to API user, such that
  he can take action. In particular, he may want to pause the video player
  before it runs out of data, such that he can resume it at that exact point.
  This may be needed as the video players behaviour on running out of data
  may be undesirable. E.g. VLC upon receiving data again will try to fast
  forward to the point where the playback is supposed to be according to
  the video's internal timestamps. I.e. it will not just continue playing
  from the point where it froze.

  ALTERNATIVE: see if VLC has some startup option that says: "stop clock
  if no data"
  	Arno, 2007-12-5: There is a --no-drop-late-frames option which,
  	doesn't appear to work. See perhaps also --no-skip-frames
    and --quiet-synchro

    Arno, 2008-1-17: We now go into prebuffering before we run out of
    time.

- Write unit tests for API
	TODO

- Add SingleInstance checker for p2player, i.e., revamp interconn.py to 
  make general SingleInstance checker and use it in p2player (and Main)
  	Arno, 2008-2-6: Done

- Allow VOD when first part of file hashchecked? For faster start of playback
	TODO

- Adjust VideoOnDemand, such that when the download speed is < bitrate, but
  a large part of the video is already in, i.e. prebuffer+20 secs (or even
  just the 20 sec prebuffer) that it already starts to play, hoping we'll
  catch up the bitrate in that period.
  	TODO

- Make sure torrent gets removed from internal tracker when Download is 
removed.
	Arno, 2008-1-17: Done.

- Have separate $HOME/.Tribler and $HOME/.SwarmPlayer?
	Arno, 2008-2-5: Separate. Also diff port,

- Allow user seeking: i.e., allow user to set hi/mid/low priority set
to some point in the future.

- SwarmPlayer's VideoPlayer still reads old config to determine int/ext player.
   I hacked around it, but it needs to be cleaned up.
   
- Search for TEMPARNO tags to see if stuff needs fixing.
     Arno: mostly done. See VideoPlayer about EXTENSIONS
     
- Replace ffmpeg.exe and VLC with newer version
     
- Make sure dest filenames on Win32 cannot exceed 255 chars. See
  download_bt1.py saveAs     =======
- Fix create live torrent such that:
	- The name of the stream is settable
    - We create unique infohashes (consequence of above, but may need more uniqueness
      to make it foolproof (disadv of more uniqueness is that making live torrents
      becomes non-reproducible)
    - Get rid of info-less empty pieces, see if we can use Merkle torrents

- Tool to seed live stream
    
- HTTP seeding in the version that does not require server-support

- See how people can modify the SessionConfig after the session is created.



TODO SQLLITE:
    
 - check links to BT engine e.g. RESERVE_PIECES + PiecePicker

    - MetaData: call_dlhelp_task: Done.
    - 2fast: Done (ugly)

 - special case: Dialback & ReturnConnHandler
     Done.

 - connect_dns() special case?
       Yes. We use the SecureOverlay directly to create a overlay connection
       to a Tribler peer we meet in a swarm. We can do this as connect_dns()
       doesn't need a database.
       Done.
 
 - get rid of all rawserver things in olapps, should use 
   OverlayThreadingBridge.add_task()
       Done.
       
- Make sure that RemoteQueryMsgHandler uses SQLlite and not TorrentDataManager

- Check RemoteTorrentHandler: make sure it is run by right thread and uses DB 
  and not TorrentDataManager
  	Assigned to Arno
  	
  	TODO: determine how Core user accesses this functionality.
  	Need Session method to call this function, and need mechanism to report back
  	received torrent.
  		Done, TODO = TEST
  	
  	Same holds for RemoteQuery: need Session method for sendQuery 
  	

- Allow Core user to access DB: add getPeerDB to Session, make sure it
  handles separate-db-conn-per-thread issue.
  	Arno + Jie together

- Check all DBHandler usages and see if the db object uses the DB connection
  for the thread that accesses the database. I've marked some with LITETHREAD 
  tags. 
  	Delegated to Jie. Handled via DBconn table. TODO: Closing of databases.

- Write to bartercast DB?
	Done
  
- Add torrents started with Session.start_download() to torrent_db
      
      CAREFUL: Make sure it is not network thread that access DB.
      Should not be a problem: The MetadataHandler that calls
      start_download() for a coop download is run by OverlayThread
      
      *Ask Jie to do this*, DB code unclear. SqliteCacheDBHandler has
      addExternalTorrent that does something like MetadataHandler
      addTorrentToDB, but is not used anywhere. And doesn't call DB!

- Get rid of MyPermID, MyIP and MyPeerInfo from SQLite MyDBHandler

	Arno: I once mailed Jie about this. This info is now kept
	in state_dir/ec*.pem, determined dynamically, or stored in
	Session config (nickname), respectively. There must not be 
	duplication in a DB.
	
	Also: why is there an index on MyInfo, if it just contains
	1 entry.
	   
	   
- Read docs for Database LockedException that is troubling Jie.	   

- Check for LITETHREAD and LAYERVIOLATION comments

C:\build\newmain>svn merge -r 6302:6877 https://svn.tribler.org/abc/branches/a
rno/d07-12-11-secover-threaded-from-mb-r6302 > mergelog.txt 2>&1

- Commit my secover-threaded and merge to mainbranch

- Install pysqlite2 / switch to Python 2.5 <-- Good idea to do now.
  Switch to latest M2Crypto, OpenSSL, wxWidgets

- Can somebody clarify the status of the Mugshotmanager? There is a now
an vwx_GUI/IconsManager and MM was moved to Tribler.Core.CacheDB.

- Let RemoteQueryHandler use usercallback to report hits and use
the database to resolve queries.


TODO MAIN CLIENT:

- See all ARNOCOMMENT issues

- Let all code use Tribler.Core.API as sole import.

- Let TorrentMaker use TorrentDef funcs.

