# Written by Arno Bakker 
# see LICENSE.txt for license information

triblerAPI v0.0.4rc1
Dec 5, 2007 

Using Python style guide

Simplest download session
=========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent')
    d = s.start_download(tdef)
    
Simpler download session
========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent')
    d = s.start_download(tdef)
    d.set_state_callback(state_callback)
    
def state_callback(ds):
	# Called by new thread
    d = ds.get_download()
    print `d.get_def().get_name()`,ds.get_status(),ds.get_progress()
    print ds.get_error()
    print "up",ds.get_current_speed(UPLOAD),"down",ds.get_current_speed(DOWNLOAD)
    return (5.0,False)


Simpler download session
========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent')
    dcfg = DownloadStartupConfig()
    dcfg.set_dest_dir('/tmp')
    d = s.start_download(tdef,dcfg)


Simple VOD download session
===========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent')
    dcfg = DownloadStartupConfig()
    dcfg.set_video_start_callback(vod_ready_callback)
    dcfg.set_selected_files('part2.avi') # play this video
    d = s.start_download(tdef,dcfg)
    
def vod_ready_callback(download,mimetype,stream,filename):
    # Called by new thread 
    while True:
        data = stream.read()
        if len(data) == 0:
            break
        outstream.write(data)
    stream.close()

CAUTION: We may add more video-on-demand callback functions to be able
to signal to the API user that a video is about to stall. At the moment
this can also be gathered via the DownloadState. If state.get_vod_playable()
becomes False after the first video-start callback, the download engine
switched to prebuffering again.


Simplest seeding session
========================
    s = Session().get_instance()
    tdef = TorrentDef()
    tdef.add_content('/tmp/homevideo.wmv')
    tdef.set_tracker(s.get_internal_tracker_url())
    tdef.finalize()
    dcfg = DownloadStartupConfig()
    dcfg.set_dest_dir('/tmp')
    d = s.start_download(tdef,dcfg)


Simpler seeding session
=======================
    s = Session().get_instance()
    tdef = TorrentDef() 
    tdef.add_content('/tmp/homevideo.wmv')
    tdef.set_thumbnail('/tmp/homevideo.jpg')
    tdef.set_tracker(s.get_internal_tracker_url())
    tdef.finalize()

    dcfg = DownloadStartupConfig()
    dcfg.set_dest_dir('/tmp')
    d = s.start_download(tdef,dcfg)

Simple Live broadcast session
=============================
    s = Session().get_instance()
    tdef = TorrentDef()
    tdef.create_live(bitrate) 
    tdef.set_tracker(s.get_internal_tracker_url())
    tdef.finalize()
    
	dcfg = DownloadStartupConfig()
	dcfg.set_video_source(stream)
	s.start_download(tdef,dcfg)
	
To watch:
---------
    s = Session()
    tdef = TorrentDef.load('/tmp/live.torrent')
    dcfg = DownloadStartupConfig()
    dcfg.set_video_start_callback(vod_ready_callback)
    d = s.start_download(tdef,dcfg)
	

Simplest tracker session
=========================
    s = Session()
    tdef = TorrentDef.load('/tmp/bla.torrent') # must have us as a tracker
    s.add_to_internal_tracker(tdef)
	

Rationale
=========
The core API is inspired by the libtorrent interface but makes all 
configurations first-class objects such that they can be independently 
manipulated (i.e., loaded, saved, set as default). Making configurations first-
class objects requires special measures because of their dual nature. First, 
when the download engine or individual download has not yet started, 
configurations are more or less (key,value) pairs. Second, when the downloads
have started the configuration represents actual parameters in the download
engine, and when config parameters are changed one expects that
the engine's behaviour also changes directly.

To support configs as first-class objects we therefore distinguish between 
startup and runtime configs. A runtime config is associated with the download 
engine via a Session or Download object. Changing the values of a runtime config
will alter the behaviour of the download in a thread safe way. 

Thread Safety
=============
All calls to Session, Download and DownloadState are thread safe. Startup 
configs are not thread safe. To prevent concurrency issues, startup 
configs passed to a Session/Download object are first copied and the copy then
becomes the runtime config. When passing an startup config as argument it may 
not be modified  concurrently. Runtime configs are thread safe, as just 
mentioned. Note that changes to runtime configs (i.e., changing upload
limit) are asynchronous, i.e., they will be scheduled on the network thread
and thus may or may not be executed when the method returns. In the future,
should the need arise, errors in changing a runtime config may be reported
via a callback. 


Persistence Support
===================
We use the Python pickling mechanism to make objects persistent. We add a
version number to the state before it is saved. To indicate serializability
classes inherit from the Serializable interface.  For a Session there is a 
special checkpointing mechanism. 


Session Object
==============
At the moment, we use a singleton Session, i.e., there is only one instance
of the Session class in a process. Theoretically, Session can be a real class 
with multiple instances. For implementation purposes making it a Singleton is 
easier, as a lot of our internal stuff are currently singletons (e.g. databases
and *MsgHandler, etc.)

Modifiability of parameters
===========================
Many configuration parameters may be modified at runtime. Some parameters may
be theoretically modifiable but implementing this behaviour may be too complex.
For example, changing the destination dir of a download a runtime is possible,
but complex to implement. The class definitions indicate which parameters are 
runtime modifiable, and points of attention. 

Note that some parameters should be modified with great care. For example.
the listen = tracker port of a Session can be easily modified, but if the 
Session had been used to create new torrents that have been distributed to Web
sites, you cannot simply change the listening port as it means that all torrent 
files out in the world become invalid.



-----------------------------------------------------------------------------
TODO:

- queuing of torrents that get activated when others' upload low?
    This relates to unsupervised usage: people turn on tribler,
    add a couple of torrents to download and then go away, expecting
    them all to be finished, perhaps with priority.
    Same for seeding: Tribler now allows seeding up to specific ul/dl ratio,
    for a specified period of time.
    
    We can leave this up to the API user, just providing the mechanism
    or offer a standard model.
    
    Freek says: leave out of core. My addition: OK, but offer standard
    modules that work on core that use this.
    One implication is that we don't have a set_max_upload() on Session level,
    just Download.
    
- local/global ratelimiter
    What is a good policy here? Dividing a global max over the number of 
    torrents may not be ideal, if some torrents don't achieve their allocated
    speed, perhaps others could have used it.
    
    ABC/Scheduler/ratemanager appears to do this. Arno, 2007-10-19: A port of 
    this to the triblerAPI failed, funky algorithmics. Added an extensible rate 
    mgmt mechanism and a simple rate manager.

- Create a rate manager that gives unused capacity to download that is at max
        See UserDefinedMaxAlwaysOtherwiseDividedOnDemandRateManager. 
        Need to TEST

- Allow VOD when first part of file hashchecked? For faster start of playback

- Is there a state where the file complete but not yet in order on disk?
      Don't think so.

- Reimplement selected_files with existing 'priority' field

- *Config: some values will be runtime modifiable, others may be as well
    but hard to implement, e.g. destdir or VOD.
    SOL: We throw exceptions when it is not runtime modifiable, and 
    document for each method which currently is. TODO: determine which and 
    document.


- Move all sourcecode to a tribler dir? So we can do:
    import Trible.Core.API as tribler
    s = tribler.Session()
    etc.

	Arno, 2008-1-17: Done.
	    

- persistence
 
    pstate: save TorrentDef rather than metafinfo? to be consistent?
    Saving internal state is more flex
    Saving objects is easier, but potentially less efficient as all sort of temp
    junk is written as well
    
    Arno, 2007-11-9: Saving internal state.
    

- Add ability to run a standalone tracker based on API
	Arno, 2008-1-17: Done.

- Test VOD quick startup with multi-file torrent. PiecePicker.am_I_complete is
  about whole file.
  	TODO

- BT1/Connecter: if 'cache' in config and config['cache']: 
- BT1/Rerequester: if 'dialback' in self.config and self.config['dialback']: 
  # WE EXPECT SESSION CONFIG HERE
	Done, Jelle now copies session config to dlconfig


- VOD: Check why prebuf pieces not obtained and implement rerequest of pieces
  if needed.
      See PiecePickerVOD: self.outstanding, need to tweak further, especially
      for "wild" torrents (i.e., not supported by publisher via seeders)

- Determine what are fatal errors for a tracker and move to 
  DLSTATUS_STOPPED_ON_ERROR if they occur. Currently all tracker errors are
  put in log messages, and the download does not change status.
  	TODO

- Expose the fact that playback is about to freeze to API user, such that
  he can take action. In particular, he may want to pause the video player
  before it runs out of data, such that he can resume it at that exact point.
  This may be needed as the video players behaviour on running out of data
  may be undesirable. E.g. VLC upon receiving data again will try to fast
  forward to the point where the playback is supposed to be according to
  the video's internal timestamps. I.e. it will not just continue playing
  from the point where it froze.

  ALTERNATIVE: see if VLC has some startup option that says: "stop clock
  if no data"
  	Arno, 2007-12-5: There is a --no-drop-late-frames option which,
  	doesn't appear to work. See perhaps also --no-skip-frames
    and --quiet-synchro

    Arno, 2008-1-17: We now go into prebuffering before we run out of
    time.

- Write unit tests for API
	TODO

- Add SingleInstance checker for p2player, i.e., revamp interconn.py to 
  make general SingleInstance checker and use it in p2player (and Main)
  	Arno, 2008-2-6: Done

- Adjust VideoOnDemand, such that when the download speed is < bitrate, but
  a large part of the video is already in, i.e. prebuffer+20 secs (or even
  just the 20 sec prebuffer) that it already starts to play, hoping we'll
  catch up the bitrate in that period.
  	TODO

- Make sure torrent gets removed from internal tracker when Download is 
removed.
	Arno, 2008-1-17: Done.

- Have separate $HOME/.Tribler and $HOME/.SwarmPlayer?
	Ask Jelle
	Arno, 2008-2-5: Separate.

- Allow user seeking: i.e., allow user to set hi/mid/low priority set
to some point in the future.

- SwarmPlayer's VideoPlayer still reads old config to determine int/ext player.
   I hacked around it, but it needs to be cleaned up.
   
- Search for TEMPARNO tags to see if stuff needs fixing.

- More than 1 download seeding:
   ISSUE: What if person started download but closed app before end.
   It may mean he didn't like it, so we should not redistribute it further.
  
   ISSUE: when user start downloading a torrent that is already being seeded.
   	Arno: We remove the download before starting the new instance, without
   	deleting the downloaded content.
   
   ISSUE: when restarting download, make sure it's not running in VOD mode.
     Arno: The mode is now explicitly reset to DLMODE_NORMAL.
  
  Plan:
     Wait till current download is seeding.
     Then load Session checkpoint
     And limit upload speed of Session to user-specified limit.
     
     
  Arno: let's postpone this, first build stable version for 14 feb.
  